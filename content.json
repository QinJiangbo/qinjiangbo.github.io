{"meta":{"title":"秦江波的个人博客","subtitle":"DON'T BE THE SAME, BE BETTER!","description":"秦江波的个人博客","author":"QinJiangbo","url":"http://qinjiangbo.com"},"pages":[{"title":"一名正在路上的全栈工程师","date":"2016-08-11T16:55:57.000Z","updated":"2018-04-02T09:27:19.000Z","comments":true,"path":"about/index.html","permalink":"http://qinjiangbo.com/about/index.html","excerpt":"","text":"DON’T BE THE SAME, BE BETTER! 博客背景你好，欢迎来到秦江波的博客！本博客是我自2014年开始写博客以来的第三次搬迁。我想，凡是像我们搞技术的可能都会经过三个阶段： 一、采用CSDN或者51CTO等博客网站写博客并且发表文章；二、觉得使用别人的东西不灵活，还是自己搭建一个博客系统，于是捣鼓捣鼓，采用了Typecho或者Wordpress搭建一个博客系统；三、每个月上300左右的云服务器费用实在hold不住，但还是想自己搭建博客，怎么办？这就是本博客的到来了。Github+Hexo组建而成的博客系统。 个人简介从以上的介绍中你可能会觉得博主是一个很爱捣鼓事情的人，对此，我只想对你说，恭喜你，答对了！嗯！正式介绍博主身份啦！ 博主24岁，2016年毕业于武汉大学国际软件学院，软件工程专业学士学位，九月（2016年09月）继续在武汉大学攻读硕士学位。关于博主研究生涯的规划主要有以下几点： 继续广泛阅读技术方面的书籍，涉猎不同的技术面，并在算法，架构以及Linux等方面继续进行深入地学习和研究。 大的方向重点研究机器学习，数据挖掘，搜索引擎和人工智能相关的技术。 持续更新博客，以及微信公众号（下面会贴出二维码），与大家分享自己的所思所想。并尝试撰写大量的系列教程，以帮助更多在技术上遇到困难的同学，同时也是博主与大家相互学习的过程！ 每天坚持向Github提交代码，保证自己每天能够敲一定质量的代码，争取保证一年下来代码编写率高达99%，相信坚持下去总会有回报！ 和女朋友一直保持良好的恋爱关系，不管怎么样，两个人在一起最重要，争取毕业领证！ 以上其中几条已经开始执行实施了，也希望大家在新的一个环境下和心境下奋力拼搏取得更大的成就！ 微信公众号“全栈日记” 书单更新1). 机器学习 《机器学习》是之前看到的还不错的一本书，对机器学习的初学者非常的友好！建议大家都去读一读，有数学基础的最好！应该说本书作者周志华将机器学习的门槛进一步地拉低了，方便我们大家好踏入机器学习的大门！强烈推荐！ 2). 重构 《重构》是我认为是Java程序员从基础到中高级水平的必经之路，里面针对日常开发中的种种问题列举出来，所以，很多时候我看到这里面的内容时候，会惊叹，诶！他们也是这么想的诶！现在，程序员对自己的要求不能仅限于写对代码，而是写好代码！这本书通过一些浅显的例子为我们介绍了重构的几十种原则。另外，本书强调一点，重构应该是随时随地进行的，而不应该放到某个特定的时刻去做。我相信这本书不会让你后悔！ 3). 高性能MySQL 《高性能MySQL》是我之前一直想读的一本书，在豆瓣和知乎的评价高，也是淘宝的高级数据库产品专家翻译的，语言的表述非常准确。这本书最大的亮点在于将数据库优化理论与企业数据库实践相联系，使我们对整个数据库的应用有了一个更清晰的了解。另外，本书中大量的代码示例对于我们编写高效SQL以及可维护性的SQL有非常大的指引作用。不管是想了解原理还是需要立马投入实战，这本书都应该值得你好好考虑！ 4). HTTP权威指南 《HTTP权威指南》详细解释了HTTP协议，包括他是如何工作的，如何利用它来开发基于Web的应用程序。但是这本书不仅仅限于介绍这些HTTP技术是如何应用的，而是更加深层次的讲解了HTTP背后的核心技术原理。这是这本书的一个最大的亮点。这本书由具有多年实践经验的专家编写的，详细说明了Web上每一条HTTP请求的实际运行情况。不管你是从事前端还是后台开发，亦或是移动端开发，我认为这本书你也应该好好读一读，会让自己受益匪浅！ 以上是我最近读的一些书籍，后面会不断地更新正在阅读的书单的，敬请关注！ 永远的国际三班"}],"posts":[{"title":"05计算广告笔记-搜索与竞价广告","slug":"05-notes-of-computational-ads-search-bidding-ads","date":"2018-09-29T08:02:58.000Z","updated":"2018-10-05T04:27:52.541Z","comments":true,"path":"05-notes-of-computational-ads-search-bidding-ads.html","link":"","permalink":"http://qinjiangbo.com/05-notes-of-computational-ads-search-bidding-ads.html","excerpt":"","text":"随着搜索业务变现的要求，以及精准受众定向技术的发展，在搜索广告和展示广告中都产生了竞价这种新的交易模式。对比前面的合约广告可知，竞价交易模式的本质是将量的约束从交易过程中去除，仅仅采用“价高者得”的简单决策方案来投放每一次广告。竞价顺应了定向广告向精细化发展的趋势要求，也为大量无法用合约售卖的剩余流量找到了可能的变现渠道，使得大量中小广告主参与在线广告的可能性和积极性大大增强，也使得在线广告的商业环境与传统广告产生了本质区别。 在竞价广告的交易逻辑下，展示广告领域也产生了广告网络这种批量采购各种媒体剩余流量，然后主要按照点击付费的方式售卖给广告主的产品形式。这种产品形态的产生对于提高整个展示广告市场的流动性发挥了很大作用。广告网络中竞价的标的物有两种： 一是上下文页面中的关键词，这是直接从搜索广告衍生而来的； 二是根据用户行为加工的兴趣标签，这是从展示广告的定向逻辑发展而来的。 对应于竞价广告的产生，需求方的产品和技术也在发生变化。其中关键的变化有两点：一是由面向广告位采买变成面向人群的跨网络采买；二是帮助广告主在竞价环境中完成量的保证，这一点是竞价市场不再直接保证的。能达到这些需求方目的的产品我们叫作媒体采买平台。在媒体采买平台里，在量的约束下完成 ROI 的优化的问题依然存在，并且变得比在线分配问题更加困难，这也成为高端的采买平台提供的服务之一。当然，搜索广告的媒体采买和 ROI 优化同样十分重要，这项专门的服务称为搜索引擎营销(Search Engine Marketing，SEM)。 搜索广告搜索广告是比较典型的竞价广告产品，其特点是广告主就某标的物(在这里是关键词)的广告展示机会展开拍卖式的竞争，并根据竞争结果依次占据该广告展示的若干位置。 搜索广告产品形态搜索广告是以上下文查询词为粒度进行受众定向，并按照竞价方式售卖和 CPC 结算的广告产品。通常，搜索广告展示在搜索结果页，下图所示。搜索广告创意的展示区域一般来说分为北(north)、东(east)、南(south)三个部分。北区和东区的所有位置构成同一次关键词拍卖的位置集合，竞价时位置的排序为{north 1 ，north 2 ，···，east 1 ，east 2 ，···}，这基本上是根据各个位置点击率的高低排列的。 在互联网广告的整个产品谱系当中，搜索广告有着特殊重要的地位，具有以下鲜明的产品和技术特点。 搜索广告的变现能力，即 eCPM 远远高于一般的展示广告，其市场重要程度也就得以彰显。而搜索广告高变现能力最关键的产品原因就是用户主动输入的查询直接反映了用户的意图。 搜索广告的受众定向标签，即是上下文的搜索查询。由于搜索词非常强地表征着用户的意图，搜索广告可以进行非常精准的定向。 搜索广告的展示形式与自然结果的展示形式非常接近，往往仅仅在底色和文字链接中有不太引人注目的提示。这样的产品设计使得它有原生广告的意味，也进一步提高了广告效果。 从搜索广告发展起来的竞价交易模式已经逐渐发展成为互联网广告最主流的交易模式。这一模式从根本上改变了广告的运营方法，并为其效果的快速提高释放出巨大的生产力。 搜索广告产品新形式搜索广告的产品技术重点与前面介绍的合约广告差别很大，与竞价的展示广告网络也有一定的差别。从产品设计的角度看，搜索广告有以下三方面的探索趋势。 丰富文字链创意的展示形式让其更富表现力以提高点击率。 利用东区对相关性要求稍低的特点设计一些拓展广告产品。 优化广告与自然结果的关系在保证相关性和广告效果的前提下提高收入。 搜索广告产品策略除了产品形式上的创新，搜索广告的投放和优化策略也是产品的重要一环。搜索广告的整个决策过程可以分为查询扩展、检索、排序、放置、定价等几个阶段。查询扩展是搜索广告独有的策略，目的是给广告主自动地拓展相关的查询词，扩大采买流量；广告检索和将候选广告根据 eCPM 排序是广告系统较为通用的核心流程；而定价是竞价广告非常核心的策略。 查询扩展是搜索广告的一项关键策略。对广告主来说，从浩若烟海的关键词中找到符合自己需求的组合绝非易事。因此，搜索引擎会提供一些将广告中的关键词匹配到更多相关查询的服务。 北区是黄金的广告展示位置，对于搜索广告的收入至关重要。一般来说，通用搜索引擎的广告收入中绝大部分都来自于北区，因此北区广告的平均条数与收入直接相关。确定一条广告能否进入北区要考虑两个关键因素：一是该广告相关性是否足够(确保用户体验)；二是该广告的 RPM 是否足够(高效地利用展示位置)。 位置拍卖与机制设计以搜索广告为代表的竞价广告实际上是像拍卖那样销售广告展示机会。也就是说，系统根据广告主的出价以及由此计算出的 eCPM 决定谁可以得到某次展示的广告位。在竞价广告初始阶段，出价是广告主阶段性调整的；而到了广告实时交易阶段，广告主可以对每次展示实时调整出价。 定价问题在线广告竞价市场最常见的定价策略是 GSP 方案；另外有一种 VCG(Vickrey-Clarke-Groves) 定价策略，虽然理论上比 GSP 更合理，但是由于原理较复杂， 向广告主解释起来有难度，因此在实际系统中采用的并不多。 所谓第二高价，指的是在只有一个位置的拍卖中，向赢得该位置的广告主收取其下一位广告主的出价，这样的拍卖也叫作 Vickrey 拍卖。在搜索广告这种有多个位置的拍卖过程中，很容易直觉地将第二高价策略推广成下面的策略：对赢得每一个位置的广告主，都按照他下一位的广告位置出价来收取费用，这就是广义第二高价。 VCG 定价是 Vickrey、Clarke 和 Groves 在研究竞价系统均衡状态时得到的一 种理论上较为优越的定价策略。其基本思想是：对于赢得了某个位置的广告主，其所付出的成本应该等于他占据这个位置给其他市场参与者带来的价值损害。 市场保留价为了控制广告的质量和保持一定的出售单价，竞价广告市场往往要设置一个赢得拍卖位置的最低价格，这一价格我们称为市场保留价(Market Reserve Price，MRP)，俗称“起价”或“底价”。广告主的出价只有在高于市场保留价时才能获得竞价机会，同时在赢得某个拍卖位置后，如果根据定价策略算出的付费低于市场保留价(以广义第二高价为例，很容易验证这种情况是可能发生的)，也需要调整到市场保留价的水平上。 广告网络竞价广告产品在搜索广告逐渐成熟的同时也在展示广告领域得到了广泛应用。对展示广告而言，合约式的售卖方式必然无法消耗所有的库存，实际销售中为了控制售卖比例以获得更高的品牌溢价空间，未通过合约售卖的广告流量很多。这部分流量我们称为剩余流量(remnant inventory)。竞价交易模式的产生为这部分流量提供了变现的机会，催生了广告网络这一产品。广告网络的产品功能是批量聚合各媒体的剩余流量，按照人群或上下文标签的流量切割方式售卖给广告主。 根据人群划分模式的不同，广告网络产品其实有两个来源：一方面来源于搜索引擎发展出来的上下文广告产品，即根据页面中提取的关键词来投放广告；另一方面来源于展示广告的兴趣标签向精细化发展后。无论上下文还是兴趣，都可以看成是对受众的划分方式，因而它们都统一在广告网络这一产品中。 竞价广告网络有下面几个关键的产品特点： 竞价方式不向广告主做量的约定，而是根据变现能力，即 eCPM，来决定每次展示分配给哪个广告主。 由于是按人群售卖，广告网络会极力淡化媒体和广告位的概念。由于淡化了媒体的概念，广告网络中很难拿到品牌溢价高的广告位，一般来说也不适合广告主的品牌类需求。 从商业角度来看，广告网络的销售模式与合约的方式相比也有两点优势：首先是无需再满足广告主品牌独占的要求，这使得让国美和苏宁同时参与同一个人群的竞价、提高市场流动性成为可能，而在合约广告中，这一点是很难做到的；其次，由于广告网络根据实际消耗来结算，一般来说财务上采用广告主先充值的方式，这区别于合约广告投放结束后计算的方式，结果使得广告网络运营方的现金流状况大为改善。 CPC 结算的合理性首先，从需求方来看，既然是各种媒体的不同广告位聚合在一起售卖，广告主无法知道每个媒体上广告的具体位置。而位置对于广告的曝光效果影响巨大，因此实际上广告主根本无法评估每次展示的出价，而在点击上出价，这个问题就没那么严重了。 另外从供给方来看，由于淡化了广告位的概念，并且聚合了多个媒体的流量，广告网络可以接触到同一个用户比较丰富的网络行为，并且知道每次展示所在的媒体与广告位位置，所以比广告主更容易估计点击率， 由广告网络负责估计点击率，需求方根据对点击价值的估计来出价，是最合理的市场分工。 广告网络产品策略广告网络中的广告决策过程与搜索广告相比，整个流程要简单一些，如下图所示，分为检索、排序、定价等几个阶段。 广告检索。广告与搜索面对的文档其实不同，它往往是一个用布尔表达式表达的投放条件，而不是可以简单看成一个词的集合。搜索那样的面向词集合的检索方案对布尔表达式来说不是最有效的。搜索广告检索与搜索基本一致，用常规的倒排索引技术就可以解决。展示广告网络与搜索广告不同，由于用户意图不明确，我们往往要将更多的关键字、兴趣标签同时用于检索过程，而实践也证明，使用更多的标签对于提高效果是有直接帮助的。 广告排序。我们都知道，竞价广告中排序的准则是 eCPM，而在 CPC 结算的情形下，对 eCPM 的估计转化为对点击率的估计问题。与广告位较规整、点击率较高的搜索广告相比，广告网络中的 CTR 预测有两方面的困难。首先，点击数据更加稀疏，而且需要同时考虑上下文和用户量方面的信息，这使得各种新广告、新策略的冷启动问题非常突出。如何设计好一个合理可行的冷启动策略，对展示广告网络来说至关重要。其次，广告网络中由于广告位的差别巨大，点击率的变动范围很大，这使得稳健地估计点击率变得相对困难。我们在后面讨论点击率预估技术时将主要以展示广告的复杂情形为场景展开讨论，并将其与搜索广告的特例对比。 竞价广告需求方产品搜索广告和竞价广告网络虽然效果差别很大，但从产品本质上看，属于同一范畴。竞价广告市场的产生对需求方的技术也提出了新的要求：原来通过直接与媒体签订保量合约的采买方式变成通过竞价为广告主完成量与质需求的采买产品。具体地说，这样的产品需要具备一项基本功能，即按照广告主预算跨媒体一站式采买人群的功能。另外，还可以具备一项高级功能，即机器决策的 ROI 优化功能。 这样的需求可以分解为两个基本问题：一是如何挑选合适的目标人群，二是如何对各个目标人群给出合适的出价。 搜索引擎营销(SEM)搜索广告对应的需求方产品，即通过竞价采买搜索引擎关键词来做推广，这就是搜索引擎营销，即 SEM。上面说的两个基本问题在 SEM 中具体表现为关键词选择和出价。 关键词选择。搜索引擎进行查询扩展的目的是为了提高自己的营收；而需求方进行关键词选择的目的是为了提高广告主采买流量的 ROI。对于大量长尾的小型广告主，往往比较难于积累起足够的数据用于优化，因此这类 SEM 公司服务的对象主要是中型以上的广告主。 出价。传统的认识是广告主根据到达率、自己网站的转化率和客单价来估计点击价值，并以此点击价值为参考来出价。不过这忽略了一个问题，那就是各个关键词的转化率、客单价和市场竞争水平都有很大的区别，因此只有在不同关键词上做不同的出价才能更深入地优化整体采买的 ROI。 媒体购买平台虽然概念类似，但是媒体采买平台的难点与 SEM 有所不同。媒体采买平台的技术挑战主要在于 ROI 的优化部分，要合理地选择需要的受众定向条件，并在每个人群上优化出价，以保证量的要求和优化收益是一个复杂的组合优化问题。","categories":[{"name":"计算广告","slug":"计算广告","permalink":"http://qinjiangbo.com/categories/计算广告/"}],"tags":[{"name":"搜索广告","slug":"搜索广告","permalink":"http://qinjiangbo.com/tags/搜索广告/"},{"name":"竞价广告","slug":"竞价广告","permalink":"http://qinjiangbo.com/tags/竞价广告/"}]},{"title":"04计算广告笔记-合约广告","slug":"04-notes-of-computational-ads-contract-ads","date":"2018-09-29T07:08:02.000Z","updated":"2018-09-29T07:59:22.289Z","comments":true,"path":"04-notes-of-computational-ads-contract-ads.html","link":"","permalink":"http://qinjiangbo.com/04-notes-of-computational-ads-contract-ads.html","excerpt":"","text":"互联网广告业务的初始阶段，拥有流量的媒体与需要广告资源的代理商是市场的主要参与者。线下广告的商业逻辑也被照搬到了线上，由广告代理公司和媒体签订协议，确保某些广告位在某时间段为指定的广告商所占有，同时广告商按整体合同支付广告费用。这种按CPT结算的广告位合约方式对技术的依赖性较小，只需要用到简单的广告排期系统。 合约式广告的重点是按CPM计费的展示量合约广告。这种方式仍然以合同的方式确定一次广告活动的投放总量和展示单价，但是售卖的对象已经由“广告位”进化到了“广告位+ 人群”。这可以说是在线广告发展史上的一个重要里程碑，而数据也被直接应用在广告的商业活动中。从供给方产品和技术的复杂程度来看，CPM合约甚至比以后的竞价系统更加复杂，其复杂性主要来源于多个合约对投放系统提出的量的约束。 在展示量合约广告中，需求方的产品技术并没有太大发展。这是因为所有广告投放的执行要求都以合约的形式交由供给方来完成了，需求方并没有技术上优化的空间。而正是由于需求方对深入优化效果的需求进一步发展，才产生了按照竞价方式来售卖的广告系统。 广告位合约广告位合约是最早产生的在线广告售卖方式。它是指媒体和广告主约定在某一时间段内、在某些广告位上固定投送该广告主的广告，相应的结算方式为CPT。这是一种典型的线下媒体广告投放模式，在互联网广告早期也很自然地被采用。 缺点：无法做到按受众类型投放广告，无法进行深入的效果优化 优点：可以有效地给用户带来品牌冲击，塑造不断攀升的品牌价值和转化效果 广告位的轮播售卖在这种方式中，同一个用户对同一个广告位的一系列访问，被依次标上一组循环的轮播顺序号，如{1，2，3}。将其中具有同样顺序号的展示作为一个虚拟的广告位，售卖给广告主。需要注意的是，对某一个用户而言，第一次展示的顺序号不应该设为1，而是应该按相等概率从所有轮播顺序号中随机选取一个，并从此开始累加和循环。 受众定向在考察某种定向方法时，主要有两个方面的性能需要关注：一是定向的效果，即符合该定向方式的流量上高出平均eCPM的水平；二是定向的规模，即这部分流量占整体广告库存流量的比例。 受众定向方法概论 地域定向(geo-targeting)。这是一种很直觉也很早就被广泛使用的定向方式。由于很多广告主的业务有区域特性，地域定向的作用相当重要，也是所有在线广告系统都必须支持的定向方式。 人口属性定向(demographicaltargeting)。人口属性的主要标签包括年龄、性别、教育程度、收入水平等。人口属性有一点与兴趣标签不同，那就是它是可以监测的，即可以用采样加调研的方法来判断一次人口属性定向广告活动受众中有多少比例是正确的。 频道定向(channeltargeting)。频道定向是完全按照供应方的内容分类体系将库存按照频道划分，对各频道的流量投送不同的广告。 上下文定向(contextualtargeting)。将频道定向这种方法加以推广，可以根据网页的具体内容来匹配相关的广告，这就是上下文定向。上下文定向的粒度可以是关键词、主题，也可以是根据广告主需求确定的分类。 行为定向(behaviorialtargeting)。行为定向是展示广告中非常重要的一种定向方式，其框架是根据用户的历史访问行为了解用户兴趣，从而投送相关广告。 精确位置定向(hyper-localtargeting)。在移动设备上投放广告时，我们有可能获得非常精准的地理位置。 重定向(retargeting)。这是一种最简单的定制化标签，其原理是对某个广告主过去一段时间的访客投放广告以提升效果。显然，某个广告主的访客是其独有的信息，因此这属于定制化标签。重定向被公认为精准程度最高、效果最突出的定向方式，不过其人群覆盖量往往较小。 新客推荐定向(look-aliketargeting)。新客推荐定向的思路是根据广告主提供的种子访客信息，结合广告平台更丰富的数据，为广告主找到行为上相似的潜在客户。 团购(group-purchase)。团购是一种变相的广告形式，这种广告有两个显著的特点：首先是一般都针对区域性的广告主，因此地域定向或者直接按照地域分类组织是必要的功能；另外，团购主要是利用价格工具，直接降低用户在决策阶段的门槛，使得价格敏感的用户转化效果有明显的提升，当然，这一手段也是要付出成本的。 受众定向标签体系选择结构化兴趣标签体系还是非结构化的兴趣标签体系更多地是商业上的决策，主要需要考虑下面两种情形。 当标签作为广告投放的直接标的时(包括CPM广告及竞价广告中直接可被广告主选择的人群)，这些标签既要能够为广告主所理解，又要方便广告主的选择。 当标签仅仅是投放系统需要的中间变量，作为CTR预测或者其他模块的变量输入时，那么结构化的标签体系其实是没有必要的，应该完全按照效果驱动的方式来规划或挖掘标签，而各个标签之间也不太需要层次关系的约束。 展示量合约展示量合约指的是约定某种受众条件下的展示量，然后按照事先约定好的单位展示量价格来结算。这种合约还有一个名称，就是担保式投送即 GD，其中的“担保”指的就是量的约定。实际执行中，在未能完成合约中的投放量时，可能要求媒体承担一定的赔偿。 从供给方和需求方两方面来看这种售卖方式出现的合理性。 媒体从按固定广告位售卖变为按 CPM 售卖，初衷是为了在受众定向的基础上提高单位流量的变现能力，可是面向的仍然是原来的品牌广告主。 广告主按广告位采买时，比较容易预估自己拿到的流量，可是按照人群定向的方式采买，流量有诸多不确定的因素。因此，需求方希望在合约中加入对量的保证，才能放心地采买。 流量预测流量预测在广告产品中包括以下三个主要用途。 售前指导。在展示量合约广告中，由于要约定曝光总数，事先尽可能准确地预测各人群标签的流量变得非常关键。如果流量严重低估，会出现资源售卖量不足的情形；如果流量严重高估，则会出现一部分合约不能达成的状况。这都会直接影响整个系统的收入。 在线流量分配。同样是在展示量合约广告中，由于合约之间在人群选择上会有很多交集，当一次曝光同时满足两个以上合约的要求时，怎样决策将它分配给哪个合约以达到整体满足所有合约的目的，这是下文将要讨论的在线分配问题。 出价指导。在竞价广告中，由于没有了量的保证，广告主往往需要根据自己预计的出价先了解一下可能获得多少流量，以判断自己的出价是否合理。 流量塑型流量预测对于展示量合约非常重要，不过在本质上还是被动地统计流量情况。在有些情形下，我们可以主动地影响流量，以利于合约的达成。这一产品策略问题称为流量塑形(traffic shaping)。","categories":[{"name":"计算广告","slug":"计算广告","permalink":"http://qinjiangbo.com/categories/计算广告/"}],"tags":[{"name":"合约广告","slug":"合约广告","permalink":"http://qinjiangbo.com/tags/合约广告/"}]},{"title":"03计算广告笔记-在线广告产品","slug":"03-notes-of-computational-ads-online-products","date":"2018-09-24T08:20:41.000Z","updated":"2018-09-24T08:37:37.000Z","comments":true,"path":"03-notes-of-computational-ads-online-products.html","link":"","permalink":"http://qinjiangbo.com/03-notes-of-computational-ads-online-products.html","excerpt":"","text":"在线广告不同于传统线下广告，其产品形式(这里说的并非创意形式)相当丰富。如果从产品的视角将这一过程提炼出来，可以用下图来示意。 合约广告产品：它由线下广告的交易形式衍生而来，又可以分为按照时段售卖的 CPT 广告和按照约定展示量售卖的 CPM 广告。这类广告产品主要服务于后续效果不宜直接衡量的品牌类广告主，在门户网站和视频网站较为常见。 竞价广告产品：其最重要的形式是搜索广告，其产品形式为对搜索关键词的竞价。这种广告在拓展到站外展示广告流量时，演进成了对页面关键词或者用户标签竞价的产品形式，也就是 ADN。竞价广告的商业逻辑与合约广告完全不同，也是解决效果类广告需求的关键产品形式。 程序化交易广告产品：竞价广告的进一步发展催生了实时竞价的交易形式。实时竞价使得需求方可以更灵活地划分和选择自己的目标受众，也使得更广泛的数据使用和交易迅速发展起来。以实时竞价为核心的一系列交易方式逐渐演变为机器之间以程序化的方式完成广告交易决策，因此，这类产品称为程序化交易广告产品。 原生广告产品：广告的产品体系除了自身的演进，另一个重要课题是如何处理与非商业化内容的关系，让广告与内容尽可能以“原生”的方式共存。搜索广告和社交网络信息流广告对此作了非常有价值的探索，不过这样的原生广告在规模化和交易化方面也遇到了很多的问题。然而，随着近年来移动设备对于原生广告的强烈渴求，像标准 ADN 那样的原生广告平台正在快速发展中。 需求方层级组织与接口一般来说，需求方提供的广告是分层次管理的。在市场上大多数的产品中，广告的层次分为广告主、广告(推广)计划(campaign)、广告(推广)组(ad goup)、广告创意(creative)等几个层级，参见下图。 广告计划概念上对应于广告主的一次投放合同，其中包括了预算、时间范围等基本信息。 广告组对应于一个具体的广告投放策略，主要是设定受众定向条件和出价。 广告创意则是最终展示出来的素材，可能在同一个组策略下有不同尺寸的创意存在。 供给方管理接口在目前的主流的广告交易逻辑中，供给方即媒体对业务的控制比起需求方来要弱很多。 供给端的资源组织主要分媒体和广告位两个层次。其中媒体可以是网站，也可以是移动应用开发者。 媒体的操作比广告主方要简单，一般来说，添加、删除广告位以及查看各广告位的运营数据是主要的功能需求。 对于其中的某个具体广告位，根据产品功能的不同，需要的操作功能也不同。但一般来说，设定广告位尺寸、取广告投放代码或 SDK 以及设定该广告位对广告类型的要求是一些通用的需求。在广告管家或 SSP 之类的供给方产品中，往往还会有精细的流量分配功能。需要注意的是，广告平台会维护各个广告位对应的域名或应用名，以防其他域名的流量盗用广告位代码。","categories":[{"name":"计算广告","slug":"计算广告","permalink":"http://qinjiangbo.com/categories/计算广告/"}],"tags":[{"name":"在线广告","slug":"在线广告","permalink":"http://qinjiangbo.com/tags/在线广告/"}]},{"title":"02计算广告笔记-计算广告基础","slug":"02-notes-of-computational-ads-fundmentals","date":"2018-09-23T10:00:11.000Z","updated":"2018-09-24T08:22:20.000Z","comments":true,"path":"02-notes-of-computational-ads-fundmentals.html","link":"","permalink":"http://qinjiangbo.com/02-notes-of-computational-ads-fundmentals.html","excerpt":"","text":"可衡量的效果以及相应的计算优化是在线广告区别于线下广告的主要特点。 在大多数广告产品中，可以通过计算优化的主要是收入部分。而千次展示期望收入(expected Cost Per Mille，eCPM)正是计算广告中最为核心的量化指标之一。与广告的信息传达过程相关， eCPM又可以分解为点击率和点击价值的乘积，这两个指标是各种广告产品在计算过程中经常碰到的，也是产品运营需要深入理解和重点关注的。 广告有效性原理图中所示这一有效性模型把广告的信息接收过程分为选择(selection)、解释 (interpretation)与态度(attitude)三个大阶段，或者进一步分解为曝光(exposure)、关注(attention)、理解(comprehension)、接受(acceptence)、保持(retention)与决策(decision) 6个子阶段。 曝光(exposure)阶段。这一阶段指的是广告物理上展现出来的过程，此阶段的有效程度往往与广告位的物理属性有关，并没有太多可以通过技术优化的空间。实际的广告实践中，曝光的有效性对最终结果的影响往往远远高于其他技术性因素，所以才会有传统广告中“位置为王”的说法。 关注(attention)阶段。这一阶段指的是受众从物理上接触到广告到意识上注意到它的过程。对广告而言，曝光并不一定意味着关注。首先，尽量不要打断用户的任务。其次，明确传达向用户推送此广告的原因，这一点是受众定向广告创意优化的重要方向。另外，内容符合用户的兴趣或需求，这是行为定向的原理基础。 理解(comprehension)阶段。用户关注到了广告的内容也并不意味着他一定能够理解广告传达的信息。首先，广告内容要在用户能理解的具体兴趣范围内， 这说明了真正精准的受众定向有多么必要。其次，要注意设定与关注程度相匹配的理解门槛。 接受(acceptance)阶段。受众理解了广告传达的信息，并不一定表示他认可这些信息。 保持(retention)阶段。对于不仅仅追求短期转化的广告商，当然希望广告传达的信息给用户留下长久的记忆，以影响他长时间的选择，因此品牌广告商在创意设计上花了大量的精力提高此阶段效果。 决策(decision)阶段。成功广告的最终作用是带来用户的转化行为，虽然这一阶段已经离开了广告的业务范围，但好的广告还是能够为转化率的提高做好铺垫。特别是对于电商或团购业务，在创意上强调哪些信息以打动那些价格敏感的消费者是有相当的学问的。 计算广告核心问题 计算广告的核心问题，是为一系列用户与环境的组合找到最合适的广告投放策略以优化整体广告活动的利润。 广告收入的分解 点击率(Click Through Rate, CTR)，广告点击与广告展现的比率； 转化率(Conversion Rate, CVR)，转化次数与到达次数的比例。 结算方式 CPM结算，即按照千次展示结算。这种方式是供给方与需求方约定好千次展示的计费标准，至于这些展示是否能够带来相应的收益，由需求方来估计和控制其中的风险。 CPC结算，即按点击结算。这种方式最早产生于搜索广告，并很快为大多数效果类广告产品所普遍采用。在这种方式结算方式下，点击率的估计是由交给供给方(或者中间市场)完成的。 CPS(cost per sale)/CPA(cost per action)/ROI结算，即按照销售订单数、转化行为数或投入产出比来结算。 CPT(cost per time)结算，这是针对大品牌广告主特定的广告活动，将某个广告位以独占式方式交给某广告主，并按独占的时间段收取费用的方式。","categories":[{"name":"计算广告","slug":"计算广告","permalink":"http://qinjiangbo.com/categories/计算广告/"}],"tags":[{"name":"广告基础","slug":"广告基础","permalink":"http://qinjiangbo.com/tags/广告基础/"}]},{"title":"01计算广告笔记-在线广告综述","slug":"01-notes-of-computational-ads-definitions","date":"2018-09-12T08:44:00.000Z","updated":"2018-09-17T12:26:41.000Z","comments":true,"path":"01-notes-of-computational-ads-definitions.html","link":"","permalink":"http://qinjiangbo.com/01-notes-of-computational-ads-definitions.html","excerpt":"","text":"广告的定义与目的广告的定义在了解计算广告之前，我们先从了解一般广告的目的开始。什么是广 告？可以参考William F.Arens在《当代广告学》中给出的定义： 广告是由已确定的出资人通过各种媒介进行的有关产品（商品、服务和观点）的，通常是有偿的、有组织的、综合的、劝服性的非人员的信息传播活动。 两个关键点： 它指出了广告活动的两个主动参与者——出资方(sponsor)和媒体(medium)。使用更加专业的术语来描述就是需求方(demand)和供给方(supply)。这里的需求方可以是广告主(advertiser)、代表广告主利益的代理商(agency)或其他技术形态的采买方；这里的供给方可以是媒体，也可以是其他技术形态的变现平台。另外，要特别注意的是，广告还有一个被动的参与方，即受众(audience)。 该定义还阐明了广告必须是有偿的、非人员的信息传播活动。这两点限制，前者使得广告的目标变得明确，后者使得这一目标可以采用计算的方式来优化，而这些都是计算广告产生的基础。 品牌广告和效果广告 品牌广告：在传统媒体时代，供给方与需求方在市场地位上有相当的距离，不论你运营的是电视台、机场或杂志，都与大多数广告主需要的转化行为之间有相当大的差距。因此，这一阶段广告的目的是希望借助媒体的力量来快速接触大量用户，以达到宣传品牌形象、提升中长期购买率与利润空间的目的。 效果广告：许多广告商希望能利用广告手段马上带来大量的购买或其他转化行为，这种目的的广告称为直接效果广告(direct response)。 广告的目的既然有品牌和效果这两种目标，究竟如何描述广告这种商业活动的根本目的呢，我们仍然借用《当代广告学》中的见解： 广告的根本目的是广告主通过媒体达到低成本的用户接触。 也就是说，按某种市场意图接触相应的人群，进而影响其中的潜在用户，使他们选择 广告主产品的几率增加，或者对产品性价比的苛求程度降低，这才是广告的根本目的。 关键点广告的“低成本”是与那些由市场或销售人员完成的劝服活动成本相对而言的，实际上是广告搭了媒体流量和影响力的便车。要确定是否真的成本较低，需要用到投入产出比(Return On Investment，ROI)这一评价指标，即某次广告活动的总产出与总投入的比例。 一切付费的信息、产品或服务的传播渠道，都是广告。 广告的创意类型 横幅广告(banner ad) 文字链广告(textual ad) 富媒体广告(rich media ad) 视频广告(video ad) 社交广告(social ad) 移动广告(mobile ad) 邮件定向营销广告(E-mail Direct Marketing, EDM) 广告形式发展 展示广告(display advertising)，指在互联网上展示广告创意的产品形式。这一阶段的展示广告售卖模式称为合约广告(agreement-based advertising)， 即采用合同约定的方式确定某一广告位在某一时间段为某特定广告主所独占，并且根据双方的要求，确定广告创意和投放策略。 定向广告(targeted advertising)，这样的广告系统已经对计算技术产生了两个具体需求：一是受众定向(audience targeting)，即通过技术手段标定某个用户的性别、年龄或其他标签；二是广告投放(ad serving)，即将广告投送由直接嵌入页面变为实时响应前端请求，并根据用户标签自动决策和返回合适的广告创意。 竞价广告(auction-based advertising)，供给方只向广告主保证质即单位流量的成本，但不再以合约的方式给出量的保证，换言之，对每一次展示都基本按照收益最高的原则来决策。 广告网络(ad Network，ADN)，基于竞价机制和精准人群定向这两个核心功能，它批量地运营媒体的广告位资源，按照人群或上下文标签售卖给需求方，并用竞价的方式决定流量分配。 广告交易平台(ad Exchange，ADX)，实时竞价(Real Time Bidding，RTB)将拍卖的过程由广告主预先出价，变成每次展示时实时出价。只要把广告展示的上下文页面 URL 以及访客的用户标识等信息传给需求方，它就有充分的信息来完成定制化的人群选择和出价。市场上产生了大量聚合各媒体的剩余流量并采用实时竞价方式为他们变现的产品形态。 原生广告(Native AD)，将内容与广告以某种方式统一决策或排序的广告产品。 泛广告商业产品 团购。团购本质上是一种按照效果付费的泛广告产品，其特殊性在于广告主除了付推广费用外，还向用户让利以获得转化。团购推广的主要广告主是一些本地化的店铺，主要目的是为了获得新客户。 游戏联运。游戏联运根据用户的最终游戏内消费在推广渠道和游戏开发商之间分成的商业产品，这仍然是一种按效果付费的泛广告产品。 固定位导航。这主要包括网址导航站的位置入口、应用分发平台的推荐位置等付费推广位置。一般来说，这种产品的销售都采用按时间付费的固定位模式，而不是动态的竞价决策模式。 返利购买。返利购买是电商行业常见的一种推广模式，它与团购有些类似，也是采用折扣或积分的方式激励用户购买。","categories":[{"name":"计算广告","slug":"计算广告","permalink":"http://qinjiangbo.com/categories/计算广告/"}],"tags":[{"name":"广告概念","slug":"广告概念","permalink":"http://qinjiangbo.com/tags/广告概念/"}]},{"title":"[转]AdNetwork与AdExchange区别","slug":"difference-between-AdNetwork-and-AdExchange","date":"2018-09-02T13:00:12.000Z","updated":"2018-09-17T12:00:01.000Z","comments":true,"path":"difference-between-AdNetwork-and-AdExchange.html","link":"","permalink":"http://qinjiangbo.com/difference-between-AdNetwork-and-AdExchange.html","excerpt":"","text":"首先，你对互联网广告的产业链要至少有一个基本的了解。什么是广告主(advertiser)，什么是媒体(publisher)，什么是广告商(agency)。广告主显然是指想为自己的品牌或者产品做广告的人，例如宝马、Intel、蒙牛……媒体则是提供广告位置的载体，例如电视台、网站、杂志、楼宇……广告商本质上其实就是中介，帮广告主找媒体广告位，帮媒体找广告主。 当然，这个产业链还有一个不能忽略的部分，那就是“消费”广告的人，即受众(audience)。受众都是有特点的，被分成一类一类相近的人群(persona或segmentation)。20多岁，刚刚从大城市毕业的女大学生有很多相近之处，销售护肤产品的企业会把她们作为同一类人群，并且认为她们是自己的目标受众(target audience)，因为这一类人对美丽容貌的追求是显著的，且开始有消费能力。对企业而言，将广告传播到潜在的消费者那里去是最基本的目标。 这当然是简单到不能再简单的理解。不过，到了现实世界，事情变得复杂，为了把广告这个看似“简单”的事情做好，人们发现其实不是一个部门就能干好的。举个例子，广告做成什么样子会吸引人呢?这涉及到创意——图形及文案，复杂的还得有动画、有拍摄。世界上的媒体这么多，投放到哪些媒体上才能“打击”到目标受众呢?这又涉及到对营销推广渠道及受众的分析和选择。广告做出之后，目标受众的大多数人并不会立即购买，而是会去进一步了解企业生产的商品，这又需要有一个承载更多信息的平台接纳、满足他们的探索欲，并尽全力说服他们购买商品。企业还发现，为了影响到目标受众，真正要做的事情还不仅仅只是广告本身，广告不过是推广形式的一种，还有很多其他在不同环境下同样有效的方式，例如公共关系营销(PR)、病毒营销(社会化营销)等等，每一种也都需要特别专业的知识和经验。 这样，整个营销推广世界一下子变得空前复杂起来，上面的每一个领域都有数量庞大的服务商提供专业的细分服务。而互联网的出现，则更加剧了这种复杂度。 互联网的海量网站和信息是它的价值之源，但也为传播广告带来了空前麻烦。与在电视上投放广告不同，互联网上的用户更加碎片化(fragmented)，浏览网站或使用apps是十分碎片化的，浏览时间同样碎片化，要打击更多的目标受众，很多时候不得不跟数量极为庞大的网站或apps分别谈判。这实际上非常不现实，于是广告主倾向于购买大型网站上的广告位，而难以触及那些虽然流量不大，但质量不错的中小网站。 但是，凡是有供给(中小网站的广告位)有需求(广告主同样希望扩大广告的覆盖广度)就一定有市场。市场出现了，那些有广告位却“不受人待见”的中小网站们明白单打独斗是没有生意的，但联合起来则不同。多个中小网站作为一个整体共同面对广告主，不仅省了广告主跟各个网站分别谈判的麻烦，也为广告主增加了价值。这是一个顶不错的主意，不过，中小网站们(很多站长其实就是个人)怎样联合，谁来与广告主谈判，如何定价等等都是非常麻烦的——没人牵头的话，根本就不具备操作性嘛。不过，办法总比问题多，一种被称为Ad Network(广告网络)的事物应运而生，它既像是一个行业协会，又像是一个中小publishers(网站和apps其实都是publishers)的中介(agency)，它帮助建立publishers联合的标准和联合的方法，它代表这些publishers与广告主谈判，它同样与广告主谈价格，提供双方都能接受的定价。愿意进入Ad Network的publisher，签一个协议服从规则就好了，不愿意的，不勉强。如果广告主有广告需求，会发给Ad Network，然后Ad Network会把这个广告散布到各个适合发布这个广告的众多publishers上去。广告主付费之后，相当部分的费用被分配给publisher，Ad Network则自己留存一部分作为自己的“辛苦费”。在Ad Network内所做的广告，与在某一个大型网站上直接谈判而签订的广告合同不同，前者更适用于按照展示量(impression)或者点击量(click)来进行收费，即CPM或者CPC的收费方式，而后者在中国，则基本是按照时间(按天数即CPD)来收费的。Ad Network的出现广受欢迎，乃至于一些大型网站也会加入Ad Network，原因在于它们总有一些无法完全销售出去的边边角角的长尾广告位，现在终于有了变现的渠道了。Ad Network，最出名的就要算Google的AdSense了(虽然并不非常典型)，中国则有易传媒(AdChina)或是好耶(AllYes)。 对于Ad Network，有一件事情是极为重要的，不仅仅它需要获得更多的publishers的认可和加入，同样还需要让广告主觉得在它的网络上所花的钱是值得的，而且，它自己还要能获利，这使如何进行广告的定价变得极度重要。本质上，Ad Network是一个计算精密的数学模型。但Ad Network再计算的再精密，publishers可能心里都会有微词，毕竟定价权不掌握在自己手中。而且随着一些牛X的Ad Network越来越大，publishers的话语权越来越小。本来Ad Network只是一个中介而已，结果中介控制了整个市场，占了更大头的好处，却没让publishers吃到大鱼大肉。另一方面，广告主则可能抱怨，Ad Network提供的广告位大多只是长尾流量，并不是那么好，自己花了钱，但是获得的流量却不精准，获得的audience不够target。 不仅如此，市场上往往不止一个Ad Network，有的Ad Network有部分质量不错的publishers，却卖不出去，因为它手上的广告主跟这些publishers不够匹配，于是它把这些publishers的广告位又以更低的价格卖个另外一个Ad Network，而下一个Ad Network又可能把它们转卖给第三个Ad Network。这个市场开始变得乱哄哄，广告主和媒体(publishers)之间开始夹杂了数量太多的各种“中介”。广告主犯愁了，本来一个Ad Network的世界其实挺简单，但现在遍地都是，良莠不齐，该选择哪一个?媒体们也犯愁了，不同Ad Network的价值各不一样，广告格式的规范也不一样，定价不同，背后的广告主质量也不同，又该如何取舍?既然有问题，那么就一定有解决问题的市场。又一个事物应运而生，它的名字是Ad Exchange，中文叫广告交换平台。好家伙，这个东西一出现，就让人们糊涂的颠三倒四。现在很多人其实并不懂得Ad Network和Ad Exchange的区别，但实际上它们是完全不同的东西。 与Ad Network联合publishers不同，Ad Exchange不仅仅联合publishers，它同样把Ad Network联合起来，这些拥有广告位的，被统一用“供应方”(supply side)一词来指代。Ad Exchange为这些供应方提供了一个用于展示自己的资产(即广告位)的界面，大家自己往上登就好了。广告主一看，这样挺好，以前要跟很多Ad Network打交道，现在只要跟一个Ad Exchange打交道就好了，而且需要什么位置，我自己可以选择。不过，除了广告主自己，广告主的广告业务代理人也是这个Ad Exchange的需求方，甚至，大家可能没有想到，Ad Network自己也同样可能是Ad Exchange的需求方。这不难理解，因为Ad Network为了丰富自己的“库存”(inventory，即广告位)，在自己不具备某一类publishers的时候，在Ad Exchange上购买一些也是完全有可能的。这些需求方，被统一用demand side一词来指代。Ad Exchange也为需求方提供了统一的界面，让它们能够查看其上的广告位情况，并且能够根据自己的需要任意选择这些广告位。 不过，如果仅仅只是做这些事情，Ad Exchange的能量其实是非常有限的。Ad Exchange比Ad Network先进的地方在于它的定价机制。Ad Network上，对于供需双方而言，其实都没有对广告位的定价权，而是由Ad Network这个“中央政府”定价的“计划经济”;而Ad Exchange，则是一个真正意义上按照供需关系来运转的“市场经济”。什么意思呢?原来，Ad Exchange为每一个商品(商品这里暂时指广告位)提供了“价高者得”的机制。对于每一个广告位，如果同时有多个广告主想买，由Ad Network根据自己认为最合理的方式来分配归于哪个广告主，而在Ad Exchange上则是价高者得——为这个广告位出价最高的广告主获得了在这个广告位显示广告的机会。定价权现在转让给了供需双方，给了市场。 你会发现，Ad Network更像是行业协会，而Ad Exchange则更像是Nasdaq，广告位就是股票，股民就是广告主。哪些广告位更有价值，就会被广告主追逐的更多，它的价格也就会更高，这跟股票的价格机制是极为相似的。 世界上著名的Ad Exchange有Google收购DoubleClick之后最近弄出来的AdX;还有Yahoo收购的Right Media，这也是老牌的Ad Exchange了;此外微软有AdECNNIC，OpenX也有自己的Ad Exchange。 随着技术的发展，Ad Exchange也变得越来越灵活，功能越来越强。过去，股票的交易不是实时的，因为受技术的限制，往往要T+1或者T+2什么的(就是推迟一天两天)才能完成交易，那个时候可能价格什么的又变了。但是，今天的股票交易，很多已经可以T+0。同样，Ad Exchange一开始应该也不是很实时的，但随着技术的基本，对于广告位的竞价，现在已经完全可以实时进行了。这种实时进行的广告位竞价，被称为Real Time Bidding，简称为RTB，即“实时竞价”。 实时竞价一般是按照CPM或者CPC出价的，关于这两个名词，我们后面会详细解释，这里简单说就是按照广告被展现在受众面前的次数出价，或是按照广告被点击的次数出价。如果我和你同时看好一个广告位，我愿意为它出价3美元每个点击，而你出价3.1美元每个点击，那么你就拥有了这个广告位。实时竞价的好处太大了，人们能够合理分配自己的预算，而且花了钱之后可以立即根据效果的好坏和竞争情况随时调整自己的出价，整个广告的选择和投放都变得很可控。 这样看来Ad Exchange真的已经很完美了。但凡事都是两面的，好的一面必然会带来不好的一面。功能强大的Ad Exchange是一个专业的实时的股票交易所，不过，可不是每一个人都是专业的股票经纪人！ 更何况，Ad Exchange也不是就一个玩家，世界上有好几个Ad Exchange，中国也有几个。 广告主现在又犯难了，Ad Exchange和RTB，看起来真是牛逼大发了，但是用起来不仅界面繁琐，而且如何出价可是一个巨大的学问，更何况还有多个Ad Exchange同时在世。更可怕的是，我该如何判断一个广告位背后是否有我需要的目标受众(target audience)呢？更可怕的是，各个Ad Exchange中的广告位储量那可是天文数字，我一个一个找，一个一个出价，累死不说，时间也全部耽误了。 旧愁虽解，新愁却来。 别慌，有问题就必然有解决问题的市场。一个叫做DSP(Demand Side Platform，即需求方平台)的事物又应运而生(互联网广告行业真是各种大小运啊)，它看起来就是帮助广告主们玩转Ad Exchange的中介(agency)，实际也差不多就是这样。DSP同时把主流的Ad Exchange的系统都与自己驳接，然后提供给广告主们一个统一的更加简单的操作界面(肯定比Ad Exchange提供的界面要简单些)，不过更重要的是，DSP把AdExchange中的广告位的展示方式做了一个巨大的改变。在Ad Exchange中，广告位可就是广告位，但在DSP中，广告位这个概念被移除或是被淡化了，而target audience的概念则被提出来。 什么意思呢?原来，每一个广告位背后，都是一部分受众(audience)，广告主买广告位的目的，实际上就是看中了这个广告位背后的这群受众。既然广告主的目的明确，而又不能自己搞定这些受众对应的全部广告位，那我DSP来帮忙呗。怎么帮，很简单，你广告主在DSP的操作界面中，告诉我你需要哪些人群，愿意出多少钱获得这些人群，我来帮你在Ad Exchange中操作不就完了。因此，对于广告主而言，广告购买形式发生了翻天覆地的变化。过去，是购买广告位，现在有了Ad Exchange和DSP，是直接购买目标受众。 于是，DSP就成了一边连接Ad Exchange，另外一边服务于广告主的中介，就好像一群炒股散户的代理人，帮他们打理手中的资金，利用自己的专业知识选择股票，让这些散户的获利最大化。中国的DSP厂商数量据说已经超过了50个，很多Ad Network转型也做DSP生意，比如前面讲到的易传媒、好耶，而其他的DSP也如雨后春笋，例如品友互动、Yoyi、MediaV、晶赞等等，国外还有Criteo，Turn等等等。这个市场很快极度繁忙繁荣。 DSP绝对是一个技术活，而且必须要通过强大的受众数据和数学能力，帮助广告主实时决策，合理花钱，让广告主的广告花费用在刀刃上。要搞定这些，单靠人力可不行，而必须有受众的非常准确的兴趣信息数据，而且还必须依靠一套强大的算法来进行广告位的竞价，这种方法就是现在炙手可热的“程序化购买”的方法之一。也就是说，程序化购买依赖于两个重要事情：其一，需要受众数据，准确的，海量的;其二，强大的自动化算法，保证最合理的竞价。 DSP自己有可能有受众数据，但有很多其实没有，或者有，也不够全面，不够准确。那怎么办呢?又一个市场上的专业提供者出现了，被称为DMP，即Data Management Platform，数据管理平台。数据管理平台，简单讲，它们手中握有受众数据，并且能够让DSP驳接到他们这里，利用它们所有的数据。 所有有细分需求的地方，就立即有细分的供应。同样的原因，供应方(publishers和Ad Networks)也有了一个被称为SSP的东西帮助它们打点各个Ad Exchange的关系，并提供使用体验更一致更集成的广告位库存管理环境。SSP，即Supply Side Platform(供应方平台)的简称。但中国事实上几乎没有真正意义上的SSP，各家媒体实际上直接绕过了SSP跟Ad Exchange直接连接，原因较为复杂，这篇文章就暂时按下不表。上面基本上说明了现在的互联网广告的产业链的大概的样子。你会问，这个跟我做互联网营销推广的分析与优化有何关系呢?嗯，的确，给大家一个大图景的目的，是为了描绘这个图景中间更加细微的东西。例如，一个问题是，DMP如何拥有受众的数据，即它们如何可以知道某个广告位背后的受众究竟是什么样的人呢? 简单讲，DMP为了获取受众的数据，它必须至少做几件事情：其一，它需要为所有的受众每一个做一个标记，这个标记在目前的技术条件下，主要是通过一种叫做cookie的事物完成的。而在更新的技术条件下，可能又有能够比cookie更多(甚至更好)的东西。这些我们都在后面会讲到。其二，它还需要能够实现跨域追踪。什么是域?这是我们要在这一节就清楚了解的东西。 搞清楚域，最好不要去翻互联网原理，那里的解释都有些不食人间烟火。简单讲，所谓的域，就是指一个网站的范围，通常一个网站只有一个一级域名(例如http://baidu.com就是一个一级域名，而http://music.baidu.com则是二级域名)，因此域和一级域名常常没有区别。跨域，就是多个网站，或者多个一级域名。跨域追踪，就是能够追踪同一个用户在多个网站(多个一级域名)上的行为。 跨域又分为两类，一种叫做跨主域，即跨越了多个不同的一级域名;另外一种叫做跨子域，即跨越了多个不同的二级域名。举一个例子。加入一个组织声称它能够追踪同一个用户在http://baidu.com、http://sina.com.cn、http://chinawebanalytics.cn上的行为，那么它的这种追踪是跨主域的。而另一个组织，如果它声称能够追踪同一个用户在百度一下，你就知道, music.baidu.com、map.baidu.com等同一个一级域名之下的二级域名的行为，那么它的这种追踪是跨子域的。跨主域，大部分时候被我们简单称为跨域，而跨子域则没有简称，必须要声明是跨子域。 跨域追踪又分为广义的跨域追踪和狭义的跨域追踪。如果是广义的，那么就是指，一个组织或者一种解决方案能够跨越不同所有人的网站追踪用户的行为。比如，它能够追踪同一个用户在搜狐上、新浪上及优酷网上的行为。这些网站显然不属于同一个组织或个人所有。而狭义的跨域追踪，则是指虽然网站的一级域名不同，但是却属于同一个组织或个人。这种情况下的追踪，只要网站所有人同意开放权限，那么执行起来比广义的跨域追踪就要容易多了。这样一个人在互联网上的兴趣就能够全面被了解，而如果不能实现跨域追踪，只能从一两个网站了解受众，那么能够判断的依据就会太片面了。今天，DMP可以称为最为复杂的互联网营销信息系统，但也是最颠覆一切的“爆炸物质”。 讲到这里，大家应该明白了什么是广告主(advertiser)和媒体(media)，明白了什么是目标受众(target audience)。大家又明白了广告主和媒体中间原来有很多广告代理商(agency)，这些代理商还花样繁多，其中很重要的是广告网络(Ad Network)和广告交换平台(Ad Exchange)，另外还有附着于广告交换平台的DSP和SSP。你还知道了多种互联网广告的付费方式，包括按照日期付费(CPD)，按照广告展示付费(CPM)以及按照广告的点击付费(CPC)，最后还有一种高级方式，RTB的方式。之后，你了解到用来定位一个受众个体的解决方案是cookie，以及其他比cookie“更牛”的方式。再之后，你学到了域和子域，以及跨域和跨子域，我们的追踪要么是在一个域(或者子域)的范围之内的，要么就得跨到一个更大的范围内——跨子域追踪或者跨域追踪。这些东西，如此基本，又如此重要，它们都深刻影响着我们对于互联网营销分析与优化的技术和方法，以至于，我在本文浮光掠影了解了这些基本概念之后，还会在后面更多文章中更进一步学习它们。 参考内容：https://www.zhihu.com/question/19794762/answer/42158254","categories":[{"name":"计算广告","slug":"计算广告","permalink":"http://qinjiangbo.com/categories/计算广告/"}],"tags":[{"name":"广告概念","slug":"广告概念","permalink":"http://qinjiangbo.com/tags/广告概念/"},{"name":"Ad Network","slug":"Ad-Network","permalink":"http://qinjiangbo.com/tags/Ad-Network/"},{"name":"Ad Exchange","slug":"Ad-Exchange","permalink":"http://qinjiangbo.com/tags/Ad-Exchange/"}]},{"title":"百阿951，我们不一样！","slug":"we-are-different-BaiA-951","date":"2018-09-02T10:02:02.000Z","updated":"2018-09-02T10:21:51.000Z","comments":true,"path":"we-are-different-BaiA-951.html","link":"","permalink":"http://qinjiangbo.com/we-are-different-BaiA-951.html","excerpt":"","text":"时间过得真快，一转眼为期9天的百阿就结束了。相信所有的小伙伴都会有“来的时候不想来，走的时候不想走”的感觉吧！Sandy老师的话还时不时回荡在脑海中，对我的教诲也会让我终身受益，谢谢Sandy老师！这次百阿能够非常顺利地完成并且全情地投入，离不开主管行格以及师兄费天的大力支持，在这里对你们表示由衷地感谢！ 其实有人说，百阿就是一场彻彻底底的“洗脑运动”，我并不这么认为。通过百阿，对于客户第一、团队合作以及拥抱变化等核心价值观有了非常不一样的看法，感受更加真切，而不是单纯地不加思考地接受它。长达9天的百阿课程非常丰富，其实每一个课程的设计都是为了更好地让大家理解阿里巴巴的文化以及价值观。只有通过自身切身地感受和体会才能明白什么是“为过程喝彩，为结果买单”。 还记得第一天《侠骨柔情》环节，石头老师让我们不触碰红线将整个团队翻越到教室的另一端。一开始大家可能是抱着玩一玩的心态来参加这个游戏，但是当石头老师严肃地看待这个环节的时候，才明白这其中的深奥。我和其他几位同学是一直作为同学们的阶梯而存在的，每个同学都需要踩着人梯来翻越这条红线到达教室另一端。我最真切的感受就是，“其实，大家都挺沉的，哈哈”。虽然过程比较辛苦，但是好在我们顺利地拿到了结果。到现在都还能感受到那一刻成功的喜悦。 再次重温了《Dream Maker》，这应该是说是我第四遍刷这个视频了。但是每一次看的时候都会有满满的感动。其中三个镜头让我非常地动容，首先是中供早期销售去业主小区的时候都是拿的硬壳公文包，因为要防狗咬。看着这个画面就会鼻子一酸，确实听不容易的，要不当年的这些铁军，可能我们的业务根本就起不来。他们是一群“因为相信，所以看见”的人！第二个镜头是非典的时候，大家都自发地将电话电脑搬到家中办公，而当客户来电的时候，一个熟悉的声音再次响起，“您好，这里是阿里巴巴”。只不过说话的主体会发生一些变化，可能有一些是员工的家属。家人的理解与支持是让我为感动的事情，只有家人的理解才能让我们全情地投入到工作当中。第三个镜头是CEO卫哲引咎辞职的事情，从来没有人相信一家公司会因为价值观而辞退自家的CEO，而这就是阿里巴巴，这就是少年阿里的简单，这就是少年阿里的赤子之心！希望我们951的小伙伴们也能一直保持一颗赤子之心、不要忘记自己初心是什么。 通过对阿里巴巴各个业务的探寻，了解集团一些核心业务的业务版图，比如集团安全部。安全部应该是阿里巴巴集团最神秘的部门之一了。通过对安全部的HR访谈，我们知道安全部的权力是非常大的，他们可以决定一家店铺的生与死，也可以让一个产品的发布终止。安全部正如一个高速行驶的列车的刹车片，如果没有及时刹车，只顾高速前行，一定会有翻车的时候，所以要时不时地踩一下刹车。这位HR所描述的一些例子已经给我们敲响了警钟。比如，一个处理违规商品的自动下架算法如果做的不够好，即使下掉了9999个违规商品，但是如果有一个误伤，对我们可能是0.01%的误差，但是对那个商家却是100%，商品被下架对于他的打击却是毁灭性的，这是一个真实存在的case。所以，要敬畏手中的权力，只有用户认可我们，我们才能有这些权力，如果用户都流失了，何谈这些权力？ 关于客户第一的探寻其实是需要每一个人回到自己的BU和组内的师兄或者自己的主管进行沟通的。我找到了自己的师兄费天，通过和费天师兄的深入交谈，明白了我们团队服务的对象是广告主，我们团队的使命是要为广告主提升广告的ROI，为此我们为广告主提供了广告创意的制作，竞价词的购买以及广告落地页的建设。后面大家选出了5个case进行了客户第一的演绎，其实才明白了客户第一不仅仅是一个口号，而是需要我们“要发疯似地解决客户的问题”。明白客户第一，首先要明白客户的需求是什么，如果这点不明确，就谈不上客户第一。另外，要换位思考，站在客户的角度想问题，试想，如果和客户坐在同一条船上，船进水了，我们自己不会拼了命去修补好吗？还有一点就是，面对的客户的投诉，应该觉得这是一次提供改进的机会，一个愿意来投诉的客户往往都是好客户，因为这样我们才可以进一步完善我们自己的产品，从而更好地服务他们。 另外，真的很幸运遇到了我们小组的成员，他们是您川，壹天，玄芷，辰悠，张晶，氮泵，嶙峋，宗尊，晨屹，左枢，海有，耿羽。能和你们在一个小组，真心感到非常的幸运，你们让我这9天过的非常充实和快乐。从你们身上，我感受到了阿里人的客户第一、团队合作、拥抱变化以及诚信，激情、敬业的核心价值观。我们一起排练节目，我们一起吃盒马鲜生，我们一起去酒吧畅谈，我们一起准备讲课老师的介绍等等，这九天我尝试了好多之前一直想尝试但是没空去实现的心愿，谢谢你们，让我这九天都实现了。每一个第一次的迈出都特别的不容易，但是正因为有你们在一起，心里才特别有底~聚是一团火，散是满天星！希望大家在各自的岗位上工作能够顺顺利利，前途一帆风顺！ 最后附上自己在《共创未来》环节画的一幅心愿，左边是未来的自己，希望能够像一些技术大牛一样能够在Qcon，开源中国等技术论坛上分享自己对业务和对技术的理解。右边是现在的自己，为了这个目标正在奋力前行。希望在业务上和技术上都能有非常大的突破。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"阿里巴巴","slug":"阿里巴巴","permalink":"http://qinjiangbo.com/tags/阿里巴巴/"},{"name":"百年阿里","slug":"百年阿里","permalink":"http://qinjiangbo.com/tags/百年阿里/"}]},{"title":"[转]如何在Hexo中支持Mathjax","slug":"how-to-support-mathjax-in-hexo-blogs","date":"2018-08-05T08:48:28.000Z","updated":"2018-08-05T09:00:18.000Z","comments":true,"path":"how-to-support-mathjax-in-hexo-blogs.html","link":"","permalink":"http://qinjiangbo.com/how-to-support-mathjax-in-hexo-blogs.html","excerpt":"","text":"在 hexo 中，你会发现我们不能用Latex语法来书写数学公式，这对于书写学术博客来说是很大的不便，因为我们会经常碰到很多的数学公式推导，但是我们可以通过安装第三方库来解决这一问题。 第一步: 使用Kramed代替 Markedhexo默认的渲染引擎是marked，但是marked不支持mathjax。kramed是在marked的基础上进行修改。我们在工程目录下执行以下命令来安装kramed. 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 然后，更改/node_modules/hexo-renderer-kramed/lib/renderer.js，更改： 12345// Change inline math rulefunction formatText(text) &#123; // Fit kramed's rule: $$ + \\1 + $$ return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$');&#125; 为： 1234// Change inline math rulefunction formatText(text) &#123; return text;&#125; 第二步: 停止使用 hexo-math首先，如果你已经安装hexo-math, 请卸载它： 1npm uninstall hexo-math --save 然后安装 hexo-renderer-mathjax 包： 1npm install hexo-renderer-mathjax --save 第三步: 更新 Mathjax 的 CDN 链接首先，打开/node_modules/hexo-renderer-mathjax/mathjax.html 然后，把&lt;script&gt;更改为： 1&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt; 第四步: 更改默认转义规则因为 hexo 默认的转义规则会将一些字符进行转义，比如 _ 转为&lt;em&gt;, 所以我们需要对默认的规则进行修改.首先， 打开/node_modules/kramed/lib/rules/inline.js 1escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/, 更改为: 1escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/, 把 1em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 更改为: 1em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 第五步: 开启mathjax在主题_config.yml中开启Mathjax， 找到mathjax字段添加如下代码（笔者亲自验证，有些博客不需要设置）： 12mathjax: enable: true 这一步可选，在博客中开启Mathjax， 添加以下内容： 123456---title: Testing Mathjax with Hexocategory: Uncategorizeddate: 2017/05/03mathjax: true--- 通过以上步骤，我们就可以在hexo中使用Mathjax来书写数学公式。 转载自 https://blog.csdn.net/u014630987/article/details/78670258","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://qinjiangbo.com/tags/Hexo/"},{"name":"Mathjax","slug":"Mathjax","permalink":"http://qinjiangbo.com/tags/Mathjax/"}]},{"title":"JS去掉畅言广告","slug":"remove-changyan-ads-with-js","date":"2018-08-05T07:42:20.000Z","updated":"2018-08-05T09:00:28.000Z","comments":true,"path":"remove-changyan-ads-with-js.html","link":"","permalink":"http://qinjiangbo.com/remove-changyan-ads-with-js.html","excerpt":"","text":"前言要不是后台有一位同学给我留言，我还一直没发现畅言的评论框开始投放广告了，因为我一直使用的是ad-block进行广告屏蔽，所以一直没有看到畅言的广告。后来在safari下面打开一看，还真有，简直过分！我在想，是不是畅言团队默认开启这个功能的呢？或许，到畅言后台有什么窗口可以关闭，或者是这部分广告还可以补贴一下博主？ ？？？心中一万匹草泥马狂奔而过。不仅收用户的钱，还收博主的钱！！！这个产品经理心中一定在窃喜自己有多聪明，实际上你，唉，不说了。 解决方案通过观察畅言的广告区域的代码，可以看到它的区域有一个ID是feedAv，因此，我们可以通过将这个区域设置为不可见即可。 代码如下： 123456789101112131415function loadCssCode(code) &#123; var style = document.createElement('style'); style.type = 'text/css'; style.rel = 'stylesheet'; //for Chrome Firefox Opera Safari style.appendChild(document.createTextNode(code)); //for IE //style.styleSheet.cssText = code; var head = document.getElementsByTagName('head')[0]; head.appendChild(style);&#125;var dsq = null;//去除畅言广告dsq = setInterval('if(document.getElementById(\"feedAv\"))&#123;document.getElementById(\"feedAv\").id=\"feedAvi\";window.clearInterval(dsq);&#125;', 1000);loadCssCode('#feedAvi&#123;position: absolute !important;z-index: -9999;top: -1000px;&#125;'); 那这部分代码具体放在什么地方呢？就是你引用畅言JS代码的下面，一旦畅言JS一加载，下面这段代码就会立即执行。 1234567891011121314151617181920212223242526272829303132333435363738(function () &#123; var appid = '&lt;%= theme.comment.changyan.appId %&gt;'; var conf = '&lt;%= theme.comment.changyan.appKey %&gt;'; var width = window.innerWidth || document.documentElement.clientWidth; if (width &lt; 960) &#123; window.document.write('&lt;script id=\"changyan_mobile_js\" charset=\"utf-8\" type=\"text/javascript\" src=\"https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&amp;conf=' + conf + '\"&gt;&lt;\\/script&gt;'); &#125; else &#123; var loadJs = function (d, a) &#123; var c = document.getElementsByTagName(\"head\")[0] || document.head || document.documentElement; var b = document.createElement(\"script\"); b.setAttribute(\"type\", \"text/javascript\"); b.setAttribute(\"charset\", \"UTF-8\"); b.setAttribute(\"src\", d); if (typeof a === \"function\") &#123; if (window.attachEvent) &#123; b.onreadystatechange = function () &#123; var e = b.readyState; if (e === \"loaded\" || e === \"complete\") &#123; b.onreadystatechange = null; a() &#125; &#125; &#125; else &#123; b.onload = a &#125; &#125; c.appendChild(b) &#125;; loadJs(\"https://changyan.sohu.com/upload/changyan.js\", function () &#123; window.changyan.api.config(&#123; appid: appid, conf: conf &#125;) &#125;); &#125;&#125;)();// 放置上面的去广告代码 总结上述的代码能够让你将畅言的广告屏蔽掉，我其实在想有多少人会去买这个去广告的产品，一个月49元真的有市场吗？我记得之前好像还是99元，现在往下调整将近一半的价格可以推测世界上傻子并不多。这笔钱虽然不多，但是够恶心人。 参考文章 https://blog.csdn.net/xiaohxx/article/details/80621717","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"畅言","slug":"畅言","permalink":"http://qinjiangbo.com/tags/畅言/"},{"name":"去广告","slug":"去广告","permalink":"http://qinjiangbo.com/tags/去广告/"},{"name":"商业化","slug":"商业化","permalink":"http://qinjiangbo.com/tags/商业化/"}]},{"title":"Maven Profile动态替换web.xml参数","slug":"replace-parameters-in-web-xml-file-with-maven-profile","date":"2018-08-04T08:52:47.000Z","updated":"2018-08-04T10:34:01.000Z","comments":true,"path":"replace-parameters-in-web-xml-file-with-maven-profile.html","link":"","permalink":"http://qinjiangbo.com/replace-parameters-in-web-xml-file-with-maven-profile.html","excerpt":"","text":"最近项目中需要引入一个叫做ABTest工具。看了一下官方给出的文档，如下： 12345678910111213141516171819202122&lt;!-- abtest 配置 --&gt;&lt;filter&gt; &lt;filter-name&gt;AbtestFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.******************.*********.web.DefaultTestFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;env&lt;/param-name&gt; &lt;param-value&gt;$&#123;env&#125;&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;appName&lt;/param-name&gt; &lt;param-value&gt;demo&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;AbtestFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;AbtestFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- abtest 配置结束 --&gt; 可以看到其中${env}的变量值是需要进行动态替换的。一开始我觉得可以使用maven-war-plugin来完成这个配置，BUT NOT WORK FOR ME！绕了好久的弯，终于看到了项目中进行config.properties替换使用的一个插件maven-antrun-plugin，BINGO，替换成功！ 先进行一下说明，项目中并没有使用antx来进行配置，因此适用于antx的方案不一定适合本项目，所以一开始就没有往antx的方向考虑。 使用maven-war-plugin进行替换[❌]看了一下父pom的配置，发现它使用了profile进行多套环境的参数替换，如下： 1234567891011121314151617181920212223242526&lt;!-- 预发布环境 --&gt;&lt;profile&gt; &lt;id&gt;staging&lt;/id&gt; &lt;properties&gt; &lt;env&gt;staging&lt;/env&gt; &lt;ant-properties-path&gt;src/main/resources/conf/config-staging.properties&lt;/ant-properties-path&gt; &lt;/properties&gt;&lt;/profile&gt;&lt;profile&gt; &lt;id&gt;publish&lt;/id&gt; &lt;properties&gt; &lt;env&gt;publish&lt;/env&gt; &lt;ant-properties-path&gt;src/main/resources/conf/config-pro.properties&lt;/ant-properties-path&gt; &lt;/properties&gt;&lt;/profile&gt;&lt;!-- 生产环境 --&gt;&lt;profile&gt; &lt;id&gt;production&lt;/id&gt; &lt;properties&gt; &lt;env&gt;production&lt;/env&gt; &lt;ant-properties-path&gt;src/main/resources/conf/config-pro.properties&lt;/ant-properties-path&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt;&lt;/profile&gt; 可以看到不同的环境有不同的配置文件。在profile中添加一个属性test-env，如下： 123456789101112&lt;!-- 生产环境 --&gt;&lt;profile&gt; &lt;id&gt;production&lt;/id&gt; &lt;properties&gt; &lt;env&gt;production&lt;/env&gt; &lt;test-env&gt;online&lt;/test-env&gt; &lt;ant-properties-path&gt;src/main/resources/conf/config-pro.properties&lt;/ant-properties-path&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt;&lt;/profile&gt; 然后再在webapp子pom中进行maven-war-plugin插件的配置，如下： 12345678910111213141516171819&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/webapp&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/.svn&lt;/exclude&gt; &lt;/excludes&gt; &lt;includes&gt; &lt;include&gt;**/web.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;webXml&gt;$&#123;basedir&#125;/src/main/webapp/WEB-INF/web.xml&lt;/webXml&gt; &lt;warSourceDirectory&gt;$&#123;basedir&#125;/src/main/webapp&lt;/warSourceDirectory&gt; &lt;/configuration&gt;&lt;/plugin&gt; 然后使用maven命令进行构建，mvn clean package -Dmaven.test.skip=true -Pproduction，但是生成war包以后，进入WEB-INF目录一看，发现这个根本就没有进行替换。NOT WORK FOR ME! 说明这个方法我觉得理论上应该是可以的，如果有更好的建议或者我的描述有不对的地方欢迎指出来哈！非常感谢！ 使用maven-antrun-plugin进行替换[✔️]后面研究了一下config.properties是如何实现多套环境的替换的，终于在同一个文件，也就是webapp子pom里面找到了答案，它使用了maven-antrun-plugin进行运行时构建，具体的替换逻辑如下： 12345678910111213141516171819&lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;configReplace&lt;/id&gt; &lt;phase&gt;validate&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;tasks&gt; &lt;copy file=\"$&#123;ant-properties-path&#125;\" tofile=\"$&#123;project.build.directory&#125;/classes/config.properties\" /&gt; &lt;/tasks&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 进入查看tasks标签的描述，如下： 123456789&lt;parameter&gt; &lt;name&gt;tasks&lt;/name&gt; &lt;type&gt;org.apache.tools.ant.Target&lt;/type&gt; &lt;required&gt;false&lt;/required&gt; &lt;editable&gt;true&lt;/editable&gt; &lt;description&gt;The XML for the Ant task. You can add anything you can addbetween &amp;amp;lt;target&amp;amp;gt; and &amp;amp;lt;/target&amp;amp;gt; in a build.xml. &lt;/description&gt;&lt;/parameter&gt; 具体的意思是说我们可以在build.xml文件中的&lt;target&gt;标签内添加任何任务。我找了一下build.xml的基本demo，如下： 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;project name=\"AntTestDemo\" default=\"run\" basedir=\".\"&gt;&lt;property name=\"src\" value=\"src\"/&gt;&lt;property name=\"dest\" value=\"classes\"/&gt;&lt;property name=\"helloant_jar\" value=\"helloant.jar\"/&gt;&lt;target name=\"init\"&gt; &lt;mkdir dir=\"$&#123;dest&#125;\"/&gt;&lt;/target&gt;&lt;target name=\"compile\" depends=\"init\"&gt; &lt;javac srcdir=\"$&#123;src&#125;\" destdir=\"$&#123;dest&#125;\"/&gt;&lt;/target&gt;&lt;target name=\"build\" depends=\"compile\"&gt; &lt;jar jarfile=\"$&#123;helloant_jar&#125;\" basedir=\"$&#123;dest&#125;\"/&gt;&lt;/target&gt;&lt;target name=\"run\" depends=\"build\"&gt; &lt;java classname=\"com.zdz.ant.test.HelloAnt\" classpath=\"$&#123;helloant_jar&#125;\"/&gt;&lt;/target&gt;&lt;target name=\"clean\"&gt; &lt;delete dir=\"$&#123;dest&#125;\" /&gt; &lt;delete file=\"$&#123;helloant_jar&#125;\" /&gt;&lt;/target&gt;&lt;target name=\"rerun\" depends=\"clean,run\"&gt; &lt;ant target=\"clean\" /&gt; &lt;ant target=\"run\" /&gt;&lt;/target&gt;&lt;/project&gt; 我发现这些target下面的标签不正是一些常见的命令吗？这个太强大了！因此，我想到可不可以使用一个替换命令，直接使用profile中定义的属性直接进行web.xml中的属性替换。上网一查，果然有同学这样做过，BINGO！我果断在webapp子pom中添加一个execution任务。 1234567891011121314&lt;execution&gt; &lt;id&gt;envReplace&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;tasks&gt; &lt;replace file=\"$&#123;project.build.directory&#125;/demo/WEB-INF/web.xml\" token=\"defaultTestEnv\" value=\"$&#123;test-env&#125;\"/&gt; &lt;/tasks&gt; &lt;/configuration&gt;&lt;/execution&gt; web.xml文件中要替换的地方如下： 123456789101112&lt;filter&gt; &lt;filter-name&gt;teslaFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.******************.*********.web.DefaultTestFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;env&lt;/param-name&gt; &lt;param-value&gt;defaultTestEnv&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;appName&lt;/param-name&gt; &lt;param-value&gt;demo&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; 然后再重新打包，果然OK了。 总结这个动态替换的问题确实会困扰到很多同学，至少困扰了我半个下午来解决这个问题，在这里记录一下，和大家分享这个问题的一种解决思路。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://qinjiangbo.com/tags/Maven/"},{"name":"Profile","slug":"Profile","permalink":"http://qinjiangbo.com/tags/Profile/"},{"name":"Web.xml","slug":"Web-xml","permalink":"http://qinjiangbo.com/tags/Web-xml/"}]},{"title":"入职两周谈点自己的感受","slug":"talk-something-about-myself-two-weeks-after-registering","date":"2018-07-16T15:35:56.000Z","updated":"2018-07-22T04:59:06.000Z","comments":true,"path":"talk-something-about-myself-two-weeks-after-registering.html","link":"","permalink":"http://qinjiangbo.com/talk-something-about-myself-two-weeks-after-registering.html","excerpt":"","text":"这个月2号入职的，到今天16号为止已经过了14天，也就是两个星期，这其中自己还是有很多思考的，包括生活、工作以及学习。 生活记得我妈最近每次和我视频的时候都惊叹于我的房间整洁干净，她永远也想不到她的儿子还是非常整洁和爱干净的，哈哈。她觉得我就是三分钟热度，过了这一阵儿就恢复为老样子了。但是我心底清楚，这一次不一样。原因是我的心理状态发生了变化，或者说我的生活态度发生了变化。我觉得生活本来就不容易，这个房间给到自己了，如果不好好整整，打扫一下，脏一天也是过，干净一天也是过，为什么不好好打扫干净呢？这样别人看的舒心，自己住着也开心。看着现在的房间越来越像想象中自己的房子，非常地开心。后续还会进一步的整一整，努力提升自己的生活品质。 但是另一个非常现实的问题是，自己的时间却越来越少了，少到女朋友和我视频也只是一种很珍贵的赏赐了。时间真的太短了，每次我一回家就是10点半以后了，她在那边也要睡了，我不想打扰她，也就没有视频。其实时间一长我觉得两个人总会冒出点隔阂啥的。所以啊，我现在就珍惜每一次和她视频的机会，把话说明白说清楚，不要留争议，因为，异地恋本身就太不容易，再加上争执的话那就更加不易了。还好我们彼此都懂，她是一个明白事理的姑娘，我很幸运。 久违的单反也只有在周末的时候才有机会拿出来拍几张，摄影一直是我想要做的事情，但是苦于时间的问题，一直找不到合适的地方进行摄影创作。我认为真正的摄影其实是要最大程度地还原摄影师当时看见的场景的，但这很难。我平时也会抽时间出来玩PS来调调照片啥的，其实生活乐趣有很多，找到一个，你就拥有了全世界。 工作关于工作，因为去年实习的原因，所以现在一过来过于公司的很多工具都使用的比较熟练，上手还比较快。由于是来了一个新的部门，因此去年实习时了解到的一些业务规则到现在也都没有多大意义了。当然了，这里仅仅是说对当前业务没太大意义，但是对于自身全面的发展还是很有必要的。 广告业务部门是每一个公司进行商业化的重要一步尝试，如谷歌，百度等等。在阿里巴巴，以前我们是做平台，服务好消费者和商家，现在依然是做平台，依然要服务好消费者和商家。但和以前不同的是商家赚到钱了以后，他还想要进一步扩展，需要更多的流量，这个时候我们就需要提供一个引流的工具，也就是广告了。商家可以根据自己的需求来购买一些广告位。对于消费者而言，广告这个东西如果没有展示到他们喜欢的或者感兴趣的东西，通常是作用不大的。因此，需要根据消费者的消费行为定向地推广一些广告，这样用户也不会明显感觉被打扰了，接受度也会高一些。 再说说工作后的心态变化，其实和学校不太相同的，公司的节奏非常快，所有的工作都是围绕着业务的进程快速展开的。阿里巴巴是一家业务驱动占主导的企业，所有的资源都要为业务服务。因此，如果某一个业务虽然短期可能做得不错，但是如果没有前途的话，也会被狠心砍掉。因此，要学会拥抱变化！快速适应这个变化的节奏。 学习学习是永远不能停的，上周和主管聊天，有一个新的观念我非常赞同，就是学习力，对于我而言这是一个非常新的概念。什么是学习力？学习力就是不仅要好学，而且要能快速利用所学的技能和知识拿到结果，而且相当长的时间之内要能记住所学的东西。 其实我发现很多同学，包括我自己或多或少都能有一定的对号入座，我以前一直提倡好学，而且沉淀下来。也就是要有输入和输出。但是没有谈到转化，光有输出还不行，还要讲输出转化为实际的东西。这才是学习力的体现！ 学习的方式我觉得还是看自己的时间来安排，如果时间比较碎片化，建议读博客，看视频。如果时间比较集中，建议多读读书，尤其是纸质书籍。因为可以在上面做一些笔记，这些笔记是非常关键的，关系着后面多少个月以后你还能快速地捡起来。 总结恭喜你，终于听我叨逼叨完了，我希望你也能对生活工作以及学习多一些思考，多一些沉淀。其实很多事情想明白了也就那么回事，但是没想明白的话就会非常费精力。这篇文章从16号一直写到22号，原谅我太忙了~😂","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"入职","slug":"入职","permalink":"http://qinjiangbo.com/tags/入职/"},{"name":"心灵港","slug":"心灵港","permalink":"http://qinjiangbo.com/tags/心灵港/"}]},{"title":"入职前夕谈点自己的体会","slug":"talk-something-about-myself-before-registering","date":"2018-06-26T01:01:14.000Z","updated":"2018-06-29T07:28:09.000Z","comments":true,"path":"talk-something-about-myself-before-registering.html","link":"","permalink":"http://qinjiangbo.com/talk-something-about-myself-before-registering.html","excerpt":"","text":"近况透露大家可以看到上一篇文章的时间还是5月15号。的确，将近一个月的时间没有更新博客的内容了。主要是两个原因：一是博主的研究生论文答辩花费了太多精力，没有过多的时间来更新新的技术文章或者经验感悟；二是博主答辩完了以后进行了毕业旅行，主要是陪陪女朋友，陪陪家人去了（说白了，就是浪~）。现在此时此刻正在公司安排的爱啡尔酒店写这篇文章。这篇文章后面主要包括我最近或者相当长时间内已经遇到或者将要遇到的一些问题，在这里都说说自己的感想。 关于毕业毕业，就俩字。说起来很容易，做起来很难。难在哪儿？难在过程，难在结果。还记得去年实习完回母校导师就要我们提前想好毕业论文的题目，想做什么？说实话，我确实有自己的想法，我在公司的时候自己就思考过这个问题，比如做一个类似于今日头条的产品出来（推荐算法+资讯流模式），一方面可以深入学习推荐算法，对自己也是促进，另一方面，还能码很多工程代码，不至于让自己后面太生疏。但是这个想法终究没有实现，因为没有研究意义。后来导师在群里给了三个题目，让我们自己认领，我选择了一个从未研究过的领域——反爬虫技术。我在实验室带的是爬虫团队，但是对于反爬虫的技术知道的并不多，就了解一下User-Agent要更改，访问频率不能过快等等，但是这些要写成论文明显不够。 虽然是一个未知的领域，但是心里面好像并不慌张，心底有一种声音告诉自己一定能够把这个研究做得很好。采取的方式就是小步快跑，每周开组会给老师展示的都是一个逐渐接近真实模型的原型系统。因此老师能够及时地针对这个原型系统中存在的问题给出一些改进的意见，然后不断地修正和改进。做学问，最重要的就是要真实，数据要真实，实验过程也要真实，而不是临时糊弄一下编造一些数据，这是导师朱卫平给我最大的教导。在毕业答辩的时候被分配到了火力很猛的几个老师，搞得我提前一两周就开始紧张起来了。但是真正到了答辩教室的时候，心里面却也没有那么慌张了。答辩的时候也是不卑不亢，针对老师提出的每一个问题给出自己的见解，平等交流吧。 毕业之前和同学们出去小聚了一下，吃了一些烧烤，喝了点酒，看了一下世界杯。仿佛一杯酒下去就会立马离别似的，很不舍，很难受。第二天，大家都还在睡梦中的时候，我起床收拾行李准备出门的时候，发现文安也起来了。他执意要送我上地铁，最让我心里难受的是他一直目送我走进地铁楼梯下去直到看不见。因为我送过好多朋友，都是送到他们上地铁，这一幕让我好熟悉好亲切，因为我当时也是这样的不舍啊。我很能明白他心里的这种感受，所以才更加感到难过。祝你们一切都好！ 关于租房辞别了母校和小伙伴，就来到了杭州。发现公司安排的房间还是相当不错的，一个loft单间，一个人住的太爽了。但是与此同时还有另外一个非常重要的事情就是租房，小伙伴们加上我一共有四人。我们总共找了三个app，分别是自如、嗨住以及安居客。发现自如上面的房子都只适合单租，不适合整租。然后嗨住上面房源信息太少，也不太适合。而安居客上面房源信息很多，并且价格都还不错。这下我们心动了，但是联系中介的时候，我们哭了，都是假房源！！！一般都会问你需要看其他房子吗？我们这边有其它的房子。 是的！我们摸清楚了中介的套路，就是使用钓鱼的方式来吸引一波客户，然后再挖掘潜在的客户。不过这种方式也是比较有效的，我们通过其中的一些中介看了他们没有公布到网上的房源信息，然后一个一个约着时间去看，终于找到了一套比较合适的房子。四个房间大小都挺合适的，而且小区环境很好，周边基础设置很齐全，生活气息很浓厚。 关于生活最近看到一种说法，房子是租来的，但生活不是。我很赞同！以前，自己租房子的时候总是觉得能住就行，而且也没有太多要求，自己也就是普普通通地生活着，一切都很无感，一切都觉得平平淡淡。但是自从看了一些出租屋改造计划的视频以后，发现，我的生活应该要有所不同了，TIME TO CHANGE！因此，我的生活观念也逐渐发生了变化。 以前生活对于我来说只是很小的一部分，甚至可以忽略不计，但是现在才会体会到公司所提倡的“快乐工作，认真生活”的真正内涵！一个不会生活的人，又如何期望他能把工作做得完美呢？虽然这两者没有直接的联系，但是这个态度确是一个人的本质属性，是一脉相承的。我宁愿相信把生活过得精致的人能有更高的可能性创造出更高的成就，也不愿意相信一个生活一塌糊涂的人能够创造更高的成就。 为了让自己获得更高的获得感和满足感，我决定将房间好好地打造一下，变成一个温馨的环境。基本的要求是能让我有一种强烈的归属感。觉得这个地方是我愿意一直好好待着的地方。花了好多money买了一些必需的用品，还有一些能有效提升幸福感的东西需要购买： 靠枕 地毯 床头包 壁画 香氛 绿色植物 这些东西都会给原本无聊的生活中增添一抹亮色，至少目前我是这么相信的哈。期待接下来的生活！关于房子是如何打扮的，后面有机会再给大家好好介绍。 总结本来还有三个主题要谈的，关于技术，关于工作以及关于爱情，我决定放到后面再谈，放到入职以后再谈谈我的想法和一些碎碎念，敬请期待。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"入职","slug":"入职","permalink":"http://qinjiangbo.com/tags/入职/"},{"name":"心灵港","slug":"心灵港","permalink":"http://qinjiangbo.com/tags/心灵港/"}]},{"title":"网络爬虫原理简析","slug":"introduction-to-web-spiders","date":"2018-05-15T08:59:17.000Z","updated":"2018-05-15T17:16:36.000Z","comments":true,"path":"introduction-to-web-spiders.html","link":"","permalink":"http://qinjiangbo.com/introduction-to-web-spiders.html","excerpt":"","text":"最近需要给一些新来的同学讲一讲爬虫相关的知识，决定写一个简单的入门系列教程吧。会从基础到进阶逐渐加深，并结合一些常见的网站给出爬虫的实战教程。下面主要从六个方面来介绍爬虫的基本原理以及进行爬虫实战所遵循的基本思路。 爬虫是什么爬虫是什么？根据维基百科的定义，网络爬虫也叫网络蜘蛛(Web Spider)，是一种用来自动浏览万维网的网络机器人(Web Robot)。本质上就是一些根据特定的规则访问万维网资源并下载网页内容的脚本或者程序。 它的基本流程就是开始于一张被称为“种子”的统一资源地址(URL)列表，爬虫会依次访问种子中的 URL，解析出页面中包含的其它链接，并将这些 URL 放入到一个爬行疆域(Crawl Frontier)，也就是待爬取 URL 列表。然后从爬行疆域中取出 URL 进行访问，通过 DNS 解析得到目标网站的 IP 地址，然后将这个目标网页保存下来， 并将其中的内容抽取出来保存到本地进行归档存储，以便于后面进行索引和查找。根据相同的规则将所有的 URL 进行遍历，并采集对应的网页内容，这个过程就是网络爬行。 爬虫的基本架构下面是一个通用爬虫的系统架构，我们来看一看通用爬虫的具体工作组件模块相互之间是怎样进行数据的沟通和协调的？ Web：这个指的是网络上各种资源，也就是爬虫要爬取的各种资源。 DNS解析器：这个模块主要是解析HTTP请求的地址，寻找到目标网站的实际IP地址。这个不是爬虫技术关注的重点。 网页下载器：这个模块功能非常简单，就是实现一个下载功能，这个下载器能够将目标网页的页面内容下载下来（不包含附加的CSS和JS脚本文件）。 网页内容解析器：这个模块功能主要是解析网页的内容，一般来说会根据页面中用户需要内容元素的ID或者Class的信息来提取内容。 URL重复过滤器：主要用于判断哪些URL已经爬取过了，哪些还没有爬取，去除重复的请求URL。 爬行疆域：简单来说就是待爬取列表，提供给网页下载器每次下载的URL地址。 爬取内容来源爬取的内容来源主要是PC端网页上的信息，其实现在移动端的很多业务也逐渐做起来了，比如之前我要采集小黄车在某一个区域的车辆数量变化情况，就是基于移动APP来进行爬虫爬取的。但是本文不打算介绍移动端的爬取过程，后面有机会再给大家介绍。 一般来说PC端网页的内容通常指的是正常用户能够可见的内容，就是直接显示在网页上的文字，图片视频等。对于不可见的内容，其实也没有爬取的必要了。但是对于初学者而言，爬取的时候会有一种情况比较尴尬，就是使用Chrome或者Firefox审查元素的时候内容是可见的，但是一旦使用程序去爬取，得到的数据就缺失了。一般来说，这个原因可以归结为动态网页加载内容的原因。 数据的来源主要有三个方面，分别是网页本身内容，JS脚本加载内容以及异步AJAX请求。下面分别介绍这三种不同的内容来源。 网页本身内容网页本身的内容就是网页加载的时候直接写在页面中的内容信息，比如说文章资讯的文字信息等。这种非常容易解决，因为只要发出对这个网页的请求信息即可获取所需的全部内容信息。因为这部分内容是完全写在网页里面的，所以不需要额外的请求去获取内容，处理起来相对容易很多。 JS脚本加载内容有些内容是通过网页中的脚本动态生成的，比如说一些时间信息还有一些网页返回了数据信息，但是是由JavaScript脚本进行拼装得到的，然后在加入到页面中的标签里面。但是如果只请求网页的话得到的相应结果就是页面内容加上页面中的JavaScript脚本，而所需要的关键内容是不会展示出来的，因为JavaScript脚本没有执行。 异步AJAX请求内容对于有些页面，数据的加载是完全异步的，一般是列表页面比较多，为了避免页面刷新，会使用AJAX请求数据，然后再动态地添加到网页的标签中。针对于AJAX请求的分析思路，可以考虑查看浏览器的HTTP请求，通过观察新数据加载时发出的新的请求信息，可以定位到具体是哪一个请求对数据进行了加载；另外一种思路比较简单，直接查看属于XHR类型的请求然后进一步判断即可。 爬取数据结构形式爬取的数据结构有很多种，但是大体上主要分为两种，分别是有结构还是无结构。所谓有结构，就是指数据是按照一个特定的文件格式传递进来的，比如JSON文件，或者是XML文件；而无结构化的数据主要是指网页中的各种数据，这些数据是没有特定的结构可言的，每一个网站的网页结构都不相同，因此需要针对每一个网页进行分析。 结构化数据主要是JSON数据或者是XML数据，这一类数据通常对应的其实是上面的异步AJAX请求内容。而在JSON数据的技术里面，还有一种使用JSON数据形式比较多的就是JSONP技术，这种技术主要是针对跨域请求而言的。利用&lt;script&gt;标签中的src属性具有跨域加载的能力，可以被用来加载非同源服务器提供的数据。 无结构化数据主要是网页中的一些HTML文本数据，其实HTML文本理应属于结构化的文本组织，但是又因为一般我们需要的关键信息并非直接可以得到，需要进行对HTML的解析查找，甚至一些字符串操作才能得到，所以还是归类于无结构化的数据处理中。 常见的限制方式常见的限制方式其实就是一些网站的反爬虫措施，不过都是一些比较基础但对普通爬虫比较有效的反爬虫措施。想要抓取这些网站的核心数据，就必须突破这些反爬虫措施的限制。具体的限制措施主要体现在以下几个方面： Baisc Auth，是用户授权，要求在请求头部的Authentication字段里面添加，这里在分析请求的时候需要注意一下。 Referer，普通爬虫与正常用户的很大的区别是普通爬虫不带Referer头，而很多网站都会校验这个请求头，如果没有，则会拒绝请求。 User-Agent，这个是最基础的一个方式了，就是将爬虫的用户代理设置为常规的浏览器用户代理，以达到伪装爬虫的目的。 Cookie，一般在用户登录或者某些操作后，服务端会在返回包中包含Cookie信息要求浏览器设置Cookie，没有Cookie会很容易被辨别出来是伪造请求。 Gzip压缩，为了节省带宽和加速网页加载，很多网站采用gzip压缩算法对网页进行压缩，然后在浏览器里进行解压显示，这个时候我们在爬虫里面就需要先进行解压操作才能获取目标文本信息。 爬虫实现思路结构化内容抽取思路对于结构化的数据，比如JSON，直接通过对应的包解析就好了，比如Python里面的json包，Java里面的Fastjson库等等，这种数据是最方便解析的。 无结构化内容抽取思路对于无结构化的内容，目前考虑的抽取思路主要是根据HTML网页的结构进行抽取，通常有三种不同的方式可以做到，分别是CSS选择器，XPATH以及正则表达式。 CSS选择器，这个是现在比较通用的一种方式，主要是根据HTML网页结构中的目标内容所在的标签包含的一些属性信息，比如ID，Class还有其他属性等，以豆瓣网站为例，如下图所示。这里得到的css选择器表达式是#content &gt; div &gt; div.article &gt; ol &gt; li:nth-child(1) &gt; div &gt; div.info &gt; div.hd &gt; a，一般来说，按照它默认给的就好了。但是如果为了追求代码的简洁，自己稍加分析得到一个更简单的表达式也是可以的，而且博主更倾向于后者。 XPATH选择器，这个主要是利用XML里面的路径表达式来定位元素信息，因为本质上来说，HTML文件就是一种XML文件，因此可以使用XML文件的那一套操作。还是和上面的例子一样，可以使用Chrome工具来创建XPATH路径表达式。，如//*[@id=&quot;content&quot;]/div/div[1]/ol/li[1]/div/div[2]/div[1]/a。这里的要求和上面也一样，通常情况下使用Chrome默认的就好了，但是自己如果能够写出更简洁的方式也是更好的。 正则表达式，这个主要是利用正则表达式在文本中进行匹配搜索，这个就没有利用HTML文件的这种结构特性，只是单纯地将这个HTML文本当做一个字符串来对待了。一般来说， 写正则表达式的要求会高很多。博主不建议在通常情况下就使用这种方式来抽取文本。 数据结构实现思路需要实现的数据结构主要是种子列表，待爬取列表以及已爬取列表。实现的方法模板主要是和上面的爬虫架构相对应，如下： start()，这个主要是爬虫启动的方法，包括初始化种子列表等等都在这里完成。 extractLinks()，这个主要是抽取出要爬取的URL列表，一般是通过列表页的内容来抽取待爬取的URL列表。 parseContents()，这个是解析目标网页内容的方法，通过CSS选择器或者是XPATH选择器来抽取出目标文本信息。 saveContents()，将抽取出的文本信息进行保存。 process()，对抽取的文本信息进行预处理，以保证不会出现一些比较乱或者是比较异常的数据。 总结本文系统地介绍了爬虫的基础架构和爬虫的基本实现方式，对于初学者来说有比较好的指导意义。建议刚开始学习的时候一定要思考爬虫完整的爬取过程，以及最后这个数据结构实现思路。这样的话更有利于快速掌握爬虫的核心技术以及后面会扩展地介绍到的一些优秀爬虫实现框架。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Python","slug":"开发技术/Python","permalink":"http://qinjiangbo.com/categories/开发技术/Python/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://qinjiangbo.com/tags/网络爬虫/"},{"name":"用户代理","slug":"用户代理","permalink":"http://qinjiangbo.com/tags/用户代理/"}]},{"title":"Python中对象转JSON问题","slug":"solutions-to-problem-of-object-to-json-in-python","date":"2018-05-14T05:36:32.000Z","updated":"2018-05-15T01:36:09.000Z","comments":true,"path":"solutions-to-problem-of-object-to-json-in-python.html","link":"","permalink":"http://qinjiangbo.com/solutions-to-problem-of-object-to-json-in-python.html","excerpt":"","text":"这篇博客解决的问题主要是xxx is not JSON serializable，这个问题是由于Python中对象不能够直接转化为JSON对象导致的。按照在Java中的开发经验，这个对象只要声明了各个属性应该可以直接转化的，但是Python中的JSON并不认同这一套。错误如下图所示： 在网上着了很多解决方案，大多数是建议将其转化为list对象，但是这里还有另外一种解决方法，就是直接指定JSON序列化对象使用的Encoder类。下面以一个例子来说明这种方法。 Item.py 123456789101112131415161718192021import jsonclass Item: def __init__(self, name, age): self.name = name self.age = ageclass ItemEncoder(json.JSONEncoder): def default(self, o): if isinstance(o, Item): return &#123; \"name\": o.name, \"age\": o.age &#125; return json.JSONEncoder.default(self, o)if __name__ == \"__main__\": item = Item(\"Richard\", 24) json_str = json.dumps(item,cls=ItemEncoder) print(json_str) 在这个文件中，声明了两个类，分别是Item和ItemEncoder，其中，ItemEncoder继承了JSONEncoder并重写了default方法。也就说，一旦检测到序列化对象是Item类的实例时，就会执行返回一个dict的逻辑，如上图所示。执行这段代码最终的结果是： 1&#123;&quot;name&quot;: &quot;Richard&quot;, &quot;age&quot;: 24&#125;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Python","slug":"开发技术/Python","permalink":"http://qinjiangbo.com/categories/开发技术/Python/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://qinjiangbo.com/tags/JSON/"},{"name":"Object","slug":"Object","permalink":"http://qinjiangbo.com/tags/Object/"},{"name":"serializable","slug":"serializable","permalink":"http://qinjiangbo.com/tags/serializable/"}]},{"title":"Linux监控进程存活状态","slug":"monitor-linux-process-liveness-status","date":"2018-05-13T08:52:59.000Z","updated":"2018-05-13T09:05:45.000Z","comments":true,"path":"monitor-linux-process-liveness-status.html","link":"","permalink":"http://qinjiangbo.com/monitor-linux-process-liveness-status.html","excerpt":"","text":"早上起来发现wiki系统挂了，也许是有同学手动将其关闭了，也许是它自己关闭了。查找各种运行日志没有发现任何异常的地方。因此，需要时不时地检查一下wiki系统是否还存活着？如果不是存活的状态，则需要将其重新启动。 进程监控脚本我们知道，查看进程的命令是ps，通常我们更喜欢带上参数，如ps -ef或者是ps -aux。要查找某一个进程的时候，我们需要加上这个进程的特征字符串，比如wiki系统的进程中包含confluence字符串，我们就是用ps -ef | grep confluence来查看wiki系统的进程存活状态，结果如下。通常情况下得到的列表除了进程本身外，还有一个就是查看这个进程状态的进程。可以看到进程12996就是当前查看进程的ID。 1234[root@whubdccl wiki_ops]# ps -ef | grep confluenceconflue+ 7733 1 5 16:02 ? 00:02:56 /opt/atlassian/confluence/jre//bin/java -Djava.util.logging.config.file=/opt/atlassian/confluence/conf/logging.properties -Djava.util.logging.manager.....conflue+ 8069 7733 0 16:03 ? 00:00:32 /opt/atlassian/confluence/jre/bin/java -classpath /opt/atlassian/confluence.....root 12996 9639 0 16:59 pts/0 00:00:00 grep --color=auto confluence 可以使用grep命令的反选参数来进行过滤，即grep -v grep去掉当前查看进程的信息。 因此，进程监控脚本可以写成如下形式： 12345#! /bin/bashps -ef | grep confluence | grep -v grepif [ $? -ne 0 ] ; then /etc/init.d/confluence startfi $?表示进程执行完的返回状态，为0表示正常执行，否则是异常的。 写入定时任务使用crontab -e写入定时任务中，如下，设置为每两个小时检查一次。 1* */2 * * * /root/wiki_ops/wiki_monitor.sh 总结这个定时任务相当于一个自动唤醒的任务，就是每隔一两个小时检查一次，如果目标进程不存活，则手动启动这个进程。大大解放系统管理员的双手，可以更好地干别的事啦。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"监听进程","slug":"监听进程","permalink":"http://qinjiangbo.com/tags/监听进程/"},{"name":"存活状态","slug":"存活状态","permalink":"http://qinjiangbo.com/tags/存活状态/"}]},{"title":"Linux系统Shell脚本变量理解","slug":"understanding-of-variables-in-shell-scripts","date":"2018-05-13T08:40:01.000Z","updated":"2018-05-13T09:11:02.000Z","comments":true,"path":"understanding-of-variables-in-shell-scripts.html","link":"","permalink":"http://qinjiangbo.com/understanding-of-variables-in-shell-scripts.html","excerpt":"关于Shell脚本中的一些参数信息，是如何从命令中传递到脚本中去的？这就需要依赖于参数变量，常见的参数变量如下表所示：","text":"关于Shell脚本中的一些参数信息，是如何从命令中传递到脚本中去的？这就需要依赖于参数变量，常见的参数变量如下表所示： 变量 说明 $# 执行脚本传入参数个数 $* 执行脚本传入参数列表 $$ 执行脚本进程id $@ 执行脚本传入所有参数 $0 执行脚本名称 $1 执行脚本第一个参数 $2 执行脚本第二个参数 $? 脚本执行状态0正常，其他表示有错误 可以看到，其实$*和$@的结果应该是一样的。可以写一个Shell脚本来实际测试一下。脚本如下： 12345678#!/bin/shecho \"param number is : $#\"echo \"param list is : $*\"echo \"all param is : $@\"echo \"process is : $$\"echo \"file name is : $0\"echo \"the first param is : $1\"echo \"stat is : $?\" 将这个文件命名为test.sh，然后使用命令sh test.sh param1 param2 param3来执行这个脚本，输出的结果如下： 1234567param number is : 3parm list is : param1 param2 param3all param is : param1 param2 param3process is : 14409file name is : test.shthe first param is : param1stat is : 0 可以看到完全符合预期。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"参数变量","slug":"参数变量","permalink":"http://qinjiangbo.com/tags/参数变量/"},{"name":"Shell脚本","slug":"Shell脚本","permalink":"http://qinjiangbo.com/tags/Shell脚本/"}]},{"title":"Linux系统释放buff/cache内存","slug":"release-buff-cache-memory-in-linux-system","date":"2018-05-13T08:10:26.000Z","updated":"2018-05-13T08:38:58.000Z","comments":true,"path":"release-buff-cache-memory-in-linux-system.html","link":"","permalink":"http://qinjiangbo.com/release-buff-cache-memory-in-linux-system.html","excerpt":"","text":"一直都没怎么关注buff/cache这个部分，因为平时在服务器上使用的过程中内存是够用的。但是最近在部署应用的时候发现内存已经严重不够用的，只剩100多M，使用top命令一看，buff/cache占用了好多内存，几乎是这个剩余空间的4-5倍。如下所示： 1234567891011121314top - 16:20:24 up 11 days, 11 min, 2 users, load average: 0.00, 0.16, 0.60Tasks: 101 total, 1 running, 99 sleeping, 0 stopped, 1 zombie%Cpu(s): 0.7 us, 0.3 sy, 0.0 ni, 98.8 id, 0.2 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 3881688 total, 102556 free, 3322056 used, 457076 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 334948 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1324 rabbitmq 20 0 1146304 44220 1092 S 0.7 1.1 0:18.66 beam.smp 7733 conflue+ 20 0 4009488 1.490g 40692 S 0.3 40.2 2:39.05 java 8069 conflue+ 20 0 3704192 566552 16588 S 0.3 14.6 0:23.80 java 21814 redis 20 0 151104 11028 208 S 0.3 0.3 0:46.42 redis-server 21892 root 20 0 136668 10980 980 S 0.3 0.3 10:22.68 AliYunDun 1 root 20 0 190716 2380 1156 S 0.0 0.1 0:06.98 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.04 kthreadd 我觉得这部分空间还是可以利用一下的，首先来看看这部分空间主要的作用。 buff/cache是什么cache只是用来缓存文件的，经常读写的文件会被缓存到cache中，可以增加读写效率，该功能是Linux系统内核提供的。也就是说为了避免频繁地发生IO请求，可以先将一部分数据写入到buffer/cache中然后再批量地持久化到本地的磁盘上。那么buffer和cache有什么区别呢？首先从字面上来说，一个是缓冲（buffer），另一个是缓存（cache），作用区别应该比较明显了。下面是一个对照表： buff cache Buffer：缓冲区，用于存储速度不同步的设备或优先级不同的设备之间传输数据；通过buffer可以减少进程间通信需要等待的时间，当存储速度快的设备与存储速度慢的设备进行通信时，存储慢的数据先把数据存放到buffer，达到一定程度存储快的设备再读取buffer的数据，在此期间存储快的设备CPU可搜索以干其他的事情。 Cache：缓存区，是高速缓存，是位于CPU和主内存之间的容量较小但速度很快的存储器，因为CPU的速度远远高于主内存的速度，CPU从内存中读取数据需等待很长的时间，而 Cache保存着CPU刚用过的数据或循环使用的部分数据，这时从Cache中读取数据会更快，减少了CPU等待的时间，提高了系统的性能。 Buffer：一般是用在写入磁盘的，例如：某个进程要求多个字段被读入，当所有要求的字段被读入之前已经读入的字段会先放到buffer中。 Cache并不是缓存文件的，而是缓存块的(块是I/O读写最小的单元)；Cache一般会用在I/O请求上，如果多个进程要访问某个文件，可以把此文件读入Cache中，这样下一个进程获取CPU控制权并访问此文件直接从Cache读取，提高系统性能。 内存释放脚本释放这部分内存的方式Linux内核团队也给出了说明，主要分为三条命令。 echo 1 &gt; /proc/sys/vm/drop_caches //To free pagecache. echo 2 &gt; /proc/sys/vm/drop_caches //To free dentries and inodes. echo 3 &gt; /proc/sys/vm/drop_caches //To free pagecache,dentries and inodes. 在运行这三条命令之前，需要把存在于缓冲区和缓存区的数据持久化到磁盘当中去，需要使用到sync命令。因此，整个内存释放的脚本可以写为： 123456789#! /bin/shused=`free -m | awk 'NR==2' | awk '&#123;print $3&#125;'`free=`free -m | awk 'NR==2' | awk '&#123;print $4&#125;'`if [ $free -le 200 ] ; then sync &amp;&amp; echo 1 &gt; /proc/sys/vm/drop_caches sync &amp;&amp; echo 2 &gt; /proc/sys/vm/drop_caches sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_cachesfi 将文件命名为release_cache.sh，使用crontab -e写入到一个定时任务中，每隔5分钟检查一次内存使用情况，如果可用空间小于这个值，就释放内存： 1*/5 * * * * /root/wiki_ops/release_cache.sh 总结buff/cache这部分内存正常情况下只要不影响常规应用的使用就不需要关注它的内存占用情况，但是如果出现剩余空间严重不足，而buff/cache空间占用特别高的情况下就需要定时清理这部分内存空间了。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"释放内存","slug":"释放内存","permalink":"http://qinjiangbo.com/tags/释放内存/"},{"name":"buff/cache","slug":"buff-cache","permalink":"http://qinjiangbo.com/tags/buff-cache/"}]},{"title":"Confluence利用Nginx实现https访问","slug":"https-to-confluence-via-nginx-web-server","date":"2018-05-13T07:15:59.000Z","updated":"2018-05-13T07:43:21.000Z","comments":true,"path":"https-to-confluence-via-nginx-web-server.html","link":"","permalink":"http://qinjiangbo.com/https-to-confluence-via-nginx-web-server.html","excerpt":"","text":"利用Confluence创建了自己的wiki系统以后，觉得通过http访问显得不是很权威，感觉有点假（小绿锁看多了就会这样）。因此，需要动手将wiki系统改造为https加密的系统。 证书申请证书的申请非常简单，需要自己拥有一个域名，然后要在这个域名所在的域名注册中心进行解析，校验通过以后就可以导出证书了。关于这申请部分的详细内容，我建议大家读一读我的这篇文章。《利用FreeSSL升级网站系统到HTTPS》 配置NginxNginx中的配置如下： 1234567891011121314151617181920212223242526272829303132333435server &#123; client_max_body_size 100m; listen 80; listen 443; ssl on; ssl_certificate /usr/local/etc/ssl/wiki.ourclass.com.pem; ssl_certificate_key /usr/local/etc/ssl/wiki.ourclass.com.key; server_name wiki.ourclass.com; access_log /var/log/nginx/wiki.log main; location / &#123; proxy_pass http://127.0.0.1:8090/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location /synchrony &#123; proxy_pass http://127.0.0.1:8091; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; &#125; # 重定向non-https流量到https if ($scheme != &quot;https&quot;) &#123; return 301 https://$host$request_uri; &#125;&#125; 注意，上面的路径配置有两个，分别是/和/synchrony，前者就是wiki的主体，后者是用来检测wiki的URL地址的一个心跳服务。其中，第二个映射/synchrony中的如下配置必须要有，否则前端多人协作的时候就会有一些问题。 123proxy_http_version 1.1;proxy_set_header Upgrade $http_upgrade;proxy_set_header Connection &quot;upgrade&quot;; 上述添加的配置是为了保证wiki中的Websocket服务正常运行。 配置Confluence很多人配置完了上述的系统以后就觉得可以访问了，但是一直会报一个警告就是 无法检测Base URL，是不是存在代理的配置问题 英文版的是 can&#39;t check base url warning 这个问题的解决方案除了上述的/stnchrony配置外，还需要加入一个Tomcat的配置，就是要在&lt;install-directory&gt;/conf/server.xml这个文件里面添加proxyPort和proxyName的配置，如下： 12345&lt;Connector port=\"8090\" connectionTimeout=\"20000\" redirectPort=\"8443\" maxThreads=\"48\" minSpareThreads=\"10\" enableLookups=\"false\" acceptCount=\"10\" debug=\"0\" URIEncoding=\"UTF-8\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" proxyName=\"ourclass.com\" proxyPort=\"443\" scheme=\"https\"/&gt; 保存重新启动wiki系统就好了。 总结这个问题的解决方案还是需要理解confluence的几个核心的组件，然后在根据这些核心的组件进行相应的配置。尤其是这个/synchrony组件非常关键，如果不加上这个完整的服务根本就起不来。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"Confluence","slug":"Confluence","permalink":"http://qinjiangbo.com/tags/Confluence/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://qinjiangbo.com/tags/HTTPS/"},{"name":"Nginx","slug":"Nginx","permalink":"http://qinjiangbo.com/tags/Nginx/"}]},{"title":"Nginx内部应用重定向问题解决","slug":"solutions-to-internal-redirection-of-nginx","date":"2018-05-13T06:58:39.000Z","updated":"2018-05-13T07:10:51.000Z","comments":true,"path":"solutions-to-internal-redirection-of-nginx.html","link":"","permalink":"http://qinjiangbo.com/solutions-to-internal-redirection-of-nginx.html","excerpt":"","text":"由于爬虫小组有很多项目要运行在同一个服务器上，而且大家都想使用80端口，这个时候就需要使用神器Nginx了。关于Nginx的反向代理配置其实网上有很多，但是这里还是有必要仔细说一说本小组的实际情况。 部署项目介绍以反爬虫项目为例，有两个子项目，分别是反爬虫系统和反爬虫后台管理系统，项目如下： 可以看到，这两个项目分别是acs和acsd，一旦Tomcat成功在本地启动，这两个项目对应的接口分别如下： 项目 访问地址 acs http://localhost:8080/acs/ acsd http://localhost:8080/acsd/ Nginx配置文件使用Nginx部署的时候，写了两个子配置文件，acs_server.conf和acsd_server.conf，分别如下：acs_server.conf 12345678910111213141516171819# ACS系统配置server &#123; listen 80; listen 443; ssl on; ssl_certificate /usr/local/etc/ssl/acs.qinjiangbo.com.pem; ssl_certificate_key /usr/local/etc/ssl/acs.qinjiangbo.com.key; server_name acs.qinjiangbo.com.com; access_log logs/access.log main; location / &#123; proxy_pass http://127.0.0.1:8080/acs/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; acsd_server.conf 12345678910111213141516171819# ACSD系统配置server &#123; listen 80; listen 443; ssl on; ssl_certificate /usr/local/etc/ssl/keys/admin.acs.qinjiangbo.com.pem; ssl_certificate_key /usr/local/etc/ssl/keys/admin.acs.qinjiangbo.com.key; server_name admin.acs.qinjiangbo.com; access_log logs/access.log main; location / &#123; proxy_pass http://127.0.0.1:8080/acsd/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 好了，在浏览器端访问的时候直接输入https://acs.qinjiangbo.com/或者是https://admin.acs.qinjiangbo.com/就能访问对应的网站了。 内部应用重定向的问题是这样的，acs这个项目需要进行重定向，也就说，内部会使用request.sendRedirect()进行重定向操作，这个时候前端的URL地址栏就变成了这个地址 多加了一个acs？是的，你没看错。这种情况是由于Nginx多次映射导致的，针对这种情况的解决方案非常少，至少我当时Google和百度了好久都没有令人满意的。这个时候就需要仔细搞清楚Nginx的实现逻辑，只有这样才能知道这个问题的答案。 问题的解决方案其实这个问题的最终解决方案非常简单，我们知道proxy_pass是用来转发请求的，将前台的请求转发到后台服务器，以一个固定的地址。OK，那么我们就需要将这个包含/acs/的地址进行重新改写，这样才能够去掉Nginx内部重定向导致的URL多了一个根目录的问题。这里需要使用rewrite命令，具体的解决方式如下： 123456789101112131415161718192021# ACS系统配置server &#123; listen 80; listen 443; ssl on; ssl_certificate /usr/local/etc/ssl/keys/acs.qinjiangbo.com.pem; ssl_certificate_key /usr/local/etc/ssl/keys/acs.qinjiangbo.com.key; server_name acs.qinjiangbo.com; access_log logs/access.log main; location / &#123; proxy_pass http://127.0.0.1:8080/acs/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; rewrite ^/acs/(.*)$ $scheme://$server_name:$server_port/$1 last; &#125;&#125; 这样的话，问题得解！关于rewrite的具体使用方法，请参考Nginx的官方文档。 总结关于这个问题，困扰了我好久，终于通过自己的努力将这个问题解决了。解决问题的思路一定是现需要理解这个问题出现的原因，然后才能比较好采用对应的解决方案。之前有点着急，到处找解决方案，无果。现在决定仔细思考这个问题的本质，然后就采用上述的方法非常有效地解决了Nginx内部应用重定向的问题。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://qinjiangbo.com/tags/Nginx/"},{"name":"重定向","slug":"重定向","permalink":"http://qinjiangbo.com/tags/重定向/"}]},{"title":"Confluence中给团队空间添加成员","slug":"add-members-to-existing-team-spaces","date":"2018-05-11T12:07:52.000Z","updated":"2018-05-11T12:34:36.000Z","comments":true,"path":"add-members-to-existing-team-spaces.html","link":"","permalink":"http://qinjiangbo.com/add-members-to-existing-team-spaces.html","excerpt":"","text":"最近需要在团队空间的首页展示团队的各个成员信息，在Confluence提供的功能模块中找了好久，都没有找到能够编辑团队成员的功能，因此只能自己进行手工编辑。编辑的步骤如下： 打开团队空间的首页并进行首页的编辑 在最后一个成员的图片后面点击一下，将光标移动到这里 然后在表格的菜单编辑栏寻找并点击此后插入列 在新的列中任意地方进行点击，将光标移动进来 按住Ctl+Shift+A或者是选择菜单栏中的插入更多内容—&gt;其它宏，并且查找Profile Picture。 选择“Profile picture” 在User*这个框中输入你想要添加的成员名称，然后点击插入，这样你的团队成员的头像信息就被插入到文中了 然后使用Ctl+K来添加链接，或者是直接在菜单栏点击插入链接的图标，然后搜索这个团队成员的名字，链接的话设置为Web链接，文字内容就是这个团队成员的名字，链接内容设置为mailto:加上这个团队成员的邮箱 需要将团队成员的名字选择居中对齐 选择固定表格而不是响应式表格样式，以保证整个列表不乱掉。 这个解决方案的来源是Atlassian社区的一个问题，How to add members to existing team spaces?。是一个非常有价值的问题！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"编程经验","slug":"经验感悟/编程经验","permalink":"http://qinjiangbo.com/categories/经验感悟/编程经验/"}],"tags":[{"name":"Confluence","slug":"Confluence","permalink":"http://qinjiangbo.com/tags/Confluence/"},{"name":"团队空间","slug":"团队空间","permalink":"http://qinjiangbo.com/tags/团队空间/"},{"name":"添加成员","slug":"添加成员","permalink":"http://qinjiangbo.com/tags/添加成员/"}]},{"title":"Confluence配置邮件服务器","slug":"mail-server-configuration-of-confluence","date":"2018-05-09T02:19:14.000Z","updated":"2018-05-09T03:04:15.000Z","comments":true,"path":"mail-server-configuration-of-confluence.html","link":"","permalink":"http://qinjiangbo.com/mail-server-configuration-of-confluence.html","excerpt":"","text":"配置Confluence的时候踩了很多坑，各种各样的原因都有，现在写这篇博客记录下踩过的这些坑，以供大家参考。在说这些坑之前先说一下如何配置Confluence的邮件服务器，比较简单。 配置Confluence邮件服务器进入配置中心，选择邮件服务器选项，如下图所示。 然后点击增加新的SMTP邮件服务器，如下图 填好对应的字段就可以了，注意区分各个服务器主机名对应的端口号，如果不填好，后面就会踩好多坑。 25和465端口号之殇我首先申领了一个网易的邮箱，然后找到网易邮箱的配置如下： 12主机名：smtp.163.com端口号：25或465 常规的思路是填写25号端口，因此，我填入25号端口以后，发现根本连接不上smtp.163.com这个邮件服务器，很郁闷。报错信息如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546An error has occurred with sending the test email: com.atlassian.mail.MailException: javax.mail.MessagingException: Exception reading response; nested exception is: java.net.SocketTimeoutException: Read timed out at com.atlassian.confluence.jmx.JmxSMTPMailServer.doSendWithMessageIdSupport(JmxSMTPMailServer.java:120) at com.atlassian.confluence.jmx.JmxSMTPMailServer.send(JmxSMTPMailServer.java:79) at com.atlassian.confluence.admin.actions.mail.SendTestEmailAction.execute(SendTestEmailAction.java:57) at com.opensymphony.xwork.DefaultActionInvocation.invoke(DefaultActionInvocation.java:168) at com.opensymphony.xwork.interceptor.AroundInterceptor.intercept(AroundInterceptor.java:35) ........... ........... at org.apache.catalina.valves.StuckThreadDetectionValve.invoke(StuckThreadDetectionValve.java:206) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:141) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:502) at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1132) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:684) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1533) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1489) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) Caused by: javax.mail.MessagingException: Exception reading response; nested exception is: java.net.SocketTimeoutException: Read timed out at com.sun.mail.smtp.SMTPTransport.readServerResponse(SMTPTransport.java:2210) at com.sun.mail.smtp.SMTPTransport.openServer(SMTPTransport.java:1950) at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:642) at javax.mail.Service.connect(Service.java:317) at javax.mail.Service.connect(Service.java:176) at javax.mail.Service.connect(Service.java:125) at com.atlassian.confluence.jmx.JmxSMTPMailServer.doSendWithMessageIdSupport(JmxSMTPMailServer.java:102) ... 363 more Caused by: java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at com.sun.mail.util.TraceInputStream.read(TraceInputStream.java:110) at java.io.BufferedInputStream.fill(BufferedInputStream.java:246) at java.io.BufferedInputStream.read(BufferedInputStream.java:265) at com.sun.mail.util.LineInputStream.readLine(LineInputStream.java:89) at com.sun.mail.smtp.SMTPTransport.readServerResponse(SMTPTransport.java:2188) ... 369 more 想到是不是服务器没有开25号端口，所以我就在安全组配置了25号端口，然而没有什么用，系统根本不会开启。后来进入阿里云的官方论坛查找答案，发现25号端口被阿里云特意Ban掉了，所以不会开启。 那就试试465号端口？好吧，同样的，在安全组添加465号端口，然后重试一下，记得这一次要加上TLS选项，因为它是采用安全SMTP协议传输的，因此，需要多加一个选项。事实证明，这个根本没有用。 切换邮件服务提供商觉得服务器部署在阿里云的服务器上连接不上网易的邮件服务器，那我就换一个邮件服务提供商—-腾讯企业邮箱。关于腾讯企业邮箱的申请和配置就不再赘述了，拿到了如上图所示的地址和配置： 12主机名：smtp.exmail.qq.com端口号：25或465 好吧，还是一样，采用25号端口和465号端口后依然不行。找到Confluence官网的配置说明，看到了一行字： 123SMTP Port Optional. The port to connect to on the SMTP host. FishEye needs to use port 25 or port 587, because unlike JIRA its initial connection doesn&apos;t use SSL. Port 25 will be used if no port is specified. 也就是说还可以整587端口呗，抱着试一试的心态，发现真心可以！并输出了如下结果： 1Your test message has been sent successfully to xxxxx@xxxxx.com. 总结这里总结一下这些坑，首先服务器部署在阿里云的ECS上面，端口号25是默认关闭的，465端口虽然开启，但是服务器连接超时了，这个只是针对我的这个confluence应用的，对于其它使用Java编写的应用不一定适用，请甄别。587端口是一个邮件里面也会使用的端口，腾讯企业邮箱虽然没有明确说明使用了这个端口，但是经过尝试，确实发现可以使用587端口发送，这也是官方推荐的端口号。网易邮箱则没有这个功能。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"编程经验","slug":"经验感悟/编程经验","permalink":"http://qinjiangbo.com/categories/经验感悟/编程经验/"}],"tags":[{"name":"Confluence","slug":"Confluence","permalink":"http://qinjiangbo.com/tags/Confluence/"},{"name":"邮件服务器","slug":"邮件服务器","permalink":"http://qinjiangbo.com/tags/邮件服务器/"},{"name":"失效","slug":"失效","permalink":"http://qinjiangbo.com/tags/失效/"}]},{"title":"Confluence导出PDF文件不显示中文","slug":"chinese-character-disappear-in-exported-pdf-files-of-confluence","date":"2018-05-08T15:04:08.000Z","updated":"2018-05-08T15:17:14.000Z","comments":true,"path":"chinese-character-disappear-in-exported-pdf-files-of-confluence.html","link":"","permalink":"http://qinjiangbo.com/chinese-character-disappear-in-exported-pdf-files-of-confluence.html","excerpt":"","text":"最近自己搭建了一个Confluence服务器，结果发现导出页面为PDF文件的时候，中文全部消失了，其实问题比较简单，就是Confluence默认字体设置的问题，按照下面的方式设置一下就可以了。 其中，simhei.ttf这个字体的可以点击此处下载。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"编程经验","slug":"经验感悟/编程经验","permalink":"http://qinjiangbo.com/categories/经验感悟/编程经验/"}],"tags":[{"name":"Confluence","slug":"Confluence","permalink":"http://qinjiangbo.com/tags/Confluence/"},{"name":"PDF导出","slug":"PDF导出","permalink":"http://qinjiangbo.com/tags/PDF导出/"}]},{"title":"Java面试问题集锦之计算机网络03","slug":"questions-of-java-interview-computer-networking-03","date":"2018-04-25T14:42:45.000Z","updated":"2018-04-25T15:12:40.000Z","comments":true,"path":"questions-of-java-interview-computer-networking-03.html","link":"","permalink":"http://qinjiangbo.com/questions-of-java-interview-computer-networking-03.html","excerpt":"","text":"1. OSI模型及其各层次的作用？ 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。 数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。 表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 应用层： 是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 2. TCP/IP模型各层次及协议？ 物理层：物理层一般为负责数据传输的硬件，比如我们了解的双绞线电缆、无线、光纤等。比特流光电等信号发送接收数据。 数据链路层：数据链路层一般用来处理连接硬件的部分，包括控制网卡、硬件相关的设备驱动等。传输单位数据帧。 网络层：网络层用来处理网络中流动的数据包，数据包为最小的传递单位，比如我们常用的ip协议、icmp协议、arp协议（通过分析ip地址得出物理mac地址）。 传输层：传输层的作用就是将应用层的数据进行传输转运。比如我们常说的tcp（可靠的传输控制协议）、udp（用户数据报协议）。传输单位为报文段。 应用层：应用层是我们经常接触使用的部分，比如常用的http协议、ftp协议（文件传输协议）、snmp（网络管理协议）、telnet （远程登录协议 ）、smtp（简单邮件传输协议）、dns（域名解析），这次主要是面向用户的交互的。这里的应用层集成了osi分层模型中 的应用、会话、表示层三层的功能。 3. 数据链路层的MAC层(介质访问控制层)是什么？MAC层主要负责控制与连接物理层的物理介质。在发送数据的时候，MAC协议可以事先判断是否可以发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层；在接收数据的时候，MAC协议首先判断输入的信息并是否发生传输错误，如果没有错误，则去掉控制信息发送至LLC（逻辑链路控制）层。 4. 计算机网络协议、接口和服务的概念? 协议就是规则的集合。在网络中药做到有条不紊地交换数据，就必须遵循一些事先约定好的规则。这些规则明确规定了所交换的数据的格式以及相关的同步问题。协议由语法、语义和同步三部分组成。（1）语法规定了传输数据的格式；（2）语义规定了所要完成的功能，即需要发出何种控制信息、完成何种动作以及做出何总应答；（3）同步规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。 一个完整的 协议通常应具有线路管理（建立、释放连接）、差错控制、数据转换等功能。 接口是统一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。每一层只能为紧邻的层次之间定义接口，不能跨层定义接口。 服务是指下层为紧向邻的上层提供的功能调用，也就是垂直的。对等实体在协议的控制下，使得本层能为上一层提供服务，但要实现本层协议还需要使用下一层所提供的服务。 上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在 OSI中称为服务原语。 5. 数据链路层：流量控制、可靠传输和滑动窗口机制 流量控制：接收方控制发送方，发送方的速率不要太快，让接收方来得及接收。 差错控制：帧错误、帧丢失、帧重复。 滑动窗口机制：滑动窗口机制中的“窗口”是指发送端和接收端的缓存空间大小；“滑动”的意思是指缓存空间中存放的未处理帧数是变化的，发送端在收到确认帧后会删除原来保存在缓存中的待重发帧，而接收端向网络层提交一个帧后也会删除原来保存在缓存中的帧。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"面试集锦","slug":"经验感悟/面试集锦","permalink":"http://qinjiangbo.com/categories/经验感悟/面试集锦/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://qinjiangbo.com/tags/计算机网络/"},{"name":"Java面试","slug":"Java面试","permalink":"http://qinjiangbo.com/tags/Java面试/"}]},{"title":"Java面试问题集锦之操作系统02","slug":"questions-of-java-interview-operating-system-02","date":"2018-04-21T04:27:19.000Z","updated":"2018-04-23T02:25:16.000Z","comments":true,"path":"questions-of-java-interview-operating-system-02.html","link":"","permalink":"http://qinjiangbo.com/questions-of-java-interview-operating-system-02.html","excerpt":"","text":"13. Linux32位系统，应用程序最多能分配的内存大小？32位linux不打开PAE，则最多只能识别出4GB内存，若打开PAE，则最多可以识别出64GB内存。但是 32位系统下的进程一次最多只能寻址4GB的空间。 PAE：物理地址扩展 14. sleep和wait的区别？ sleep方法正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(注意：sleep方法只让出了CPU，而并不会释放同步资源锁)； wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度）； 15. 什么是临界资源？什么是临界区？ 临界资源：把一次只允许一个进程使用的资源成为临界资源。(独占性，如打印机，卡片输出机等) 临界区：把每个进程中访问临界资源的那段代码从概念上分离出来，将其称为临界区。即临界区是指对临界资源实时操作的程序的代码段。 相关临界区：并发进程中涉及相同临界资源的临界区。相关临界区必须互斥执行。 16. 什么是进程互斥？ 进程互斥是解决进程间竞争关系(间接制约关系)的手段。指任何时刻不允许两个以上的共享该资源的并发进程同时进入临界区，这种现象称为互斥。 相关临界区的管理原则：互斥、空闲让进、有限等待。 17. 进程同步的概念？进程同步指两个或多个进程为了合作完成同一个任务，在执行速度或某些确定的时序点上必须相互协调，即一个进程的执行依赖于另一个进程的消息，当一个进程到达了某一个确定点而没有得到合作伙伴发来的已完成消息时必须等待，知道该消息到达被唤醒后，才能继续向前推进。 18. 进程同步和互斥的关系？ 进程的互斥实际上是进程同步的一种特殊情况，即主次使用互斥共享资源，也是对进程使用资源次序上的一种协调。进程的互斥和同步统称为进程同步。 进程的互斥是进程间共享资源的使用权，这种竞争没有固定的必然联系，哪个进程竞争到资源的使用权，该资源就归哪个进程使用，直到它不再需要使用时才归还资源；而进程同步中，所涉及的共享资源的并发进程间有一种必然的联系，当进程必须同步时，即使无进程在使用共享资源，尚未得到同步消息的进程也不能去使用该资源。 19. 信号量机制(PV操作)信号量机制的实现原理是两个或多个进程可以利用彼此间收发的简单信号来实现正确的并发执行，一个进程在收到一个指令信号前，会被迫在一个确定的或者需要的地方停下来，从而保持同步或互斥。 20. 同步的实现机制 临界区：通过多线程的串行化来访问公共资源或者一段代码，速度快，适合控制数据访问。 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以可以保证公共资源不会同时被多个线程访问。 信号量：允许多个线程同时访问同一资源，但是需要限制同一时刻访问此资源的最大线程数目。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统PV操作相似。 事件(信号)：通过通知操作的方式保持多线程同步，还可以方便的实现多线程的优先级比较的操作。 21. 经典的同步问题 生产者消费者问题 读者-写者问题（读者优先：信号量+读进程计数器rc；弱写者优先：信号量+读进程计数器rc+排队信号量read；强写者优先：信号量+读进程计数器rc+排队信号量read+写优先信号量write_first） 哲学家就餐问题：是在多个线程之间共享多个资源时会不会导致死锁或饥饿的典型模型。解决方案：i. 每个哲学家取得手边的两个叉子才能吃面，即仅当一个哲学家左右两边的叉子都可用时，才允许他拿叉子，否则一个叉子也不取。ii. 偶数号哲学家先取手边的叉子，奇数号哲学家先取右手边的叉子。 嗜睡理发师问题 22. 进程通信的方式 共享存储：消息缓冲 消息传递：信箱 管道通信 23. 产生死锁的条件 互斥条件：同时只能有一个进程持有资源 请求和保持条件：一个进程请求资源得不到满足时，不释放占有的资源 不剥夺条件：任何一个进程不能抢夺其他进程占有的资源 循环等待条件：存在一个循环等待链，链中每个进程已获得资源，并分别等待前一个进程持有的资源。 24. 处理死锁的方法 死锁预防：破坏产生死锁条件的任何一个或多个，如静态资源分配策略(2)和按序分配资源策略(4)。 死锁避免：采用银行家算法，每次分配都查看能否找到一种资源分配方法，使得已有的进程可以顺利完成任务，如果有，则分配，否则不分配。 死锁检测和解除：用软件来检查有进程和资源构成的有向图是否存在一个或多个回路。 25. 分页和分段的区别 分页是信息的物理单位，与源程序的逻辑结构无关，用户不可见，分页的目的主要是为了减少碎片，提高主存的利用率。分段是信息的逻辑单位，由源程序的逻辑结构来决定，目的是更好地满足用户的需求。 页的大小固定且由系统确定，而段的长度不固定，由用户程序决定。 分页的作业地址空间是一维的(线性地址空间)，分段的作业地址空间是二维的(段名和段内地址) 26. 缓存的局部性原理根据研究，在较短的时间内，程序的执行会局限于某一个部分，则可以根据当前程序运行的位置，推测可能执行的程序，预先加载，来达到缓存的目的。(虚拟内存的实现) 27. 同步和异步有什么不同？ 同步，就是说你的程序在执行某一个操作时一直等待直到操作完成。最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 RESULT值返回给调用者。 异步，就是说程序在执行某一个操作时，只是发出开始的指令；由另外的并行程序执行这段代码，当完成时再通知调用者。当一个客户端通过调用Connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。 28. 什么是线程？有哪些状态？一个线程是进程的一个顺序执行流。同类的多个线程共享一块内存空间和一组系统资源，线程本身有一个供程序执行时的堆栈。线程在切换时负荷小，因此，线程也被称为轻负荷进程。一个进程中可以包含多个线程。 状态如下： 新建状态：新建线程对象，并没有调用start()方法之前 就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态哦。 运行状态：线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态 阻塞状态：线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态 死亡状态：线程执行结束 29. synchronized和Lock的异同？ table th:first-of-type { width: 150px; } table th:nth-of-type(2) { width: 300px; } table th:nth-of-type(3) { width: 300px; } 类别 synchronized Lock 存在层次 Java的关键字，在jvm层面上 是一个类 锁的释放 1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁 在finally中必须释放锁，不然容易造成线程死锁 锁的获取 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待 分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待 锁状态 无法判断 可以判断 锁类型 可重入 不可中断 非公平 可重入 可判断 可公平（两者皆可） 性能 少量同步 大量同步 30. 什么是序列化？什么是串行化？把对象转换为字节序列的过程称为对象的序列化。把字节序列恢复为对象的过程称为对象的反序列化。 序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。 对象的序列化主要有两种用途： 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中； 在网络上传送对象的字节序列。 串行化和并行化 串行化也叫做序列化，就是把存在于内存的对象数据转化成可以保存成硬盘文件的形式去存储； 并行化也叫反序列化，就是把序列化后的硬盘文件加载到内存,重新变成对象数据。 也就是把内存中对象数据变成硬盘文件. 31. 什么是守护线程与用户线程 ？举一个守护线程的例子 用户线程：我们平常创建的普通线程。 守护线程：用来服务于用户线程；不需要上层逻辑介入。 当主线程结束时，结束其余的子线程（守护线程）自动关闭，就免去了还要继续关闭子线程的麻烦。如：Java垃圾回收线程就是一个典型的守护线程；内存资源或者线程的管理，但是非守护线程也可以。 32. synchronized关键字的用法 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"面试集锦","slug":"经验感悟/面试集锦","permalink":"http://qinjiangbo.com/categories/经验感悟/面试集锦/"}],"tags":[{"name":"Java面试","slug":"Java面试","permalink":"http://qinjiangbo.com/tags/Java面试/"},{"name":"操作系统","slug":"操作系统","permalink":"http://qinjiangbo.com/tags/操作系统/"}]},{"title":"网站大图片加载原理","slug":"principle-of-large-image-loading","date":"2018-04-03T05:06:49.000Z","updated":"2018-04-03T06:21:32.000Z","comments":true,"path":"principle-of-large-image-loading.html","link":"","permalink":"http://qinjiangbo.com/principle-of-large-image-loading.html","excerpt":"","text":"前面一篇博客讲述的是图片的懒加载过程，即只有页面滑动到图片所在的位置时才会触发加载的操作。本文在此基础上进行了进一步的研究，即不管用户什么时候打开页面，所有的图片都加载了，而不是给用户显示一个Loading的图标，只不过我们的初始显示的图片是模糊的，后面再慢慢加载清晰，保证网页加载是流畅的。 有两张图片，都是樱花图，sakura.jpeg和sakura_min.jpeg两张。分别如下： 大小是6.9M，分辨率是6000*4000 大小是34K，分辨率是1134*768 可以看到，压缩过的小图片使用了高斯模糊，而且非常小。在3G网络下，我们看两张图片的加载速度： 非常直观地给我们显示出小图片加载的时间为950ms，而大图片的加载时间达到了38.89s。当然了，这只是3G网络下，4G网络下的速度可能会更快一些，但是这个区别还是非常明显的。 我们给出测试页面的代码： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;大图片加载测试页&lt;/title&gt; &lt;style type=\"text/css\"&gt; img &#123; width: 100%; &#125; &lt;/style&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"https://obrxbqjbi.qnssl.com/blog/image/sakura_min.jpeg\"/&gt;&lt;!--&lt;img src=\"https://obrxbqjbi.qnssl.com/blog/image/sakura.jpeg\"/&gt;--&gt;&lt;script&gt;$(function()&#123; //一段正则，匹配所有_min的图片src属性 var test = /_min/ //遍历所有的图片节点 $(\"img\").each(function(index,obj)&#123; if(test.test($(this).attr(\"src\")))&#123; var reSrc = $(this).attr(\"src\").replace(test,\"\"); $(this).attr(\"src\",reSrc) &#125; &#125;)&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 还有另外一种实现方式就是通过使用data属性，比如在img标签中添加一个data-src属性，直接通过这个替换即可，而不是通过特定的规则来约束整个文件的命名。 总结关于网页大图片加载的研究有很多，通常是采用的懒加载方式，本文提供了另一种解决的思路，其实从技术实现上来说都差不多，只不过解决的角度不同。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"前端","slug":"开发技术/前端","permalink":"http://qinjiangbo.com/categories/开发技术/前端/"}],"tags":[{"name":"大图片","slug":"大图片","permalink":"http://qinjiangbo.com/tags/大图片/"},{"name":"加载","slug":"加载","permalink":"http://qinjiangbo.com/tags/加载/"}]},{"title":"[转]使用jQuery实现图片懒加载原理","slug":"basic-principle-of-image-lazy-loading-with-jquery","date":"2018-04-02T08:49:45.000Z","updated":"2018-04-02T08:57:12.000Z","comments":true,"path":"basic-principle-of-image-lazy-loading-with-jquery.html","link":"","permalink":"http://qinjiangbo.com/basic-principle-of-image-lazy-loading-with-jquery.html","excerpt":"","text":"在网页中，常常需要用到图片，而图片需要消耗较大的流量。正常情况下，浏览器会解析整个HTML代码，然后从上到下依次加载&lt;img src=&quot;xxx&quot;&gt;的图片标签。如果页面很长，隐藏在页面下方的图片其实已经被浏览器加载了。如果用户不向下滚动页面，就没有看到这些图片，相当于白白浪费了图片的流量。 所以，淘宝、京东这些流量非常巨大的电商，商品介绍页又必须有大量的图片，因此，这些页面的图片都是“按需加载”，即用户滚动页面时显示出来的时候才加载图片。当网速非常快的时候，用户并不能感知懒加载的动作，既省流量又不影响用户浏览。 本文给出一种利用jQuery实现图片懒加载的原理。它的基本思想是：在输出HTML的时候，不要直接输出&lt;img src=&quot;xxx&quot;，而是输出如下的img标签： 1&lt;img src=\"/static/loading.gif\" data-src=\"http://真正的图片地址/xxx.jpg\"&gt; 因此，页面显示的图片是一个gif加载动画。当页面滚动时，如果图片出现在屏幕中，就利用jQuery把&lt;img&gt;的src属性替换为data-src的内容，浏览器就会实时加载。 JavaScript代码如下： 1234567891011121314151617181920212223242526272829303132333435363738// 注意: 需要引入jQuery和underscore$(function() &#123; // 获取window的引用: var $window = $(window); // 获取包含data-src属性的img，并以jQuery对象存入数组: var lazyImgs = _.map($('img[data-src]').get(), function (i) &#123; return $(i); &#125;); // 定义事件函数: var onScroll = function() &#123; // 获取页面滚动的高度: var wtop = $window.scrollTop(); // 判断是否还有未加载的img: if (lazyImgs.length &gt; 0) &#123; // 获取可视区域高度: var wheight = $window.height(); // 存放待删除的索引: var loadedIndex = []; // 循环处理数组的每个img元素: _.each(lazyImgs, function ($i, index) &#123; // 判断是否在可视范围内: if ($i.offset().top - wtop &lt; wheight) &#123; // 设置src属性: $i.attr('src', $i.attr('data-src')); // 添加到待删除数组: loadedIndex.unshift(index); &#125; &#125;); // 删除已处理的对象: _.each(loadedIndex, function (index) &#123; lazyImgs.splice(index, 1); &#125;); &#125; &#125;; // 绑定事件: $window.scroll(onScroll); // 手动触发一次: onScroll(); onScroll()函数最后要手动触发一次，因为页面显示时，并未触发scroll事件。如果图片已经在可视区域内，这些图片仍然是loading状态，需要手动触发一次，就可以正常显示。 要测试图片懒加载效果，可以在Chrome浏览器的控制台选择“Network”，把“Online”改为“Slow 3G”就可以模拟慢速网络下浏览器懒加载图片的效果： 原文地址：https://www.liaoxuefeng.com/article/00151045553343934ba3bb4ed684623b1bf00488231d88d000","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"前端","slug":"开发技术/前端","permalink":"http://qinjiangbo.com/categories/开发技术/前端/"}],"tags":[{"name":"懒加载","slug":"懒加载","permalink":"http://qinjiangbo.com/tags/懒加载/"},{"name":"大图片","slug":"大图片","permalink":"http://qinjiangbo.com/tags/大图片/"},{"name":"jQuery","slug":"jQuery","permalink":"http://qinjiangbo.com/tags/jQuery/"}]},{"title":"珞·樱","slug":"luo-ying","date":"2018-04-01T09:05:20.000Z","updated":"2018-05-13T09:29:38.000Z","comments":true,"path":"luo-ying.html","link":"","permalink":"http://qinjiangbo.com/luo-ying.html","excerpt":"","text":"今天放出一组樱花节拍摄的樱花美图。敬请欣赏！温馨提示，下面的图片分辨率比较高，因此图片很大，建议在Wifi网络环境下打开，土豪随意~","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"摄影","slug":"经验感悟/摄影","permalink":"http://qinjiangbo.com/categories/经验感悟/摄影/"}],"tags":[{"name":"樱花","slug":"樱花","permalink":"http://qinjiangbo.com/tags/樱花/"},{"name":"武汉大学","slug":"武汉大学","permalink":"http://qinjiangbo.com/tags/武汉大学/"}]},{"title":"Java面试问题集锦之操作系统01","slug":"questions-of-java-interview-operating-system-01","date":"2018-04-01T07:13:50.000Z","updated":"2018-04-21T04:31:38.000Z","comments":true,"path":"questions-of-java-interview-operating-system-01.html","link":"","permalink":"http://qinjiangbo.com/questions-of-java-interview-operating-system-01.html","excerpt":"","text":"最近春招很多人都在找工作，我给学弟学妹学妹进行了一些基础知识上的辅导和面试技巧上的一些交流，觉得自己也还有一些知识的盲区，需要再重新温习温习一下相关的知识。作为记录，我将一些面试中同学们反馈给我的问题以及一些有可能会问到的问题进行总结，以供大家参考。 01. 请叙述一下并行和并发两个概念的区别？并行（parallellism）和并发（concurrency）是： 解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。 解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。 解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。 02. 什么是进程？什么是线程？ 进程是一个可并发执行的，具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和调度的独立单位。进程是资源分配的基本单位。 线程也称为轻量级进程(LWP)，是程序执行流量的最小单位，它是进程的一个实体，是系统独立调度和分派处理机的基本单位。线程是操作系统调度的最小单位。 03. 进程和线程的区别？从调度、并发性、拥有资源和系统开销四个方面来比较 调度。在引入线程的操作系统中，把线程作为调度和分派CPU的基本单位，把进程作为资源分配的基本单位，显著提高了并发程度。由于系统调度的基本单位是线程，所以每个进程至少创建一个线程，否则无法被调度。 并发性。多线程可以提高服务的质量，在一个线程阻塞时，还有其他线程提供服务。 拥有资源。进程是拥有资源的独立单位，线程自己不拥有系统资源，而是共享进程的资源(包括代码段、数据段即系统资源等)。 系统开销。进程切换的开销远远大于线程切换的开销，进程的切换需要保存很多现场，但线程只需要保存和设置少量的寄存器内容，不涉及存储器管理方面的操作。 04. 进程的特征？ 动态性：进程是动态产生和动态消亡的，有其生存周期。 并发性：一个进程可以与其他进程一起向前推进。 独立性：一个进程是一个相对完整的调度单位。 异步性：每个进程都已相对独立、不可预知的速度向前推进。 结构性：为了控制和管理进程，系统为每个进程设立一个进程控制块(PCB)。 05. 进程有几种状态？ 创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态 就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行 执行状态：进程处于就绪状态被调度后，进程进入执行状态 阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用 终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行 06. 为什么会提出线程这个概念？进程的缺点是什么？ 进程切换开销大 进程通信代价大 进程之间并发性粒度粗，并发度不高 不适合并行计算和分布式并行计算的要求 不适合客户-服务器(C/S)计算的要求 操作系统中引入进程的目的是为了使多个程序并发执行，改善资源的利用率以提高系统的吞吐量。 07. 线程的分类 用户级线程 – ULT(User Level Thread)，优点是线程切换不需要系统状态的转换，每个进程可以使用专门的调度算法来调度线程，不需要依赖操作系统底层的内核。缺点是父进程阻塞会导致线程全都阻塞，不能真正的并行。Java的线程就是一种用户级的线程。 内核级线程 – KLT(Kernel Level Threal)，优点是同一个进程内多个线程可以并行执行，缺点是线程状态转换时内核态的任务，通常很慢。 混合式线程 – 上两种的结合，有良好的效果。 08. 进程控制块的作用？它是如何描述进程动态性质的？操作系统组织PCB的方式有索引式（数组）、链式（链表）。Linux系统是采用链式方式来组织PCB的，对于不同的状态建立起一个进程队列。在系统中可能有很多个进程处于相同的状态，这些进程构成一个进程队列，比如由于不同的阻塞原因而阻塞的进程。 (1) PCB是系统感知进程存在的唯一标志，是进程动态特性的集中反映，和进程一一对应，操作系统通过管理PCB来管理进程。 (2) PCB中保存了进程的所有信息，将这些信息可以分为几大类： 1、进程标识信息。比如进程ID、所属用户ID、所属组ID、父进程ID等。 2、进程控制信息。比如进程调度信息、进程通信机制等。 3、进程资源信息。比如打开的文件、进程地址空间等。 4、cpu状态信息。用来进程被中断时保护现场。 09. 操作系统的四大特性操作系统的四大特征：并发、共享、虚拟、异步。 并发。在一段时间内，运行多个程序，执行多个任务。从宏观上来说的。操作系统中引入进程的目的就是为了使程序能并发执行。 共享。资源共享，即系统中的资源可供多个并发执行的进程共同使用。 虚拟。把物理上的一台设备变成逻辑上的多台设备。虚拟，可以理解为是用户感觉上的。 异步。在多道程序环境下，允许多个程序并发执行。但由于资源有限，进程的执行不是一贯到底，而是走走停停，已不可预知的速度向前推进，这就是进程的异步性。 10. 进程调度的方式 非抢占式方式：优点是简单、易实现，系统开销小。缺点是不太灵活，难以满足紧迫任务必须立即执行的要求。实时系统不宜采用这种调度方式。 抢占式方式：优先权更高的进程优先执行。 11. 进程调度的算法 先来先服务算法 最短优先算法 优先级算法：优先级高的先执行。可以采用剥夺或非剥夺，剥夺方式更能反映优先的特点，但是会造成无穷阻塞和饥饿现象。 轮转算法：基本思想是系统把所有就绪进程按先来先服务的原则排成一个队列，且规定一个较小的时间单元，称为时间量或时间片，按时间片把CPU轮流分配给进入就绪队列的第一个进程使用，当进程的时间片使用完后，产生一个时钟中断，剥夺该进程的执行，将它送到就绪队列的队尾，等待下次调度。轮转算法专门为分时系统设计。 多级队列调度算法：根据不同的进程，分配到不同的队列中，实行不同的调度算法。一般按照优先级分成多个队列，高优先级的任务先做。 多级反馈队列调度算法：按优先级分配队列，但是优先级越高分配的时间片越小，如果没做完，自动移动到下一级队列继续做。 实时调度算法：在限定的响应时间内提供所需水平的服务。 12. 哪种权限许可用户进入一个文件系统的目录？Read，Execute，Write，Access Controll，注意可执行权限很重要。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"面试集锦","slug":"经验感悟/面试集锦","permalink":"http://qinjiangbo.com/categories/经验感悟/面试集锦/"}],"tags":[{"name":"Java面试","slug":"Java面试","permalink":"http://qinjiangbo.com/tags/Java面试/"},{"name":"操作系统","slug":"操作系统","permalink":"http://qinjiangbo.com/tags/操作系统/"}]},{"title":"MySQL数据库乱码解决方案","slug":"solutions-to-chinese-messy-code-in-mysql-database","date":"2018-03-28T04:59:53.000Z","updated":"2018-03-28T05:21:47.000Z","comments":true,"path":"solutions-to-chinese-messy-code-in-mysql-database.html","link":"","permalink":"http://qinjiangbo.com/solutions-to-chinese-messy-code-in-mysql-database.html","excerpt":"","text":"还是最近的这个Java Web项目，在本机运行好好的，一到服务器就出现了中文乱码的问题。虽然感觉很奇怪，但是还是顺着思路一步一步给解决了。解决的思路如下。 查看Java Web项目中接收的中文是否乱码有一个业务逻辑就是要获取浏览器输入的中文，在处理中文输入的地方加上一句输出语句可以看到日志中记录如下： 122018-03-28 11:26:33 [INFO] - org.springframework.web.servlet.DispatcherServlet - FrameworkServlet.java(508) - FrameworkServlet &apos;servlet&apos;: initialization completed in 4321 ms[content]: &lt;p style=&quot;display:none;&quot;&gt;习近平欢迎各国使节来华履新，请他们转达对各有关国家领导人和人民的诚挚问候和美好祝愿，表示中国政府将为各国使节履职提供便利和支持，希望使节们发挥桥梁和纽带作用，为增进中国同各国友谊、推动双边关系发展作出积极贡献。&lt;/p&gt; 说明中文输入是没有问题的，问题就出现在了Java Web服务器与MySQL数据库的交互上面，因此现在查找的方向就是MySQL数据库编码情况。 查看MySQL数据库的字符编码情况在终端打开MySQL数据库： 1$ mysql -u root -p 然后再选择数据库并查看其编码情况： 1234567891011121314MariaDB [anti_crawler_system]&gt; show variables like \"%char%\";+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec) 很明显可以看到character_set_server是latin1编码，估计这个地方就是元凶。 修改my.cnf文件切换到/etc目录下，编辑my.cnf文件，和我一样即可，注意配置添加的顺序哦。 123456789101112131415161718192021222324[mysqld]# 这个地方添加一行character-set-server=utf8character-set-server=utf8datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0# Settings user and group are ignored when systemd is used.# If you need to run mysqld under a different user or group,# customize your systemd unit file for mariadb according to the# instructions in http://fedoraproject.org/wiki/Systemd[mysqld_safe]log-error=/var/log/mariadb/mariadb.logpid-file=/var/run/mariadb/mariadb.pid# 这个地方把下面这两行补上即可[client]default-character-set=utf8[mysql]default-character-set=utf8## include all files from the config directory 重启MySQL服务器，具体方法见上一篇博客。然后再次查看编码可以看到： 1234567891011121314MariaDB [anti_crawler_system]&gt; show variables like \"%char%\";+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec) 再次查看数据库中的数据，发现一切正常，因此可以看到罪魁祸首的确是这个地方。 总结关于MySQL数据库修改编码的方式还有很多，但是基本上都是临时修改而已，数据库一旦重新启动则还是原来的编码，因此需要在配置文件中指定好，这样不管重启多少次，都是没有问题的。查找BUG的时候一定要冷静，按照思路一步一步的排查，一定可以找到解决方案的。","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"MySQL","slug":"数据科学/MySQL","permalink":"http://qinjiangbo.com/categories/数据科学/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://qinjiangbo.com/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://qinjiangbo.com/tags/CentOS/"},{"name":"乱码","slug":"乱码","permalink":"http://qinjiangbo.com/tags/乱码/"}]},{"title":"[转]CentOS下重启MySQL的方法","slug":"methods-of-restarting-mysql-in-centos","date":"2018-03-28T04:41:00.000Z","updated":"2018-03-28T04:57:00.000Z","comments":true,"path":"methods-of-restarting-mysql-in-centos.html","link":"","permalink":"http://qinjiangbo.com/methods-of-restarting-mysql-in-centos.html","excerpt":"","text":"在网上着了一些方法，但是大多都不是很全，这里转载一篇文章，有各种方式的MySQL在CentOS下面的重启方式，推荐。 通过rpm包安装的MySQL12$ service mysqld restart$ /etc/inint.d/mysqld start 从源码包安装的MySQL12345# linux关闭MySQL的命令$ $mysql_dir/bin/mysqladmin -uroot -p shutdown# linux启动MySQL的命令$ $mysql_dir/bin/mysqld_safe &amp; 其中mysql_dir为MySQL的安装目录，mysqladmin和mysqld_safe位于MySQL安装目录的bin目录下。 通过强行命令杀进程以上方法都无效的时候，可以通过强行命令：killall mysqld来关闭MySQL。 原文地址：https://blog.csdn.net/gz747622641/article/details/54669464","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"MySQL","slug":"数据科学/MySQL","permalink":"http://qinjiangbo.com/categories/数据科学/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://qinjiangbo.com/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://qinjiangbo.com/tags/CentOS/"}]},{"title":"Tomcat启动变慢问题解决方案","slug":"solutions-to-slow-startup-time-of-tomcat-web-server","date":"2018-03-27T17:01:36.000Z","updated":"2018-03-27T17:27:13.000Z","comments":true,"path":"solutions-to-slow-startup-time-of-tomcat-web-server.html","link":"","permalink":"http://qinjiangbo.com/solutions-to-slow-startup-time-of-tomcat-web-server.html","excerpt":"","text":"最近发现Tomcat在服务器上部署的时间越来越长，以前是需要大概5-6秒中，现在的实践基本上是5-6分钟，而且一直卡在这个地方： 128-Mar-2018 00:58:11.810 INFO [localhost-startStop-1] org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time. 因此我认为是由于扫描了不应该扫描的包导致了，Stackoverflow上也给出了对应的解决方案：修改Tomcat目录下面的conf/context.xml文件，在里面添加一行代码即可： 1&lt;JarScanner scanClassPath=\"false\"/&gt; 但是并没有什么用。因此我认为是服务器（1核2G）的原因，但是直到我在网上搜索Tomcat服务器启动慢的问题，发现大多数人都是卡了5-6分钟，因此我想这应该是一个通病，所以选择了其中一篇文章进行深读，终于找到了使Tomcat启动变慢的元凶。 原文地址：https://blog.csdn.net/chszs/article/details/49494701 Tomcat 8启动很慢，且日志上无任何错误，在日志中查看到如下信息： 123Log4j:[2015-10-29 15:47:11] INFO ReadProperty:172 - Loading properties file from class path resource [resources/jdbc.properties]Log4j:[2015-10-29 15:47:11] INFO ReadProperty:172 - Loading properties file from class path resource [resources/common.properties]29-Oct-2015 15:52:53.587 INFO [localhost-startStop-1] org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [342,445] milliseconds. 原因Tomcat 7/8都使用org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom类产生安全随机类SecureRandom的实例作为会话ID，这里花去了342秒，也即接近6分钟。 SHA1PRNG算法是基于SHA-1算法实现且保密性较强的伪随机数生成器。 在SHA1PRNG中，有一个种子产生器，它根据配置执行各种操作。 如果java.security.egd属性或securerandom.source属性指定的是”file:/dev/random”或”file:/dev/urandom”，那么JVM会使用本地种子产生器NativeSeedGenerator，它会调用super()方法，即调用SeedGenerator.URLSeedGenerator(/dev/random)方法进行初始化。 如果java.security.egd属性或securerandom.source属性指定的是其它已存在的URL，那么会调用SeedGenerator.URLSeedGenerator(url)方法进行初始化。 这就是为什么我们设置值为”file:///dev/urandom”或者值为”file:/./dev/random”都会起作用的原因。 在这个实现中，产生器会评估熵池（entropy pool）中的噪声数量。随机数是从熵池中进行创建的。当读操作时，/dev/random设备会只返回熵池中噪声的随机字节。/dev/random非常适合那些需要非常高质量随机性的场景，比如一次性的支付或生成密钥的场景。 当熵池为空时，来自/dev/random的读操作将被阻塞，直到熵池收集到足够的环境噪声数据。这么做的目的是成为一个密码安全的伪随机数发生器，熵池要有尽可能大的输出。对于生成高质量的加密密钥或者是需要长期保护的场景，一定要这么做。 那么什么是环境噪声？随机数产生器会手机来自设备驱动器和其它源的环境噪声数据，并放入熵池中。产生器会评估熵池中的噪声数据的数量。当熵池为空时，这个噪声数据的收集是比较花时间的。这就意味着，Tomcat在生产环境中使用熵池时，会被阻塞较长的时间。 解决有两种解决办法： 在Tomcat环境中解决，可以通过配置JRE使用非阻塞的Entropy Source。在catalina.sh中加入这么一行：-Djava.security.egd=file:/dev/./urandom 即可。 在JVM环境中解决，打开$JAVA_PATH/jre/lib/security/java.security这个文件，找到下面的内容：securerandom.source=file:/dev/urandom替换成securerandom.source=file:/dev/./urandom 加入后再启动Tomcat，整个启动耗时下降到Server startup in 2912 ms。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://qinjiangbo.com/tags/Tomcat/"},{"name":"启动很慢","slug":"启动很慢","permalink":"http://qinjiangbo.com/tags/启动很慢/"}]},{"title":"Crontab执行脚本失效原因分析","slug":"analysis-of-crontab-failures","date":"2018-03-27T01:53:21.000Z","updated":"2018-03-27T02:46:25.000Z","comments":true,"path":"analysis-of-crontab-failures.html","link":"","permalink":"http://qinjiangbo.com/analysis-of-crontab-failures.html","excerpt":"","text":"近期需要在服务器上跑一个python脚本，但是发现单独使用python命令去调用这个脚本是可以的，但是一旦加入到定时任务中就不行了。找了很多原因，现总结如下。先给出我的运行时脚本内容和定时任务： 12#!/bin/bash/bin/echo \"Hello World!\"&gt;&gt;/root/hello.txt crontab -e编辑定时任务，本文的定时任务为每分钟执行一次： 1* * * * * /root/scripts/daily_run.sh 使用Shell脚本来调用Python脚本为什么要写这个呢？因为Python脚本中如果包含了对文件的操作，那么这个python脚本的目录默认就定位了/home/username/下，因此很多路径都会出错，因此把这些操作使用Shell脚本封装起来就能按照Python脚本中定义的路径去操作了。 没有指明运行时环境网上有一种说法是需要在运行时指定脚本的运行时环境，即加入以下一行代码到daily_run.sh中： 1234if [ -f ~/.bash_profile ];then . ~/.bash_profilefi 但是通过本文的实践可以看到，不加这个也是可以的。但是如果你运行不了程序，其他原因都找遍了，可以试试这个。 Shell脚本中的命令不是全路径可以看到本文的Shell脚本中echo的写法是/bin/echo，这里是需要指明全路径的。否则很容易出现找不到命令的情况，从而导致任务执行失败。 Shell脚本的权限问题*这个问题是所有人都容易忽略的问题，当你创建完一个用于执行定时任务的脚本时候，你一定要修改它的权限为可执行，最简单的方式就是chmod 777 daily_run.sh。本文找了好久的BUG就是因为没有给daily_run.sh脚本赋上可执行权限。 总结针对定时任务失败的问题，首先需要弄懂是任务不能执行还是任务被定时任务调度器执行了，但是脚本里面的内容执行失败了，这样就可以针对性地定位问题和给出解决方案。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Python","slug":"开发技术/Python","permalink":"http://qinjiangbo.com/categories/开发技术/Python/"}],"tags":[{"name":"crontab","slug":"crontab","permalink":"http://qinjiangbo.com/tags/crontab/"},{"name":"python","slug":"python","permalink":"http://qinjiangbo.com/tags/python/"}]},{"title":"[转]VisualVM 入门指南","slug":"getting-started-with-visualvm","date":"2018-03-26T11:14:24.000Z","updated":"2018-03-28T07:37:22.000Z","comments":true,"path":"getting-started-with-visualvm.html","link":"","permalink":"http://qinjiangbo.com/getting-started-with-visualvm.html","excerpt":"","text":"VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。 本入门指南应当对您快速设置并运行 VisualVM 有所帮助。本指南将演示如何安装 VisualVM，以及如何通过安装 VisualVM 更新中心提供的插件向该工具添加功能。本指南还将介绍如何启动 VisualVM，以及如何查看可以获取的一些有关本地和远程 JVM 上运行的应用程序的信息。 安装 VisualVM 从 VisualVM 项目页下载 VisualVM 安装程序。 将 VisualVM 安装程序解压缩到本地系统。 导航至 VisualVM 安装目录的 bin 目录，然后启动应用程序。 使用“应用程序”窗口在启动应用程序后，将打开 VisualVM 的主窗口。缺省情况下，“应用程序”窗口显示在主窗口的左窗格中。在“应用程序”窗口中，可以快速查看本地和远程 JVM 上运行的 Java 应用程序。 “应用程序”窗口是查看特定应用程序详细信息的主入口点。右键单击应用程序节点将打开弹出式菜单，从该弹出式菜单中可以选择是打开主应用程序标签，还是生成线程 dump 或堆 dump。 有关如何使用“应用程序”窗口查看和保存应用程序相关数据的更多详细信息，请参见以下页面： Using the Applications Window（使用“应用程序”窗口） 浏览堆 DumpVisualVM 有一个可视化窗口，通过该窗口可以轻松浏览堆 dump。您可以装入现有堆 dump，或为本地运行的应用程序生成堆快照。 要生成本地应用程序的堆 dump，可以执行下列任一操作： 在“应用程序”窗口中右键单击应用程序节点，然后选择“堆 Dump”。 在“应用程序”窗口中双击应用程序节点以打开应用程序标签，然后在“监视”标签中单击“堆 Dump”。 要打开保存的堆 dump，请从主菜单中选择“文件”&gt;“装入”，然后找到保存的堆 dump。 浏览打开的堆 dump： 单击“堆 Dump”工具栏中的“类”，以查看活动类和对应实例的列表。 双击某个类名打开“实例”视图，以查看实例列表。 从列表中选择某个实例，以查看对该实例的引用。 在生成堆 dump 后，VisualVM 将在新标签中打开该堆 dump，并在“应用程序”窗口中的应用程序节点下为该堆 dump 创建一个节点。要保存生成的堆 dump，请右键单击该堆 dump 节点，然后选择“另存为”。如果没有明确保存生成的堆 dump，则在应用程序关闭时将删除该 dump。 有关更多信息，请参见以下文档： Browsing a Heap Dump（浏览堆 Dump） 对应用程序进行性能分析VisualVM 包括一个 Profiler，可以使用它对本地 JVM 上运行的应用程序进行性能分析。您可以在应用程序标签的 “Profiler” 标签中访问性能分析控件。通过该 Profiler，可以分析本地应用程序的内存使用情况和 CPU 性能。 注意：要对 JDK 6 上运行的应用程序进行性能分析，需要关闭该应用程序的类共享，否则该应用程序可能会崩溃。要关闭类共享，请使用 -Xshare:off 参数启动应用程序。 启动本地 Java 应用程序。（使用 -Xshare:off 参数启动该应用程序。） 在“应用程序”窗口的“本地”节点下，右键单击该应用程序节点，然后选择“打开”以打开该应用程序标签。 在该应用程序标签中单击 “Profiler” 标签。 在 “Profiler” 标签中单击“内存”或 “CPU”。 在选择性能分析任务后，VisualVM 将在 “Profiler” 标签中显示性能分析数据。 有关使用 VisualVM 进行性能分析的更多信息，请参见以下文档： 对应用程序进行性能分析 连接到远程主机通过 VisualVM，可以轻松监视远程主机上运行的应用程序，并查看有关远程系统的常规数据。要查看远程主机上应用程序的相关信息，必须首先连接到远程主机。已连接的远程主机将列在“应用程序”窗口的“远程”节点下。展开远程主机节点可查看远程主机上运行的应用程序。 要从远程应用程序中检索数据，需要在远程 JVM 上运行 jstatd 实用程序。有关如何启动 jstatd 的更多信息 请参见 jstatd - Virtual Machine jstat Daemon（jstatd - 虚拟机 jstat 守护进程）。无法对远程主机上运行的应用程序进行性能分析。 右键单击“应用程序”窗口中的“远程”节点，然后选择“添加远程主机”。 在“添加远程主机”对话框中，键入远程计算机的主机名或 IP 地址。 （可选）键入远程主机的显示名称。此名称将显示在“应用程序”窗口中。如果没有输入显示名称，则在“应用程序”窗口中使用主机名标识远程主机。 单击“确定”。 单击“确定”后，将在“远程”节点下显示远程主机的节点。展开远程主机节点可查看远程主机上运行的 Java 应用程序。 您可以双击远程应用程序的名称，在 VisualVM 中打开该应用程序标签。 有关更多信息，请参见以下文档： Working with Remote Applications（使用远程应用程序） 安装 VisualVM 插件通过安装 VisualVM 更新中心提供的插件，可以向 VisualVM 添加功能。例如，安装 VisualVM-MBeans 插件可以向应用程序标签中添加 “MBeans” 标签，通过此标签，可以在 VisualVM 内监视和管理 MBeans。 安装 VisualVM 插件： 从主菜单中选择“工具”&gt;“插件”。 在“可用插件”标签中，选中该插件的“安装”复选框。单击“安装”。 逐步完成插件安装程序。 该屏幕快照显示了选中 VisualVM-MBeans 插件的“插件”管理器。 原文地址：https://visualvm.github.io/gettingstarted.html","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"JvisualVM","slug":"JvisualVM","permalink":"http://qinjiangbo.com/tags/JvisualVM/"},{"name":"JDK","slug":"JDK","permalink":"http://qinjiangbo.com/tags/JDK/"}]},{"title":"JDK9将JvisualVM工具移除","slug":"jvisualvm-tool-was-removed-from-jdk9","date":"2018-03-26T06:40:03.000Z","updated":"2018-03-26T11:15:44.000Z","comments":true,"path":"jvisualvm-tool-was-removed-from-jdk9.html","link":"","permalink":"http://qinjiangbo.com/jvisualvm-tool-was-removed-from-jdk9.html","excerpt":"","text":"最新资讯从JVisualVM的官方网站可以看出，这个项目已经迁移到了Github平台上。官网英文如下： VisualVM comes in two distributions: VisualVM at GitHub and Java VisualVM as a JDK tool. VisualVM at GitHub is a bleeding-edge distribution with the latest features. To get a stable tool, use the Java VisualVM available in your Oracle JDK 8. NEW: Starting from Oracle JDK 9, Java VisualVM has moved to the GraalVM, an innovative, high-performance polyglot VM developed at Oracle Labs. See the Graal VisualVM page for details. 意思很简单，就是VisualVM现在有两个分发渠道了，分别是Github和JDK内置工具。但是最新的消息显示，从Oracle JDK 9开始，Java VisualVM已经转移到了GraalVM，这是一个创新的，高性能的多语言VM性能监控器。 安装步骤 解压下载好的目录，这个目录已经包含了visualvm的顶级目录。 通过启动下面的程序来启动VisualVM，不同的系统对应的方式不同：visualvm\\bin\\visualvm.exe或者是visualvm/bin/visualvm，你可能要提供额外的选项来定义JDK或者是VisualVM的目录：--jdkhome &quot;&lt;path to JDK&gt;&quot; --userdir &quot;&lt;path to userdir&gt;&quot;。 直接读这篇文档来查看VisualVM的使用教程。 总结VisualVM从JDK 9起被移出去我认为是不太合适的，这个工具其实是非常好用的，至少我认为比起jconsole来说它的优势体现在可视化效果好，而且功能选项多，重要是还支持插件。只不过从现在开始，JvisualVM在JDK中就成为了过去式，想使用的人只能单独下载了。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"JvisualVM","slug":"JvisualVM","permalink":"http://qinjiangbo.com/tags/JvisualVM/"},{"name":"JDK","slug":"JDK","permalink":"http://qinjiangbo.com/tags/JDK/"}]},{"title":"利用JRebel实现Tomcat热部署","slug":"hot-deployment-of-tomcat-with-JRebel-tools","date":"2018-03-19T14:38:48.000Z","updated":"2018-03-19T16:36:37.000Z","comments":true,"path":"hot-deployment-of-tomcat-with-JRebel-tools.html","link":"","permalink":"http://qinjiangbo.com/hot-deployment-of-tomcat-with-JRebel-tools.html","excerpt":"","text":"这里主要是参考了JRebel官方使用文档的内容，原文是英文http://manuals.zeroturnaround.com/jrebel/standalone/config.html#war-configuration。本文采用的是是WAR包部署的方式教程，而且是基于rebel.xml来实现的。 IDEA 工具设置需要将这个设置中的On &#39;Update&#39; action和On frame deactivation都设置为Hot Swap classes。 rebel.xml配置文件需要在resources文件夹里面创建一个rebel.xml文件。这个文件的内容如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;application xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.zeroturnaround.com\" xsi:schemaLocation=\"http://www.zeroturnaround.com http://update.zeroturnaround.com/jrebel/rebel-2_1.xsd\"&gt; &lt;classpath&gt; &lt;dir name=\"/Users/richard/Documents/Projects/IdeaProjects/AntiCrawlerSystemDashboard/target/classes\"/&gt; &lt;/classpath&gt; &lt;web&gt; &lt;link target=\"/\"&gt; &lt;dir name=\"/Users/richard/Documents/Projects/IdeaProjects/AntiCrawlerSystemDashboard/src/main/webapp\"/&gt; &lt;/link&gt; &lt;/web&gt;&lt;/application&gt; 使用JRebel启动项目在IDEA中按这两个按钮启动： 总结关于其他方式的JRebel配置就不再赘述了，关于具体的信息可以访问官网去查看相关的文献。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Docker","slug":"架构师/Docker","permalink":"http://qinjiangbo.com/categories/架构师/Docker/"}],"tags":[{"name":"Hot deployment","slug":"Hot-deployment","permalink":"http://qinjiangbo.com/tags/Hot-deployment/"},{"name":"JRebel","slug":"JRebel","permalink":"http://qinjiangbo.com/tags/JRebel/"}]},{"title":"利用Docker搭建JRebel授权服务器","slug":"build-jrebel-license-server-with-docker","date":"2018-03-19T12:45:06.000Z","updated":"2018-03-19T13:37:08.000Z","comments":true,"path":"build-jrebel-license-server-with-docker.html","link":"","permalink":"http://qinjiangbo.com/build-jrebel-license-server-with-docker.html","excerpt":"","text":"受https://gitee.com/gsls200808/JrebelLicenseServerforJava作者的启发，决定在他的基础上进行改进，并制作一个docker版本的授权服务器。目前Docker版的授权服务器已经制作完成，并放在了Docker Hub的仓库中，地址是：https://hub.docker.com/r/qinjiangbo/jrebel-server/，里面有详细的使用说明，但是今天本文还是一步一步讲一下如何使用docker来打造一个JRebel的授权服务器。 下载Docker镜像1234567891011121314151617$ docker pull qinjiangbo/jrebel-server Using default tag: latestlatest: Pulling from qinjiangbo/jrebel-server5040bd298390: Already exists fce5728aad85: Already exists 76610ec20bf5: Already exists 60170fec2151: Already exists e98f73de8f0d: Already exists 11f7af24ed9c: Already exists 2cf014724202: Already exists 4bc402a00dfe: Already exists 12083eb63e6e: Pull complete f22c128afefa: Pull complete 92d84e0aeed2: Pull complete 37d91e27dd7b: Pull complete Digest: sha256:253d0cd8892aa4e897c7766a00b1250295fef2383649bcec2a3874905341f3b3Status: Downloaded newer image for qinjiangbo/jrebel-server:latest 使用docker images查看列表得到如下结果： 12345678910docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEqinjiangbo/jrebel-server latest dbd72510c946 35 minutes ago 653MBqinjiangbo/idea-license-server latest b185c20c5886 2 months ago 120MBubuntu latest 00fd29ccc6f1 3 months ago 111MBsshd_centos latest f0560ea85754 5 months ago 221MBnginx latest 1e5ab59102ce 5 months ago 108MBgitlab/gitlab-ce latest 453d64ae84c7 5 months ago 1.28GBcentos latest 196e0ce0c9fb 6 months ago 197MBjava 8 d23bdf5b1b1b 14 months ago 643MB 我们可以看到jrebel-server的镜像ID是dbd72510c946。接下来我们就来启动容器。 启动容器12345$ docker run -d -p 8081:8081 dbd7c15ebe41bd8b089e2068c69bc1bf5f24b8003722dfdfcfbb547ba29e190d9070$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc15ebe41bd8b dbd7 \"/usr/local/sbin/r...\" 2 seconds ago Up 6 seconds 0.0.0.0:8081-&gt;8081/tcp hungry_kalam 可以看到容器启动成功了。 访问页面查看具体的激活指南访问网页http://localhost:8081/，可以看到如下页面： 总结本文并没有讲解如何使用Dockerfile来构造一个Docker镜像。对于有些想学习Dockerfile的同学，那么我还是附上本镜像的Dockerfile吧： 12345678910111213141516171819# 指定基础镜像FROM java:8# 维护者信息MAINTAINER qinjiangbo&lt;qinjiangbo1994@163.com&gt;# 加入应用到镜像中ADD JrebelLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar jrebel-server.jarADD IntelliJIDEALicenseServer.html /html/IntelliJIDEALicenseServer.html# 添加启动脚本ADD run.sh /usr/local/sbin/run.shRUN chmod 755 /usr/local/sbin/run.sh# 开放端口EXPOSE 8081# 容器启动执行脚本CMD [\"/usr/local/sbin/run.sh\"] 如果觉得不错，欢迎大家给我的镜像多多点个Star哈~","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Docker","slug":"架构师/Docker","permalink":"http://qinjiangbo.com/categories/架构师/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://qinjiangbo.com/tags/Docker/"},{"name":"JRebel License Server","slug":"JRebel-License-Server","permalink":"http://qinjiangbo.com/tags/JRebel-License-Server/"}]},{"title":"在CentOS上部署多台Tomcat服务器","slug":"deploy-multiple-tomcat-servers-in-centos-server","date":"2018-03-17T03:55:52.000Z","updated":"2018-03-17T04:20:07.000Z","comments":true,"path":"deploy-multiple-tomcat-servers-in-centos-server.html","link":"","permalink":"http://qinjiangbo.com/deploy-multiple-tomcat-servers-in-centos-server.html","excerpt":"","text":"前几天需要写一个后台服务器，本想着在同一个Web应用里面添加后台逻辑，但是要采用独立的域名。但是后来发现Nginx配置好像不支持这么做（应该我不知道而已）。所以，思考了很久决定采用一台Tomcat服务器部署两个Java Web应用，这个时候有人会说，就是应该这么做啊？的确，我就是这么做的，刚开始运行的时候还好，一旦出现Tomcat应用内部重定向请求的时候，Nginx就会把应用名拼接一下，Nginx配置如下： 123456789101112131415161718192021222324# ACS系统配置server &#123; listen 80; listen 443; ssl on; ssl_certificate /usr/local/etc/keys/chain.pem; ssl_certificate_key /usr/local/etc/keys/chain.key; server_name acs.qinjiangbo.com; access_log /var/log/nginx/access.log main; location / &#123; proxy_pass http://127.0.0.1:8080/app1/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; # 重定向non-https流量到https if ($scheme != \"https\") &#123; return 301 https://$host$request_uri; &#125;&#125; 以这个请求为例：GET https://acs.qinjiangbo.com/finance/，在APP内部是做了重定向的，通过response.sendRedirect(URL)到列表页，应该是https://acs.qinjiangbo.com/finance/list/1，但是我地址栏显示的是https://acs.qinjiangbo.com/app1/finance/list/1，找了好多解决方案都没有人遇到过这个问题，这里的话就先mark一下，如果你有解决方案的话，希望在评论区不吝赐教，非常感谢！ 好了，这就到了本文的问题了，我后面呢打算使用两台Tomcat服务器，分别跑前台和后台业务，因此，我把/usr/local/tomcat/复制了一份，命名为/usr/local/tomcat2/。但是这个时候如果直接启动两台服务器的话会出现非常多的端口冲突，因此需要先解决端口冲突才能启动成功。直接编辑/usr/local/tomcat2/conf/server.xml文件即可，将里面的每个端口往上加一： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;!-- 注意这里需要将8005更改为8006 --&gt;&lt;Server port=\"8006\" shutdown=\"SHUTDOWN\"&gt; &lt;Listener className=\"org.apache.catalina.startup.VersionLoggerListener\" /&gt; &lt;!-- Security listener. Documentation at /docs/config/listeners.html &lt;Listener className=\"org.apache.catalina.security.SecurityListener\" /&gt; --&gt; &lt;!--APR library loader. Documentation at /docs/apr.html --&gt; &lt;Listener className=\"org.apache.catalina.core.AprLifecycleListener\" SSLEngine=\"on\" /&gt; &lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt; &lt;Listener className=\"org.apache.catalina.core.JreMemoryLeakPreventionListener\" /&gt; &lt;Listener className=\"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\" /&gt; &lt;Listener className=\"org.apache.catalina.core.ThreadLocalLeakPreventionListener\" /&gt; &lt;!-- Global JNDI resources Documentation at /docs/jndi-resources-howto.html --&gt; &lt;GlobalNamingResources&gt; &lt;!-- Editable user database that can also be used by UserDatabaseRealm to authenticate users --&gt; &lt;Resource name=\"UserDatabase\" auth=\"Container\" type=\"org.apache.catalina.UserDatabase\" description=\"User database that can be updated and saved\" factory=\"org.apache.catalina.users.MemoryUserDatabaseFactory\" pathname=\"conf/tomcat-users.xml\" /&gt; &lt;/GlobalNamingResources&gt; &lt;!-- A \"Service\" is a collection of one or more \"Connectors\" that share a single \"Container\" Note: A \"Service\" is not itself a \"Container\", so you may not define subcomponents such as \"Valves\" at this level. Documentation at /docs/config/service.html --&gt; &lt;Service name=\"Catalina\"&gt; &lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt; &lt;!-- &lt;Executor name=\"tomcatThreadPool\" namePrefix=\"catalina-exec-\" maxThreads=\"150\" minSpareThreads=\"4\"/&gt; --&gt; &lt;!-- A \"Connector\" represents an endpoint by which requests are received and responses are returned. Documentation at : Java HTTP Connector: /docs/config/http.html Java AJP Connector: /docs/config/ajp.html APR (HTTP/AJP) Connector: /docs/apr.html Define a non-SSL/TLS HTTP/1.1 Connector on port 8080 --&gt; &lt;!-- 这里需要将8080更改为8081 --&gt; &lt;Connector port=\"8081\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; &lt;!-- A \"Connector\" using the shared thread pool--&gt; &lt;!-- &lt;Connector executor=\"tomcatThreadPool\" port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; --&gt; &lt;!-- Define a SSL/TLS HTTP/1.1 Connector on port 8443 This connector uses the NIO implementation. The default SSLImplementation will depend on the presence of the APR/native library and the useOpenSSL attribute of the AprLifecycleListener. Either JSSE or OpenSSL style configuration may be used regardless of the SSLImplementation selected. JSSE style configuration is used below. --&gt; &lt;!-- &lt;Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" maxThreads=\"150\" SSLEnabled=\"true\"&gt; &lt;SSLHostConfig&gt; &lt;Certificate certificateKeystoreFile=\"conf/localhost-rsa.jks\" type=\"RSA\" /&gt; &lt;/SSLHostConfig&gt; &lt;/Connector&gt; --&gt; &lt;!-- Define a SSL/TLS HTTP/1.1 Connector on port 8443 with HTTP/2 This connector uses the APR/native implementation which always uses OpenSSL for TLS. Either JSSE or OpenSSL style configuration may be used. OpenSSL style configuration is used below. --&gt; &lt;!-- &lt;Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11AprProtocol\" maxThreads=\"150\" SSLEnabled=\"true\" &gt; &lt;UpgradeProtocol className=\"org.apache.coyote.http2.Http2Protocol\" /&gt; &lt;SSLHostConfig&gt; &lt;Certificate certificateKeyFile=\"conf/localhost-rsa-key.pem\" certificateFile=\"conf/localhost-rsa-cert.pem\" certificateChainFile=\"conf/localhost-rsa-chain.pem\" type=\"RSA\" /&gt; &lt;/SSLHostConfig&gt; &lt;/Connector&gt; --&gt; &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt; &lt;!-- 这里需要将8009更改为8010 --&gt; &lt;Connector port=\"8010\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt; &lt;!-- An Engine represents the entry point (within Catalina) that processes every request. The Engine implementation for Tomcat stand alone analyzes the HTTP headers included with the request, and passes them on to the appropriate Host (virtual host). Documentation at /docs/config/engine.html --&gt; &lt;!-- You should set jvmRoute to support load-balancing via AJP ie : &lt;Engine name=\"Catalina\" defaultHost=\"localhost\" jvmRoute=\"jvm1\"&gt; --&gt; &lt;Engine name=\"Catalina\" defaultHost=\"localhost\"&gt; &lt;!--For clustering, please take a look at documentation at: /docs/cluster-howto.html (simple how to) /docs/config/cluster.html (reference documentation) --&gt; &lt;!-- &lt;Cluster className=\"org.apache.catalina.ha.tcp.SimpleTcpCluster\"/&gt; --&gt; &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords via a brute-force attack --&gt; &lt;Realm className=\"org.apache.catalina.realm.LockOutRealm\"&gt; &lt;!-- This Realm uses the UserDatabase configured in the global JNDI resources under the key \"UserDatabase\". Any edits that are performed against this UserDatabase are immediately available for use by the Realm. --&gt; &lt;Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\" resourceName=\"UserDatabase\"/&gt; &lt;/Realm&gt; &lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; &lt;!-- SingleSignOn valve, share authentication between web applications Documentation at: /docs/config/valve.html --&gt; &lt;!-- &lt;Valve className=\"org.apache.catalina.authenticator.SingleSignOn\" /&gt; --&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html Note: The pattern used is equivalent to using pattern=\"common\" --&gt; &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"localhost_access_log\" suffix=\".txt\" pattern=\"%h %l %u %t &amp;quot;%r&amp;quot; %s %b\" /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 至于网上说的更改环境变量依据实际情况去修改啦，因为我是直接通过shell脚本启动的，就是/usr/local/tomcat/bin/startup.sh，因此不需要关心环境变量是什么，它自己就会指定。 总结关于CentOS部署多台Tomcat服务器的Nginx配置就不再赘述了，和上面的非常像，对照着修改就行了。但是一定要注意区分端口，否则系统起不来的。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://qinjiangbo.com/tags/CentOS/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://qinjiangbo.com/tags/Tomcat/"}]},{"title":"重新播放CSS动画","slug":"restart-css-animation","date":"2018-03-16T13:19:40.000Z","updated":"2018-03-16T13:59:46.000Z","comments":true,"path":"restart-css-animation.html","link":"","permalink":"http://qinjiangbo.com/restart-css-animation.html","excerpt":"","text":"对于做前端动画的同学来说，动画库Animate.css并不陌生。我们往往希望一个动画能够重复播放，首先以一个简单的动画shake为例： 12345678910111213141516171819202122232425262728293031.animated &#123; -webkit-animation-duration: 1s; animation-duration: 1s; -webkit-animation-fill-mode: both; animation-fill-mode: both;&#125;@-webkit-keyframes shake &#123; from, to &#123; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); &#125; 10%, 30%, 50%, 70%, 90% &#123; -webkit-transform: translate3d(-10px, 0, 0); transform: translate3d(-10px, 0, 0); &#125; 20%, 40%, 60%, 80% &#123; -webkit-transform: translate3d(10px, 0, 0); transform: translate3d(10px, 0, 0); &#125;&#125; 我们通过调整CSS来使某一个元素左右抖动起来，比如div#banner框，如下： 123&lt;div id=\"banner\" class=\"banner\"&gt;Hello Banner!&lt;/div&gt; 可以按照如下方式来添加CSS类 1$(\"#banner\").addClass(\"animated shake\"); 这个时候其实这个元素的CSS类就变化为了banner animated shake这三个css类了，所以再次执行这个函数是没有动画产生的。 那么你可能会想，为什么不通过删除CSS类，然后重新添加来实现呢？试一下： 12// won't work at all$(\"#banner\").removeClass(\"animated shake\").addClass(\"animated shake\"); 是的，完全不会奏效。因为添加操作和删除操作的时间间隔太短了，其实中间可以加一个很小的时间间隔都可以的，但是我们还有更优秀的实现方式，通过从文档树中移除这个元素并重新添加回来而达到这个效果，具体逻辑如下： 1234var temp = $(\"#banner\").clone(true);// 注意当前元素要放在克隆元素的后面，因为后面使用了`:last`选择器$(\"#banner\").after(temp);$(\"#banner:last\").remove(); 博主在自己的登录页面使用这个效果，当用户输错用户名和密码的时候就会摇头： 参考文章：https://css-tricks.com/restart-css-animation/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"前端","slug":"开发技术/前端","permalink":"http://qinjiangbo.com/categories/开发技术/前端/"}],"tags":[{"name":"Animate.css","slug":"Animate-css","permalink":"http://qinjiangbo.com/tags/Animate-css/"},{"name":"重新播放","slug":"重新播放","permalink":"http://qinjiangbo.com/tags/重新播放/"}]},{"title":"IDEA修复文件的显示类型","slug":"repair-file-types-in-IDEA","date":"2018-03-16T03:10:47.000Z","updated":"2018-03-16T03:25:21.000Z","comments":true,"path":"repair-file-types-in-IDEA.html","link":"","permalink":"http://qinjiangbo.com/repair-file-types-in-IDEA.html","excerpt":"","text":"今天碰到一个非常头疼的问题，就是一个Freemarker文件(*.ftl)一直被IDEA显示为普通文本文件(text)，也无法进行编辑。如下图所示： 可以看到，文件名为dashboard.ftl的文件一直被解析为纯文本，究其原因，应该是我们在创建文件的时候选择了一个错误的文件打开方式造成的。解决的方案也非常简单，如下图： 删掉这个text选项中已经注册类型的这个文件名即可。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://qinjiangbo.com/tags/IDEA/"},{"name":"文件类型","slug":"文件类型","permalink":"http://qinjiangbo.com/tags/文件类型/"}]},{"title":"MySQL分页技巧","slug":"pagination-tricks-of-mysql","date":"2018-03-13T03:32:59.000Z","updated":"2018-03-17T03:25:08.000Z","comments":true,"path":"pagination-tricks-of-mysql.html","link":"","permalink":"http://qinjiangbo.com/pagination-tricks-of-mysql.html","excerpt":"","text":"最近需要为毕设的资讯系统添加一个类目下的文章列表的功能，需要从MySQL数据库取数据，第一时间想到了使用limit。没错，limit是MySQL为我们提供的一个好工具，但是limit如果使用不当也会造成数据读取速度非常慢。 使用limit m语句最常见的写法就是 1SELECT * FROM table_A limit m; 当时这个数据是取出前m行数据，很显然随着m的增大，时间也会逐渐增加，是一个正相关的关系，很显然我们还要使用分页，因此这种方案不被采纳。 使用limit m,n语句这种方式和上述的方式比较有点不太一样了，LIMIT后面多了两个参数，m在这里表示从哪里开始取出数据，n表示取出多少行数据。大家可能会想，这种方式太棒了，正好符合分页的特征，但是我们看一下这个语句： 12SELECT * FROM table_A limit 10, 10;SELECT * FROM table_A limit 10000, 10; 很显然，的确都能够取出相关的数据，但是这种方式的弊端也很明显，就是当m非常大的时候，整个SQL语句的性能会急剧下降。前一条语句执行通常可能只需要0.001秒，而后面这条语句可能需要执行10秒，相隔几个数量级了。因为后面需要先扫描10000+10条数据，然后再抛弃前面的10000条数据，这个过程非常耗时。 复合索引其实这里我提出了另一种解决的办法就是复合索引，如果需要使用WHERE语句和ORDER语句的话，我们可以知道无论LIMIT后面接的是什么数，都是需要等ORDER语句排序先执行完，然后才能开始进行切分。 和上一节一样，也是用limit m,n格式，比如下面这个查询： 1234SELECT title, url, SUBSTRING(content, 1, 150) as content FROM acs_postWHERE category = \"news\"ORDER BY pub_date DESCLIMIT 10000, 10; 通过EXPLAIN查询它的执行计划时我们可以得到一下信息： 123456789101112131415mysql&gt; EXPLAIN SELECT title, url, SUBSTRING(content, 1, 150) as content FROM acs_post WHERE category = \"news\" ORDER BY pub_date DESC LIMIT 10000, 10 \\G;*************************** 1. row *************************** id: 1 select_type: SIMPLE table: acs_post partitions: NULL type: refpossible_keys: category_index key: category_index key_len: 62 ref: const rows: 38964 filtered: 100.00 Extra: Using index condition; Using filesort1 row in set, 1 warning (0.01 sec) 可以看到，虽然使用单一的category_index索引，但是在Extra列还是出现了Using filesort文件排序的信息，说明这个SQL执行的效果很差。如果我们添加了comp_index(category, pub_date)索引之后，效果会有所不同，同样的SQL执行计划就不同了。 123456789101112131415mysql&gt; EXPLAIN SELECT title, url, SUBSTRING(content, 1, 150) as content FROM acs_post WHERE category = \"news\" ORDER BY pub_date DESC LIMIT 10000, 10 \\G;*************************** 1. row *************************** id: 1 select_type: SIMPLE table: acs_post partitions: NULL type: refpossible_keys: category_index,comp_index key: comp_index key_len: 62 ref: const rows: 38964 filtered: 100.00 Extra: Using where1 row in set, 1 warning (0.00 sec) 这次在Extra列没有了Using filesort文件排序信息了，另一个可以看到执行时间，上一条的执行时间是0.01sec，而这一次的执行时间是0.00sec。 使用where+limit m语句这种方式通常是有一个顺序ID列的，比如： 1SELECT * FROM acs_post WHERE id &gt; 10000 LIMIT 10; 这个时候查找的行数就只有10条了，速度非常快，但是缺点就是一旦其中某一些行数被删除了，结果可能会不准确，因此需要建立一个表来维护这个ID列的信息，不管数据的插入还是删除都需要在这个表上同步一下，以后查询的时候直接从这个表取数据会非常快。 总结优化LIMIT慢SQL的方式有很多，但是要依据自己的实际业务情况进行选择。通常首先做的事情就是检查相关的列有没有进行索引优化。如果没有的话，需要先进行索引优化。这样才能有效提升整体的性能。否则慢SQL可能会使你的系统直接崩掉。","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"MySQL","slug":"数据科学/MySQL","permalink":"http://qinjiangbo.com/categories/数据科学/MySQL/"}],"tags":[{"name":"导入数据","slug":"导入数据","permalink":"http://qinjiangbo.com/tags/导入数据/"},{"name":"分页","slug":"分页","permalink":"http://qinjiangbo.com/tags/分页/"}]},{"title":"摄影作品版权水印制作","slug":"make-copyright-watermarker-for-photos","date":"2018-02-01T16:28:18.000Z","updated":"2018-02-01T16:57:12.000Z","comments":true,"path":"make-copyright-watermarker-for-photos.html","link":"","permalink":"http://qinjiangbo.com/make-copyright-watermarker-for-photos.html","excerpt":"","text":"谈到摄影作品的版权问题，大家可能会想到很多很炫酷的水印。的确，水印这个东西很神奇，因为合适的水印能显著增加作品的逼格，甚至会和作品相辅相成，互相补充。 那么，这篇文章主要是介绍如何使用Photoshop制作我们自己的摄影作品的水印 。主要分为以下几个步骤： 制作水印打开Photoshop，根据你平时拍摄照片的分辨率设置相应的大小，比如笔者的就是6000*4000。因此，我创建的水印大小为4500*630。然后编辑水印上的文字，我的是© PHOTO BY RICHARD QIN，如下： 嵌入水印还是打开我家妞妞处理之后的美照，嵌入上面的水印之后如下，我制作的还有白色的版本，这次嵌入白色的版本： 保存作品将作品按照前一篇博客说明的“另存为(Save As…)”JPG格式就好了。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"摄影","slug":"经验感悟/摄影","permalink":"http://qinjiangbo.com/categories/经验感悟/摄影/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"http://qinjiangbo.com/tags/摄影/"},{"name":"水印","slug":"水印","permalink":"http://qinjiangbo.com/tags/水印/"},{"name":"版权","slug":"版权","permalink":"http://qinjiangbo.com/tags/版权/"}]},{"title":"照片后期处理保存EXIF且无压缩","slug":"processing-photos-with-exif-information-and-without-compression","date":"2018-02-01T15:13:32.000Z","updated":"2018-02-01T17:02:14.000Z","comments":true,"path":"processing-photos-with-exif-information-and-without-compression.html","link":"","permalink":"http://qinjiangbo.com/processing-photos-with-exif-information-and-without-compression.html","excerpt":"","text":"本文主要记录在使用Photoshop进行照片的后期处理时，如何保存照片的原始EXIF信息以及如何以原图的大小进行保存，不进行压缩。 注意：下图有两张超过9M的图片，使用手机流量者请谨慎继续浏览。 保存原始EXIF信息以我家的妞妞的美图为例，原始图片如下： 可以右键查看原始图片的信息，如下图： 查看这张图我们可以看到图片整体偏暗，而且对比度不是很强，因此我们决定使用Photoshop来进行简单地调整。步骤如下： 使用Photoshop打开图片选中原始图层，然后按住command+J就可以新建拷贝的图层，以后的调整都是基于拷贝的图层来进行的。 新建调整的图层在图层菜单栏，选择新建调整的图层，如下： 调整亮度和对比度在右侧的区域里面根据照片的状态来动态地调整亮度和对比度，直到满意为止。 “另存为”而不是“导出为”保存这张照片的时候需要注意是“另存为(Save As…)”而不是“导出为(Export As…)”。只有另存为才会保存照片的exif信息，而导出为则不会保存。 不压缩图片“另存为”的时候需要注意一个选项就是保存图片的质量，为了保证和原图一致，请大家将图片质量调整到最高，一般来说这个值为12。这样另存为的图片就不会被压缩为1-2M。 总结先放出后期处理后的妞妞美照，如下： 查看照片的exif信息，如下： 可以看到，照片的EXIF信息比没有丢失，而且照片的大小也没有被压缩。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"摄影","slug":"经验感悟/摄影","permalink":"http://qinjiangbo.com/categories/经验感悟/摄影/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"http://qinjiangbo.com/tags/摄影/"},{"name":"Photoshop","slug":"Photoshop","permalink":"http://qinjiangbo.com/tags/Photoshop/"},{"name":"后期","slug":"后期","permalink":"http://qinjiangbo.com/tags/后期/"}]},{"title":"解决Mac电脑Wifi共享失败的问题","slug":"fix-macbook-pro-wifi-sharing-failure-issues","date":"2018-01-23T01:39:38.000Z","updated":"2018-01-30T13:48:01.000Z","comments":true,"path":"fix-macbook-pro-wifi-sharing-failure-issues.html","link":"","permalink":"http://qinjiangbo.com/fix-macbook-pro-wifi-sharing-failure-issues.html","excerpt":"","text":"这几天被Mac电脑的Wifi共享恶心到了，电脑上开了Wifi热点以后，手机上连接一直提示密码错误或者是无法加入该网络。找了一些文章，发现有一篇还比较靠谱，链接地址如下：http://osxdaily.com/2016/09/22/fix-wi-fi-problems-macos-sierra/，文中提供的一种方法完美地解决了我的问题。现在给大家分享一下： Step 1. 退出任何正在使用Wifi或者使用网络的应用，比如说Safari，QQ，Chrome等等；Step 2. 关闭Wifi，在顶部栏选中Wifi图标，点击关闭Wifi即可；Step 3. 打开Finder，按Command+Shift+G快捷键打开跳转到某个文件夹的工具界面；Step 4. 输入这个地址/Library/Preferences/SystemConfiguration/并且按回车；Step 5. 在SystemConfiguration文件夹定位并选择下面这几个文件； 12345com.apple.airport.preferences.plistcom.apple.network.eapolclient.configuration.plistcom.apple.wifi.message-tracer.plistNetworkInterfaces.plistpreferences.plist Step 6. 先把这几个文件拷贝到桌面做一个备份，然后删掉它们；Step 7. 重启电脑，打开Wifi，重新进行热点的创建就可以了。 更新一下 2018.01.30最近发现这个故障的原因是学校的校园网崩了，因为室友的Wifi也连不上，而回到家就能连上了。校园网之前一直都是好的，大家也都没有问题，而现在大家都有这个问题，因此据此判定为校园网的锅。不过上述的方法对大多数同学的情况是适用的，可以很大程度上解决你的问题。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"http://qinjiangbo.com/tags/MacOS/"},{"name":"Wifi共享","slug":"Wifi共享","permalink":"http://qinjiangbo.com/tags/Wifi共享/"}]},{"title":"窘境时刻如何作抉择","slug":"how-to-make-decisions-in-dilemma","date":"2018-01-16T11:12:39.000Z","updated":"2018-01-20T07:09:34.000Z","comments":true,"path":"how-to-make-decisions-in-dilemma.html","link":"","permalink":"http://qinjiangbo.com/how-to-make-decisions-in-dilemma.html","excerpt":"","text":"其实这篇文章最开始的想法是想将我最近经历的一些事情所思考的感悟记录下来，后面配了这张图以后觉得也可以写一写选择的话题。不过首先还是讲述我自己的亲身经验感悟吧。 尴尬时刻如何抉择尴尬的时刻想必每个人都曾经历过，比如公共场合下被某个人羞辱了一番，这个就会很尴尬。那么，到底什么是尴尬？维基百科中给出的定义如下： 尴尬是人的一种情绪，是人对于表达自己的情感时感到不安。在社交场合上做一些行为时感到难为情而被他人目击或揭露。在多数情况下，感到尴尬的人丧失了一些荣誉及尊严。这种情感和羞耻相似，差别在于羞耻可以在个人情况下出现（而不需受他人见证）。而尴尬的行为多数源自社会的不接受，而非道德上的错误。 其实简单的来说就是丢了面子。有的人好面子，有的人不好面子，取决于这个人的性格特征以及事件发生的场合。对于一个二十多岁的年轻人来说丢了面子其实是比较重要的一件事情，因为这个年龄层的人自尊心比较强，还没有被社会打磨掉。说说我的个人经历吧。 不久前的某一天，我和寝室的同学一起出去看电影。先去吃了饭，吃完饭之后发现还有一个半小时电影才开始，怎么办呢？于是A君邀请我们去打台球，不好意思让他全部出了，所以我提议AA制。由于M君不是很会打，所以他就没有打，然后我就和A君两人去打了，他在一旁观战。客观地说，A君打台球还是很不错的，因此每一局基本上都是他胜我，除了有一局我状态不佳被他领先5个球结束之外，其余的基本上就是看谁打进黑球的区别了。从开始打球到结束M君在一旁各种嘲讽，虽然我觉得是无意的，但是还是感到很尴尬。A君一开始也嘲讽啥的，比如说我进球都是运气啥的，但是后面似乎注意到了这样会让别人不悦，所以就停止了。打球结束以后，M君又惯常的一句嘲讽彻底让我不能接受了，于是我怒怼了他一句。好了，经历分享到到这里结束，具体后面的就不说了。下面我来说说我在这个情景里面的反应以及自己事后做出的一些反思。 在台球馆里面打台球其实如果一些很容易进的球如果因为技术失误而没有进的时候会很容易感到羞愧，觉得丢了面子，这就是很尴尬了。其实自己内心处于自我保护，就已经感到有点不愉悦了，如果这个时候别人再来刺激你，很容易矛盾就会转移了。这个是本能反应，不论是谁，不管刺激你的人是谁，都会本能地将矛盾转移到这个人身上，只是不凑巧刚好是M君刺激了我。那么，回过头来，是否自己最后怒怼回去这个行为是合理的呢？ 我认为不同的人有不同的想法，事后我回顾这个事件本身来看，其实是我的反应是不对的，值得反思。我觉得，尴尬情况下，人本能地会保护自己，别人刺激你的话就很容易转变为愤怒。本来自己可以内化的事情变成了外化了，更进一步让别人觉得你是一个输不起的人。其实这不是我们的本意，因此最佳的抉择就是选择控制自己的情绪，不要与别人争执。另外，自己做的不足的地方还是需要多多改进，让别人无话可说才是上上策。 这个答案看似有点圣母婊，但是实际上确实是非常受用的，因为一方面不仅能反映出你的涵养和修为，另一方面能有效减少和别人的冲突，自己也少一些烦恼。当然了，也还有种情况，就是看这个人对你是否重要。如果无足轻重，这样一个人居然还来中伤你，刺激你，我觉得可以和他干一仗都没关系的，不能太忍气吞声了，让别人觉得你好欺负。 另外还有一个不错的应对方案就是自嘲，这是我在A君身上发现的人生哲学。遇到一些比较尴尬的时刻，A君很多时候选择对自己开刀。这样别人就会对你的尴尬事情其实没那么难接受了，也就不会再过度地去提及这个事情，只会相视一笑。自嘲往往要自然，半开玩笑，不然别人还以为是检讨大会呢！生活中很多时候会跟A君学习到这一点，这种缓解尴尬的方式其实是比较有智慧的。 另外从M君的角度和A君的角度来说我们也能得到一些启示，就是A君其实一开始也和M君一样存在嘲讽的现象，虽然并不是有心的，因为都是好哥们儿，但是被嘲讽的人心里会感到不舒服这个是事实。但是他们俩的反应截然不同，知道我可能会有点不悦以后A君马上停止了嘲讽，态度一下子缓和许多，更多地是鼓励和称赞，这样的话其实别人都懂，都是能感受到你的善意的，我平时也会这么做，只不过这次我是善意的接受者而不是善意的赠予者。反观M君，应该是根本就没有意识到这个情况，所以导致最后矛盾转移到了自己头上还觉得莫名其妙。所以，给我们的一个启示就是要善于察言观色，不要让一个感到尴尬的人的尴尬被再次放大，不要引火上身，否则会伤到自己。 选择困难如何抉择谈论过很多关于选择的话题，如果选择出现了困难怎么做？我的想法就是全面衡量，综合考虑。啥意思呢？首先对出现选择困难的情形进行分析，看出现选择困难的对象是什么？然后再考虑影响你做这个决策的因素是哪些？能导致你出现选择困难的因素往往都不止一种，而是多方的。那么，针对一个对象的选择就很容易转化为了针对多个子问题的决策。这个和机器学习算法里面的决策树比较像，通过多种特征来进行筛选和判别，其中每个特征又有自己的权值。这里我们称之为优先级。 仔细思考一下，决策树每次进行筛选的时候都是选择信息增益最大的特征，而我们每一次评估影响因子的时候都要选择对我们最有益的方向。以出国留学为例，每个同学出国或者不出国的理由都不尽相同，因此也有同学纠结到底要不要出国，其实这个选择困难问题的对象就是出国。影响出国的因子有哪些呢？学费，生活费，能否顺利毕业，毕业以后工资水平，国内发展和国外发展前景，语言问题，恋爱问题，父母年龄问题等等。我不能说这里的哪个因素最重要，因为每个人的情况是不同的，你必须要针对自己的问题进行分析，把一切可能影响你决策的因素罗列出来进行分析，然后每一个进行思考并且标注一个优先级，如此反复几遍。最后相信你能够做出对自己最有益的决策。 总结不管是尴尬时候的处境还是选择困难时候的处境，我们似乎很容易陷入两难的境地，这个时候就需要我们结合自己的实际情况选择对应的措施。尴尬的时候还是应该尽量克制自己情绪，其实控制情绪是一门非常重要的学问。面对选择困难的时候要从容地分析各个可能影响决策的因素，然后各个击破。不管怎么说，我自己通过生活这门课学习到了很多东西，冷静思考以及及时总结吧！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"窘境","slug":"窘境","permalink":"http://qinjiangbo.com/tags/窘境/"},{"name":"尴尬","slug":"尴尬","permalink":"http://qinjiangbo.com/tags/尴尬/"},{"name":"抉择","slug":"抉择","permalink":"http://qinjiangbo.com/tags/抉择/"}]},{"title":"Xcode部署应用到真机测试","slug":"using-xcode-deploy-applications-to-real-devices-for-testing","date":"2018-01-07T07:38:37.000Z","updated":"2018-01-13T15:16:29.000Z","comments":true,"path":"using-xcode-deploy-applications-to-real-devices-for-testing.html","link":"","permalink":"http://qinjiangbo.com/using-xcode-deploy-applications-to-real-devices-for-testing.html","excerpt":"","text":"其实对于IOS开发我只能属于入门级别，不对，是入门-级别。因此，对于如何将写好的应用部署到真机上进行测试确实是一脸懵逼，不知道怎么操作，对于一些证书的处理也不知道应该怎么做，本文今天借最近比较火的跳一跳小游戏作弊玩法的机会，着重介绍如何部署应用到真机上，小游戏只是后面的一个消遣啦。注意：虽然这里是介绍如何部署WebDriverAgent应用到真机上，但是本文的介绍的方法是通用的，针对所有应用！ 下载WebDriverAgent应用这个项目是Facebook在Github上开源的一个应用，主要用于IOS端的测试。由于是要对小游戏进行作弊破解，因此这个工具还是很有必要的。地址是：https://github.com/facebook/WebDriverAgent。把整个项目克隆或者下载到本地。下载以后打开文件夹如下： 1234567$ WebDriverAgent-master lsCONTRIBUTING.md LICENSE WebDriverAgent.xcodeprojCartfile PATENTS WebDriverAgentLibCartfile.resolved PrivateHeaders WebDriverAgentRunnerCarthage README.md WebDriverAgentTestsConfigurations ResourcesInspector Scripts 这个时候如果我们直接按照Facebook的提示去执行./Scripts/bootstrap.sh，就会失败，它会提示说我们是不是还没有在/usr/local/bin/下安装Carthage。因此，在此之前我们先要安装Carthage引用，使用Homebrew安装比较好。 1$ brew install carthage 然后再执行./Scripts/bootstrap.sh，如下： 123456789101112131415161718192021222324252627$ WebDriverAgent-master ./Scripts/bootstrap.shFetching dependenciesBuilding InspectorCreating bundle directory...Fetching Inspector dependencies...npm WARN react-dom@15.6.2 requires a peer of react@^15.6.2 but none was installed.npm WARN web-driver-inspector@1.0.0 No repository field.up to date in 3.148sValidating InspectorLaunching Flow server for /Users/richard/Downloads/WebDriverAgent-master/InspectorSpawned flow server (pid=3281)Logs will go to /private/tmp/flow/zSUserszSrichardzSDownloadszSWebDriverAgent-masterzSInspector.logNo errors!Building Inspector...&gt; web-driver-inspector@1.0.0 build /Users/richard/Downloads/WebDriverAgent-master/Inspector&gt; webpack --progress --colorsHash: 8cac1428c00de3caad87 Version: webpack 1.15.0Time: 2141ms Asset Size Chunks Chunk Namesinspector.js 859 kB 0 [emitted] main [0] multi main 28 bytes &#123;0&#125; [built] + 226 hidden modulesDone 接着我们就可以使用Xcode打开这个项目了。点击下图中的WebDriverAgent.xcodeproj文件即可： 设置证书使用Xcode打开项目以后是这个样子的： 在运行之前，我们需要设置好证书，不然无法在真机上调试，目前有两种模式的证书，一种是直接到苹果开发者官网购买证书，一年99刀。博主比较穷，所以就选择免费的个人证书啦。关于个人证书如何生成？见下图： 不过你得先登录你的iCloud账户才能开始添加，这一步完成以后我们就可以开始设置整个项目的证书啦： 红框框的顺序是从左往右，从上往下。我这里是将中间那个Targets列表每一个都设置了证书，而且还需要注意的是，我们由于是免费证书，因此需要更改这个BundleID，如最右边第二个我们就改为了com.qinjiangbo，保证唯一性就可以了，不然Signing这个模块不会成功的。至于Signing这个选项我们所有的都默认为Automatically manage signing自动管理签名。 这里附一张IntegrationTests_1这个Target的BundleID修改方式，IntegrationTests_2及后面的两个都是一样的方式： 只要不是Facebook默认的那个就行了。最好是选择我们自己的域名的反写，这样肯定是唯一的。 编译运行项目Xcode请求签名输入密码当我们点击左边的运行按钮的时候，在编译的过程中可能会弹出这个框框： 这里是说项目需要访问我们的系统的KeyChain，即使密码输入正确，它也会弹很多次，这里我们在输入密码后，只需点击Always Allow就好了。如果不小心点击了Deny，那么项目将会一直编译失败，而且是Unknown Error，这个时候，我们需要手动地将KeyChain中的记录删除： 选中证书直接右击鼠标，点击删除就可以了。然后重新编译就会再次弹出这个框框了，按照上面输入正确的密码后点击Always Allow就好了。 选择设备和Target如下图： 然后点击菜单栏中的Product-&gt;Test就可以编译执行了。 可能的问题比如提示说我iPhone的版本为11.2.1 (15C153)不被当前版本的Xcode支持，但是我们又不想升级Xcode的，如何做呢？是需要添加一个11.2版本的IOS SDK就可以了。具体下载地址如下：https://pan.baidu.com/s/1pLKHgsr ，密码是: 73c5。 选择11.2版本的下载下来丢进这个目录/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/即可， 手机上安装描述文件重启Xcode，然后再重新连接你的iPhone就可以了，中间还可能出现一个问题就是，启动程序失败，如下： 原因很简单，就是手机上需要信任这个描述文件，如下： 然后就可以在我们的手机上安装成功了。 转发端口到Mac上我们希望在Mac上可以直接通过localhost来访问到目标设备，而不是192.168.1.145这样的内网地址，怎么做呢？如下： 12$ brew install libimobiledevice$ iproxy 8100 8100 注意上面的是libimobiledevice，imobiledevice已经不存在了，应该是升级成libimobiledevice这个了。然后我们在浏览器输入：localhost:8100/inspector就可以看到如下界面了： 说明端口转发成功！ 运行Python3脚本这个Python3脚本依赖一个包https://github.com/openatx/facebook-wda，这个包是WebDriverAgent的一个Python操作库，因此我们先安装这个包： 1$ pip3 install --pre facebook-wda 接着将脚本下载下来，地址https://github.com/wangshub/wechat_jump_game。下载完成以后我们打开目录可以看到以下文件： 1234567$ wechat_jump_game-master lsLICENSE config wechat_jump_auto.pyREADME.md config.json wechat_jump_auto_iOS.pyTools requirements.txt wechat_jump_iOS_py3.pyautojump.png resource wechat_jump_py3.pychangelog.md screenshot_backupscommon wechat_jump.py 上面的config.json是我从config目录中拷贝出来的，不然会报错，找一个和自己手机分辨率一样的目录，进去拷贝这个config.json出来就好了。 打开微信小游戏我们现在需要打开微信小游戏，然后使用两种模式来玩，自动和手动： 自动模式： 1$ python3 wechat_jump_auto_iOS.py 手动模式： 1$ python3 wechat_jump_iOS_py3.py 推荐手动模式，自己测距然后再点比较准确一点，自动模式好像到105分左右就会挂掉，不太靠谱。下面晒一晒自己的“战绩”： 一下子刷到了好友排名第三名，哈哈，不搞第一了，大家都懂。 总结本文通过微信小程序游戏“跳一跳”作弊操作为例，详细讲解了如何将Xcode中的应用部署到真机上进行测试的操作流程，以前一直都不熟悉这一块，因此每次搞几下就放弃了。但是2018年都来了，要钻进去，一定可以找到解决方案，果然不负自己所望。面对不懂的问题，可以搁置，但是不能次次都搁置，否则现在不懂，到以后还是不懂。及时解决问题的心态和能力也是非常重要的。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"IOS","slug":"开发技术/IOS","permalink":"http://qinjiangbo.com/categories/开发技术/IOS/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://qinjiangbo.com/tags/IOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://qinjiangbo.com/tags/Xcode/"},{"name":"跳一跳","slug":"跳一跳","permalink":"http://qinjiangbo.com/tags/跳一跳/"}]},{"title":"利用Docker搭建IDEA授权服务器","slug":"build-idea-license-server-via-docker","date":"2018-01-06T16:19:06.000Z","updated":"2018-03-19T13:46:07.000Z","comments":true,"path":"build-idea-license-server-via-docker.html","link":"","permalink":"http://qinjiangbo.com/build-idea-license-server-via-docker.html","excerpt":"","text":"上一篇我们提到过如何构建一个Docker镜像并提交到Docker Hub仓库，还记得我们制作的是什么镜像吗？没错，就是IDEA License Server！因此，本文就接着上一篇文章的内容，我们来搭建一个授权服务器。 拉取镜像我们先看一下授权服务器镜像在仓库中的样子： 可以在右侧看到这样一行命令：docker pull qinjiangbo/idea-license-server，因此我们在命令行直接执行这个命令： 1$ docker pull qinjiangbo/idea-license-server 拉取完成后我们使用docker images命令来查看镜像： 123$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEqinjiangbo/idea-license-server latest e9d376fd30b0 21 minutes ago 118MB 运行镜像其实这部分工作就是我们前面已经提到过的工作啦，不过这里做一些说明。授权服务器镜像暴露出来的端口号是1017，为什么是这个？因为10月17号是这个授权服务器作者的女朋友的生日。我们需要做的就是将主机的端口和这个容器的端口做一个映射，为了方便，我们通常选择80端口。因此命令如下： 1$ docker run -d -p 80:1017 e9d376fd30b0 后面的e9d376fd30b0是镜像的ID号，这里还可以通过-e选项加上一个参数USER=yourname来指定激活的用户名。容器启动以后我们通过docker ps来查看正在运行中的容器： 123$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad81821362a2 e9d376fd30b0 \"/docker-entrypoin...\" Less than a second ago Up 1 second 0.0.0.0:80-&gt;1017/tcp heuristic_keller 访问授权服务器地址这里我们可以直接通过浏览器访问授权服务器地址，如果我们在本地启动，在浏览器输入127.0.0.1，我们可以看到： 激活IDEA产品按照上面的操作，我们打开Intellij进行注册，如下，已经注册成功！ 总结其实大家完全可以自己搞一台服务器，买一个域名，这样的话就可以通过域名来进行注册了。虽然区别不大，但是看起来舒服点，专业点。使用Docker的好处就是可以package one place, deploy everywhere！非常棒的体验！ 更新：最近发现一个问题，如果不指定-u参数，这个授权服务器授权的用户名字会以第一个成功授权的用户名作为所有用户授权的用户名。也就是说Licensed to [yourname]这个yourname就是第一个成功被授权的用户，这是一个BUG，作者在1.5版本里面还没有修复，期待作者能快速修复。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Docker","slug":"架构师/Docker","permalink":"http://qinjiangbo.com/categories/架构师/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://qinjiangbo.com/tags/Docker/"},{"name":"IDEA License Server","slug":"IDEA-License-Server","permalink":"http://qinjiangbo.com/tags/IDEA-License-Server/"}]},{"title":"Docker制作镜像并提交到Docker Hub","slug":"make-docker-images-and-push-to-docker-hub-center","date":"2018-01-06T11:55:17.000Z","updated":"2018-01-06T16:14:43.000Z","comments":true,"path":"make-docker-images-and-push-to-docker-hub-center.html","link":"","permalink":"http://qinjiangbo.com/make-docker-images-and-push-to-docker-hub-center.html","excerpt":"","text":"前面研究过Docker的基本命令和使用，但是一直没有介绍如何制作自己的一个镜像并将其提交到Docker Hub镜像中心，本文今天就介绍如何来制作一个关于IDEA授权服务器的Docker镜像并提交到Docker Hub。 登录Docker Hub首先我们需要注册一个Docker Hub的用户名，以我的为例：qinjiangbo。登录Hub以后，需要创建一个repository，作为我们后面提交的仓库。如下图： 第一步，找到create菜单 第二步，填写相关信息 第三步，查看已创建仓库 终端登录Docker我使用的是macOS版本，因此直接打开Docker应用就可以了。如果没有使用Docker应用的话，可以直接在终端输入docker login来登录的。 12345docker loginLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.Username (qinjiangbo): qinjiangboPassword: Login Succeeded 下载授权服务器程序我们制作的镜像是关于IDEA的授权服务器的，因此需要先下载这个授权服务器运行程序。下面给出磁力链接： 磁力链接: magnet:?xt=urn:btih:ED1FA379ECBD34D13CB7D14B0C2B024986A6FC79&amp;dn=IntelliJIDEALicenseServer(v1.4).tar.tar) 粘贴到迅雷下载，完成以后解压可以看到一下文件列表： 12345678910111213$ cd IntelliJIDEALicenseServer$ IntelliJIDEALicenseServer lsIntelliJIDEALicenseServer.html IntelliJIDEALicenseServer_linux_mips64leIntelliJIDEALicenseServer_darwin_386 IntelliJIDEALicenseServer_linux_mipsleIntelliJIDEALicenseServer_darwin_amd64 IntelliJIDEALicenseServer_netbsd_386IntelliJIDEALicenseServer_freebsd_386 IntelliJIDEALicenseServer_netbsd_amd64IntelliJIDEALicenseServer_freebsd_amd64 IntelliJIDEALicenseServer_netbsd_armIntelliJIDEALicenseServer_freebsd_arm IntelliJIDEALicenseServer_openbsd_386IntelliJIDEALicenseServer_linux_386 IntelliJIDEALicenseServer_openbsd_amd64IntelliJIDEALicenseServer_linux_amd64 IntelliJIDEALicenseServer_windows_386.exeIntelliJIDEALicenseServer_linux_arm IntelliJIDEALicenseServer_windows_amd64.exeIntelliJIDEALicenseServer_linux_mips md5sumIntelliJIDEALicenseServer_linux_mips64 我们后期是要放在Linux服务器上运行的，所以选择一个Linux版本，IntelliJIDEALicenseServer_linux_386和IntelliJIDEALicenseServer_linux_amd64都可以的，只是对应的处理器类型不同，我们这里选择IntelliJIDEALicenseServer_linux_386。 制作Docker镜像我们最终是需要制作一个Dockerfile文件，在此之前，我们需要准备一些文件。给大家列举一下： 123$ license-server lsDockerfile IntelliJIDEALicenseServer_linux_386IntelliJIDEALicenseServer.html docker-entrypoint.sh 这里需要跟大家解释一下过程，首先我们需要创建一个文件夹用于存放这些文件，我们这里创建的文件夹名称是license-server，里面包含四个文件： Dockerfile，这个不解释 IntelliJIDEALicenseServer_linux_386，这个是我们的授权服务器运行程序 IntelliJIDEALicenseServer.html，这个是提示页面，就是用户如果在浏览器直接访问授权服务器地址，展现给用户的提示页面，一般会告诉用户如何操作 docker-entrypoint.sh，这个主要是容器启动后用来执行运行程序的脚本 重点看两个文件： Dockerfile123456789101112131415161718FROM ubuntuMAINTAINER qinjiangbo&lt;qinjiangbo1994@163.com&gt;RUN mkdir /ideaADD IntelliJIDEALicenseServer_linux_386 /ideaADD IntelliJIDEALicenseServer.html /ideaADD docker-entrypoint.sh /RUN chmod 755 idea -RRUN chmod 755 docker-entrypoint.shEXPOSE 1017WORKDIR /ideaCMD [\"/docker-entrypoint.sh\"] 这个内容就不解释了，不明白的可以看我前面的关于Docker的几篇文章。 docker-entrypoint.sh12#!/bin/bash./IntelliJIDEALicenseServer_linux_386 打包制作镜像制作镜像的命令比较简单： 1$ docker build -t license-server:latest . 注意最后有一个. 查看镜像列表： 12345678$ docker images REPOSITORY TAG IMAGE ID CREATED SIZElicense-server latest 34fe7d26dd9e 4 hours ago 118MBubuntu latest 00fd29ccc6f1 3 weeks ago 111MBsshd_centos latest f0560ea85754 2 months ago 221MBnginx latest 1e5ab59102ce 2 months ago 108MBgitlab/gitlab-ce latest 453d64ae84c7 3 months ago 1.28GBcentos latest 196e0ce0c9fb 3 months ago 197MB 已经存在这个镜像了，接下来需要给这个镜像打标，示例就是docker tag &lt;existing-image&gt; &lt;hub-user&gt;/&lt;repo-name&gt;[:&lt;tag&gt;]，因此我们这样操作： 1$ docker tag 34fe7d26dd9e qinjiangbo/idea-license-server 再次查看可以看到列表中多了一个： 123456789$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZElicense-server latest 34fe7d26dd9e About an hour ago 118MBqinjiangbo/license-server latest 34fe7d26dd9e About an hour ago 118MBubuntu latest 00fd29ccc6f1 3 weeks ago 111MBsshd_centos latest f0560ea85754 2 months ago 221MBnginx latest 1e5ab59102ce 2 months ago 108MBgitlab/gitlab-ce latest 453d64ae84c7 3 months ago 1.28GBcentos latest 196e0ce0c9fb 3 months ago 197MB 如果是针对容器做出修改又如何创建呢？docker commit &lt;exiting-Container&gt; &lt;hub-user&gt;/&lt;repo-name&gt;[:&lt;tag&gt;]这个命令可以解决。 提交到Docker Hub仓库中1234567891011121314$ docker push qinjiangbo/idea-license-server The push refers to a repository [docker.io/qinjiangbo/idea-license-server]9ee0aba95d5f: Pushed d18db1e351f0: Pushed cdc1754f226e: Pushed e65d9cc78d36: Pushed c15ee4074338: Pushed 3da57500ceb4: Pushed f17fc24fb8d0: Pushed 6458f770d435: Pushed 5a876f8f1a3d: Pushed d2f8c05d353b: Pushed 48e0baf45d4d: Pushed latest: digest: sha256:21c1dc48a12372fa4943e262f8dc57af9782664278e6f8bfaab68251de6fb8b7 size: 2607 中间可能会报以下错误： 123$ docker push qinjiangbo/idea-license-server:latestThe push refers to a repository [docker.io/qinjiangbo/idea-license-server]Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io on 192.168.65.1:53: read udp 192.168.65.2:56209-&gt;192.168.65.1:53: i/o timeout 没关系，重试几次就好了，最好加上VPN会比较稳定一点。 查看Docker Hub个人仓库 可以看到，我们的镜像已经制作并提交成功了。 总结以上就是如何制作一个Docker镜像并提交到Docker Hub仓库的基本流程。需要注意自己是基于别人镜像的容器改进的还是自己从零开始制作的，因为方式是不一样的。上面也提到了两者的制作方式。大家有什么好的镜像都可以踊跃地向社区提交，优秀的东西应该和大家一起分享嘛！","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Docker","slug":"架构师/Docker","permalink":"http://qinjiangbo.com/categories/架构师/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://qinjiangbo.com/tags/Docker/"},{"name":"Docker Hub","slug":"Docker-Hub","permalink":"http://qinjiangbo.com/tags/Docker-Hub/"}]},{"title":"利用Tesseract OCR引擎识别验证码","slug":"recognize-captcha-via-tesseract-ocr-engine","date":"2018-01-06T07:01:11.000Z","updated":"2018-01-06T14:02:34.000Z","comments":true,"path":"recognize-captcha-via-tesseract-ocr-engine.html","link":"","permalink":"http://qinjiangbo.com/recognize-captcha-via-tesseract-ocr-engine.html","excerpt":"","text":"最近研究了一下验证码识别的技术，基本上都是在做图像的识别，具体一点来说就是文字的识别。比较流行的就是使用Google的Tesseract OCR引擎来做支撑，识别图像中的文字。本文主要讲解如何利用Tesseract OCR识别最简单的验证码和文章内容。 安装Tesseract OCR引擎关于Windows下如何安装Tesseract OCR引擎的文章实在是太多了，我就不赘述了，这里重点讲一下如何在macOS中安装Tesseract OCR引擎，答案是Homebrew或MacPorts。 Homebrew安装使用Homebrew安装只需要运行以下代码即可： 1brew install tesseract MacPorts安装使用MacPorts安装只需要运行一下代码即可： 1sudo port install tesseract 安装PIL和Pytesseract需要安装Python3的图像处理库和Tesseract包装类。 12pip3 install Pillowpip3 install pytesseract 安装完毕以后基本上就可以用来识别一些简单的图片验证码啦，还有一些比较清晰的文字。 简单验证码识别实例我们以一些简单的图片为例演示一下如何使用Python3来识别验证码或图片文字。以下面的一个验证码为例： 可以通过Pytersseract来识别： 123456789import pytesseractfrom PIL import Imageimage = Image.open(\"data/7025.png\")image = image.convert(\"L\")image.load()image.split()image.save(\"data/gray_7025.png\")print(pytesseract.image_to_string(image)) 结果如下： 1237025Process finished with exit code 0 另外在data目录下我们还可以看到一张二值化后的图片： 能够非常准确滴将这种简单的验证码识别出来。 标准文字图片实例这一节我们以CNN网站上的新闻文字为例，截取了一张CNN的新闻文字图片，如下： 我们看一下它的识别效果如何？看一下运行结果： 1234567891011The President‘s own lies and distortions, which are keyfeatures of his leadership style, make it impossible foranyone to rely on him and his aides in a normal way.As a private citizen, Trump developed this squid—inkmethod so that he could sell himself like a humanproduct. In falsely claiming that various starlets pursuedhim for dates, or the British royals were eying Trumpreal estate, he played a game with reality.Process finished with exit code 0 基本上没有什么错误地识别出来了。 关于Tesseract OCR其它语言包以及复杂验证码问题本文主要讨论的是如何利用Tesseract OCR引擎解决简单验证码和图片文字识别的问题。但是验证码可能会比较复杂，比如说加了干扰线等等。另外，Tesseract OCR用来识别中文会如何？这一些问题都是值得好好研究的。 Tesseract OCR其它语言包的问题在这个页面下可以看到很全的语言包信息。https://github.com/tesseract-ocr/tesseract/wiki/Data-Files 大家可以下载对应的包去处理对应的文字信息。关于如何使用这些包，我以中文为例演示一下，首先在刚刚的网址下载一个中文的包，我们可以先看一下自己的tesseract-ocr版本是多少？ 1234$ tesseract --versiontesseract 3.05.01 leptonica-1.74.4 libjpeg 9b : libpng 1.6.34 : libtiff 4.0.9 : zlib 1.2.11 所以，我们下载3.05版本的中文包，点我下载。 把这个包加载到一个名叫lang的目录下，名字可以随便定，但是lang这个包要和我们的代码在同一个目录。一下面这幅图为例： 12345678import pytesseractfrom PIL import Imageimage = Image.open(\"data/163-news-image.png\")image.load()image.split()tesseract_data_config = '--tessdata-dir \"lang\"'print(pytesseract.image_to_string(image, lang=\"chi_sim\", config=tesseract_data_config)) 结果如下： 12345这是习近立总书记在新进口央委员会的委员` 候补委员和省部级三要领导二部学&gt;J贝彻刁近其新时代口玉特色社会二二义思想和党的十九大精神研讨班开班式上说的一句=目一新` 息昧深长的话。Process finished with exit code 0 可以看到中文的效果不是很理想，后面再进一步研究如何改进这种情况。 复杂验证码的问题复杂验证码的情况比如字体变形了，或者是字体上加了很多干扰线，这种情况下仅仅tesseract-ocr是做不到的。需要前期做大量的预处理，比如去噪，二值化等等，这个也需要后面再进一步研究研究。面对更复杂的验证码就有可能需要使用机器学习的方式了。 总结本文主要是介绍了如何使用Tesseract-OCR引擎并结合Python3来实现对简单验证码和普通文本的识别工作。目前这个引擎对英文的识别度非常理想，基本上可以用作商业用途了，而针对中文的识别效果则非常不理想，基本上不怎么可用，后面需要针对这个问题进一步研究，改进相关的模型和研究方法。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Python","slug":"开发技术/Python","permalink":"http://qinjiangbo.com/categories/开发技术/Python/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"http://qinjiangbo.com/tags/Python3/"},{"name":"Tesseract OCR","slug":"Tesseract-OCR","permalink":"http://qinjiangbo.com/tags/Tesseract-OCR/"}]},{"title":"解决Python3不能导入pip3安装包问题","slug":"solve-problem-that-python3-cannot-load-modules-pip3-installed","date":"2018-01-05T17:53:50.000Z","updated":"2018-01-06T04:15:06.000Z","comments":true,"path":"solve-problem-that-python3-cannot-load-modules-pip3-installed.html","link":"","permalink":"http://qinjiangbo.com/solve-problem-that-python3-cannot-load-modules-pip3-installed.html","excerpt":"","text":"最近要跑一个机器学习的demo，按照要求使用pip3命令安装好了相关的模块，结果出现了一个重大的问题，就是使用python3命令导入相关模块的时候直接出现了一个很尴尬的问题，无法查找到该模块。如下： 12345678$ python3Python 3.6.3 (v3.6.3:2c5fed86e0, Oct 3 2017, 00:32:08) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; import imutilsTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ModuleNotFoundError: No module named 'imutils' pip3安装包位置与python3引用位置不同在命令行查看一下pip3到底是什么？ 1234$ which pip3/usr/local/bin/pip3$ pip3 --versionpip 9.0.1 from usr/local/lib/python3.6/site-packages 注意这里的目录usr/local/lib/python3.6/site-packages，下面我们会和它进行对比。 在命令行打开Python3的终端： 12345678$ python3Python 3.6.3 (v3.6.3:2c5fed86e0, Oct 3 2017, 00:32:08) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; import sys&gt;&gt;&gt; print(sys.path)['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages']&gt;&gt;&gt; 看最后一个路径/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages，和我们上面pip3安装的目录usr/local/lib/python3.6/site-packages居然不一样。也就是说我们使用python3命令根本就无法导入pip3安装的模块，因为完全找不到这个目录下。有些同学可以看一下自己的python3输出结果，有的是这个： 12345678$ python3Python 3.6.3 (v3.6.3:2c5fed86e0, Oct 3 2017, 00:32:08) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; import sys&gt;&gt;&gt; print(sys.path)['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', 'usr/local/lib/python3.6/site-packages']&gt;&gt;&gt; 这种情况的话就可以直接导入成功了。我也不太清楚为啥同样是Homebrew安装Python，结果有的同学是这个结果，有的同学是那个结果，不过没关系，下面我们提出解决方案。 建立一个软链将两个site-packages合并其实我们是希望python3能够找到pip3安装的模块，但是无法找到usr/local/lib/python3.6/site-packages这个目录，我们可以将这个site-packages去掉，将它变成/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages的一个软链接，这样的话，我们使用pip3安装的模块都会直接进入/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages这个目录了，导入自然就没问题了。 123$ cd /usr/local/lib/python3.6$ mv site-packages site-packages.bak$ ln -s /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages site-packages 这样软链就创建完成了，关于site-packages.bak这个目录，如果你觉的没什么用就可以直接删除了。这样我们再次使用pip3安装imutils这个模块，就会直接进入/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages这个目录。我们接下来再次使用python3导入一下这个模块： 123456$ python3Python 3.6.3 (v3.6.3:2c5fed86e0, Oct 3 2017, 00:32:08) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; import imutils&gt;&gt;&gt; 说明导入成功了！ 其它博客的解决方案在网上之前找了很多解决方案，其中比较多的就是说在/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages目录中建立一个.pth文件，指定另一个site-packages目录的地址，然后site.py文件会自动去查找，但是这种方案仅针对python2.7，我还没有试过，不过觉得比较麻烦，而且不一定能成功，所以就没有采取这种方法。 PyCharm安装目录我们在使用PyCharm去安装一些模块的时候会到这里进行安装： 看到上面的项目解释器(Project Interpreter)，就是我们上面提到的Python3.6.3，它的安装目录地址就是/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages，因此PyCharm在这个解释器的情况下会安装到/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages这个目录。和我们在命令行使用pip3安装模块的目录是一样的。我们使用pip3安装一些目录以后，重新打开这个窗口，就会发现这里全部显示出来了。 总结这个应该算是Python环境里面的一个大坑了吧，对于Python不太熟悉的朋友很有可能会被这么多的安装位置搞晕，搞懵。不过我们在遇到这个问题的时候还是要冷静思考，多Google，看得多了，自己也就对这个问题慢慢熟悉了，然后才能有自己的解决方案。所以一定要有足够的Input，才能有Output。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Python","slug":"开发技术/Python","permalink":"http://qinjiangbo.com/categories/开发技术/Python/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"http://qinjiangbo.com/tags/Python3/"},{"name":"pip3","slug":"pip3","permalink":"http://qinjiangbo.com/tags/pip3/"}]},{"title":"MacOS为Python3安装OpenCV3","slug":"install-opencv3-for-python-on-mac","date":"2018-01-05T14:00:49.000Z","updated":"2018-01-06T04:15:17.000Z","comments":true,"path":"install-opencv3-for-python-on-mac.html","link":"","permalink":"http://qinjiangbo.com/install-opencv3-for-python-on-mac.html","excerpt":"","text":"说到OpenCV，大家也许并不陌生，就是一个非常强大的库，主要用于面部识别，物体识别，边缘检测以及图像处理等等很多方面。本文呢，主要就是告诉大家如何在macOS下面安装好OpenCV，因为国内的大多数博客都是在介绍如何在Windows下安装。 安装Homebrew [已安装请跳过]官方提供的方式如下： 1$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 我们手动将Homebrew升级到最新的版本： 1$ brew update 安装OpenCV3首先需要进行的一步是要添加OpenCV的源，主要是通过下面的这个命令添加的： 1$ brew tap homebrew/science 但是这个命令会报一个问题，如下： 1Warning: homebrew/science was deprecated. This tap is now empty as all its formulae were migrated. 我的建议是先不用管它，直接接着安装就好了： 1$ brew install opencv3 --with-contrib --with-python3 注意，这个地方不要在最后加上--HEAD选项，否则会找不到这个HEAD的，至少最新版的Python(3.6.3)是这样的。 进入OpenCV目录123456$ cd /usr/local/Cellar/opencv$ ls3.4.0$ cd 3.4.0/lib/python3.6/site-packages$ lscv2.cpython-36m-darwin.so 创建一个软链接到Python3的site-packages1$ ln -s /usr/local/Cellar/opencv/3.4.0/lib/python3.6/site-packages/cv2.cpython-36m-darwin.so /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/cv2.so 检测是否安装成功可以通过导入这个模块来检测是否安装成功。 1234567$ python3Python 3.6.3 (v3.6.3:2c5fed86e0, Oct 3 2017, 00:32:08) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; import cv2&gt;&gt;&gt; print(cv2.__version__)3.4.0 说明安装成功啦~","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Python","slug":"开发技术/Python","permalink":"http://qinjiangbo.com/categories/开发技术/Python/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"http://qinjiangbo.com/tags/Python3/"},{"name":"OpenCV3","slug":"OpenCV3","permalink":"http://qinjiangbo.com/tags/OpenCV3/"},{"name":"Homebrew","slug":"Homebrew","permalink":"http://qinjiangbo.com/tags/Homebrew/"}]},{"title":"写在2018年伊始","slug":"write-at-the-new-beginning-of-2018","date":"2018-01-02T15:25:16.000Z","updated":"2018-01-03T12:31:27.000Z","comments":true,"path":"write-at-the-new-beginning-of-2018.html","link":"","permalink":"http://qinjiangbo.com/write-at-the-new-beginning-of-2018.html","excerpt":"","text":"每年到了年末的时候都会总结一下今年的总总事情，回顾一下今年有哪些目标达成了，有哪些还没有做到，明年准备如何做等等。其实我觉得这是一个非常有必要性的事情，因为总结过去才能展望未来！ 2017年对于我来说是忙碌的一年，但同时也是收获的一年。关于2017年的记忆从三月开始，看到同学们都在认真准备春招面试，我却很淡定。因为我的计划就是好好在实验室学习技术，直接准备九月份的秋招，然后我还理直气壮地跟身边的小伙伴谈自己的想法。有的小伙伴支持我的观点，有的小伙伴反对我的观点，但是我却没有任何动摇，心态平静地学习着技术。直到某一天… 三月22号下午，小磊给我发了一个微信，说阿里巴巴春招，阿里有一个人可以内推我，说可以直接进二面。我心里面其实动摇了，但是却也给他婉拒了。因为一月初的时候涂斌也给我发了一个网易的内推岗位，也是非常优惠的条件，但是我还是给拒绝了。我虽然婉拒了，但是还是将手机号，邮箱等给了小磊，那个能帮我内推的阿里师兄（就是我后来的主管啦，很赞的！）就完善了资料，发了一份内推邀约过来了。看到邀约邮件，一不小心就点击，然后就直接进入了流程。好吧，那就全力以赴吧，按照要求重新制作了一份简历，真的是非常简洁额，包括个人基本信息，教育背景，实习经历，项目经历以及个人兴趣爱好。虽然品类很多，但是每一个都很简洁，只保留了关键信息，最终所有信息浓缩在一张纸上。这里也提醒大家制作简历的时候尽量简练，能用最少的文字表达最大量的信息也是一个人的综合能力的体现。 由于之前准备了比较长的一段时间，因此面试官（后来是我的大师兄，非常厉害！）的电话打过来面试的时候就是一开始紧张了一下，后来就比较自然了，不管是谈算法的理解，还是谈语言的认识，还是谈自己的项目都比较顺利，因此很顺利地通过了一面。后面的几轮面试都是在“紧张地准备以及平静地面试”这种状态中度过的。那段时间很充实，因为每天的目标很明确，知道自己的下一个点在哪儿，下一个方向是什么。 中间的一个插曲是腾讯公司的面试，其实四月3号做腾讯的面试题的时候，我给女朋友说了一个词，“血虐”，做完的感觉很一般，不过还是把能做的都做了，后面一问很多同学和我的体验是一样的，都是被血虐。不过很幸运，还是收到了腾讯公司的面试邀约，和阿里略有不同的是，腾讯采用的是现场面试，就在光谷那边的凯悦大酒店。过去第一轮面试进入一个房间，面试官直接让我用C写一个字符串反转的算法，我内心是拒绝的，因为我面试的是Java。于是想了一会，我鼓起勇气跟面试官说了我的想法，他人也很nice。说给我安排一下，后面是一个移动端团队的老大面试的，面试谈了很多，JVM虚拟机调优，线程池实现原理，网络TCP/IP等等。然后给了一支笔和一张纸，说让设计一个API接口返回码，要求可拓展，可以快速查找等等。我想了一下决定将一些关键属性封装起来，然后使用树的结构进行存储，重写比较的接口，根据关键属性进行排序，这样不管要添加什么新的返回码，都可以很好地拓展。他很感慨地说道，你是我今天下午第一个能谈的这么爽快的人，你在我这里已经没什么问题了，只要过了二面，我们团队欢迎你的到来。后面又陆续去参加了二面，是一个技术总监，全程无笑脸，非常严肃。直接做了三个题，外加问了一下我的实习经历。虽然一波三折，但是三道题还是都做出来了。出门的时候感觉自己要GG了，但是晚上的时候查看招聘状态，HR面试！最后去参加了HR面试，顺利通过了腾讯公司的全部考核。腾讯公司比阿里早三天发了录用通知书，限我三天之内签约，否则这个签约书就失效了。我思考了很久，又跟阿里师兄确认了阿里的情况。他说HR（颖姐）正在给我办理，让我不要着急，我说好的。 是时候做选择了。阿里和腾讯该如何抉择？而且腾讯公司Offer签约快截止了，而阿里巴巴Offer还迟迟没有到来。我思考了很久。我是这样认为的，阿里巴巴集团是一家战略驱动型公司，而腾讯公司是一家产品驱动型公司。另一个原因就是阿里巴巴集团的技术栈主流是Java语言，而腾讯公司的技术栈主流是C/C++语言（这一点后面腾讯公司打电话过来问我的时候也承认了）。从自身发展的角度来说，我认为阿里巴巴集团是最适合的，因为我热爱的Java技术栈是主流，意味着可以接触到很多Java相关的大神，同时也能培养自己的分享的意识，这一点后面会单独谈到。另外，关于两家公司的发展，我认为战略型的公司虽然短期内可能不如产品型公司发展迅速；但是从最终能够到达的高度来看，我认为战略型的公司会远远超过产品型的公司。（注意，这里没有贬低腾讯公司的意思，不得不说腾讯公司也是一家非常优秀的公司，这只是我个人的一个浅见而已，如有触犯还请谅解。）所以，我的最终选择是等待，选择继续等待阿里巴巴的Offer。终于在第三天晚上六点半收到了阿里巴巴集团的Offer，感谢HR的及时，点赞！ 其实人的一生中有很多做选择的时刻，关键是看自己选择的标准是什么。有同学曾经说过，说秦江波，我觉得你就没有做过什么错的决定。我笑了笑，哪会没有呢？人啊，都是在这些错误决定的坑里慢慢爬起来的。做决定的时候也会越来越谨慎，因为知道错误的决定会给自己带来的伤有多痛，麻烦有多大。在针对一件事情做决定时，往往考虑最多的不是这个事情本身，而是与这个事情相关的其它很多事情，是这些事情的存在导致了这个决定变得复杂起来，这些都属于一些影响因素。考虑影响因素的时候我想我们可以一件事情一件事情去梳理，而不是杂乱无章，毫无头绪地瞎着急。当两个影响因素出现冲突的时候，衡量一下二者的重要性是至关重要的。按照这个思路下去，我想其实做决定的时候应该都是朝最有利于我们的方向进行的。 另一件同时发生的事情就是考驾照了，终于在2017年把驾照拿到了，想想都很开心，虽然没有车开。其实考驾照是早在2015年就报名了事情，只是事情比较多，就一直没去。这里我还要反省一下自己，其实事情比较多只是一个借口而已，很多时候是自己不敢真的去面对。因为一直听别人说科目二很难考，所以就把去训练场练科目二一直拖着。知道去年研究生入学，心想这件事情不能再拖了，到了必须解决的时候了！于是跟教练说要去练车，真正到场地摸车的时候心里却是那么的平静。很多事情如果一直因为害怕面对而不去直面它，那么就会一直困于此，必须得有突破，其实真正面对的时候也没有那么难！科目二在惊险中顺利通过，因为在半坡熄火了，凭借我单身18年的手速成功重新点火，前后扣了20分，刚好及格。科目三训练其实到现在都还有阴影，但现在想想其实也慢慢释然了。科目三训练的时候，教练完全变了一个人，很凶（其实哪个驾校都一样），后来问其原因。他说，如果我不凶一点，怕你们记不住，到了自己一个人上路开车的时候出了什么事就没有后悔药了。明白以后我还挺感动的，感谢教练！ 五月底就赴公司实习去了，之前也写过关于很多在阿里实习的感悟，包括《遇见阿里》以及《百技培训感悟》等等。总的来说，阿里巴巴给我的感觉是非常好的！阿里巴巴是一家面向国际，面向世界的公司，因此可以看到很多外籍员工。而且这些外籍员工和中国员工相处得非常好，这也是一种文化上的交流吧。第一次去公司的时候，看到了阿里巴巴几个大字，活生生让我激动了好久，而且对面就是网易！这都是多么熟悉的公司啊！之前内推我的师兄突然变成了我的主管，人超级nice！先说一说我的主管，从师兄们给我说的一些情况以及我自己的亲身感受，可以看的出来主管对我非常的重视，希望我实习完毕能顺利留下来。在我心态非常紧张的时候，他抽空约我出来谈心，帮我缓解压力，这些我都一直记着，而且也感动着。他和我一样为了取得一个更好的结果而努力着，师兄，感谢你！另一个就是我的师傅了，博善师兄。他非常地严谨，对技术问题比较较真，如果某一点有疑问，他一定会当场去查询相关的资料，并能够在很短地时间内消化而且教授给我。这一点我也慢慢从他的身上学习到了。我们的团队一共有九个人，支撑着三大业务模块，每个人的作用都非常巨大。给大家分享一下我们团队的一个故事，其实这也是千千万万个阿里团队的故事。某一天夜里两点多的样子，我的钉钉突然各种消息通知声音响个不停，于是我就醒了，看消息。原来是集团监控报警了，大家都在群里面紧急解决这个问题，负责这一块业务的师兄正在群里面反馈实时进展，主管也在线。真的，对于这件事情我还是挺有感触的，这也是我后来了解到的阿里的一种重要的品质-Owner意识！每一个阿里人都很有很强烈的Owner意识，这是这个公司持续保持前进的很重要的一个驱动力。 阿里人热爱听分享，也热爱分享。在公司最常见的莫过是各种大大小小的分享会了，不管是技术的分享还是职场的分享，都有很多同学会去听。真正分享过的人才会知道什么叫台上三分钟，台下十年功了。实习期间我听过不少分享会，有天猫和聚划算的同学过来讲算法，讲数据化运营等，虽然听不懂，但是觉得好高端的样子。其实需要明白的是知道有这么一个事情就可以了，拓宽自己的眼界很重要，工作之余感兴趣的再仔细琢磨琢磨。自己也曾经代表优秀实习生上台进行了一次分享，上台之前非常紧张，其实到了台上就没那么紧张了，和大家正常的交流，讨论。上台展示自己的能力也是慢慢一次一次地锻炼起来的，这也是公司促进我的一个重要成长。阿里的技术氛围是我见过的非常纯粹和专注的，技术团队有很多极客，重要的是这些极客会和大家分享，帮助同学们一起成长，相信在这种环境下我们能获得快速的成长，同时自己也能帮助更多需要的同学一起成长，想想也是一件很快乐的事情。 八月底如愿收到了公司的签约书，顺利地加入了阿里巴巴。同时学校这边导师也打电话过来催了，希望我早点回来。后来有一个同学说实验室导师下面有好几支团队现在处于无管理状态，希望我能早点回来帮忙带一下这些团队。收到老师的消息以后，就主动和主管沟通了这个事情，主管也表示非常能理解，这里在此对主管表示感谢，点赞！然后十月一号就回学校了，回实验室的第一个星期就和全新的团队小伙伴们见了面，表示第一次见面确实很难记住这么多人的名字，所以后面就慢慢和大家熟络熟络了。管理团队是一门学问，我认为只有被管理过的人才能更好地管理好一个团队。还好，我在公司被管理过，所以知道团队成员和团队Leader之间的关系。和大家简单见过面以后，就一次询问了大家的研究方向和现在所做的事情以及想做的事情。根据大家目前的工作和想做的事情将同学们分成了四个小组，这样同学们才能更加明确自己的位置，同事也能明确自己所要做的工作是什么。为了具体化每个人的工作，我制作了一张表格，表格上会记录每个团队的每个成员在过去一周所做的工作，每个人都会记录，然后开会时给我汇报。通过具体到个人的方式可以很好地处理有些同学摸鱼的问题，我认为每个人都应该做一些事情，每个人都应该获得成长。但是每周的任务我不会给大家安排得很重，结合自己的课程学习情况合理安排即可，大家应该在一个相对舒适的环境下工作才是比较高效的。另外，我给大家透传的一个观点就是开会不仅仅是为了听取大家的工作汇报，更多地是希望听到同学们在工作中遇到的一些困难和疑惑，什么问题都可以在会议上提出来，这么多人一定有一个能解决这个问题的人，如果实在没有，我们一起想办法。总之，大家都不是一个人在战斗。 另一方面在准备毕设的事情，导师提供了一个反爬虫的研究，我觉得还不错，就选择这个题目开始做，目前浏览了很多论文，觉得可以改进的点还是有一些的。我采用的方式是实现一个系统，这个系统能够实时分析请求的情况并给出相应的反馈，另外还有离线模块对每一天的请求进行分析，看是否属于爬虫请求，然后再异步地加入到黑名单。另外就是在进行机器学习处理前需要对数据进行预处理，认为传统的基于固定时间间隔划分的用户会话可以更进一步改进。 还有一个非常重要的点就是十月份回学校以后一直在坚持健身，慢慢肚子上也开始有六块儿痕迹了，健身是一个非常容易令人产生成就感的活动。自从健身以后，很少开始生病，感冒几乎没有过，感觉自己比以前更加灵活，更能舒展地开了。另一个就是拔牙，拔牙是一个关键的点，以前没有养成夜晚刷牙的习惯，导致牙齿蛀掉了许多，有一个还需要做根管治疗，总之到目前位置，牙齿的问题基本上解决了。刷牙的习惯还是好好养成的，毕竟跟着我们的时间是一辈子。 终于赶在2018年之前入坑了机器学习，虽然对很多人来说会比较晚，但是我一直认为，学不嫌晚！我是做Java开发的，因此优先选择一个Java的数据挖掘工具Weka来研究。以前机器学习对于我来说就是一个反复出现的概念，自己想去了解但是有不知道该如何入手。现在慢慢一点一点啃，总算有那么回事了。至少现在说起来，还是知道机器学习和数据挖掘的基本流程的。知道如何去训练一个样本数据，知道如何将训练好的模型保存起来以便于后面直接使用，知道如何进行交叉验证，进行数据的标注等等。机器学习看起来很高大上，但是实际上对于数学院的同学来说不过是一些基本的内容罢了，所以我认为数学能力很重要，尤其是概率论和线性代数。机器学习重度依赖这两门学科。后面会把这一块列入学习的重点。 另一个就是反思一下自己这一年里面的存在各种各样的不足。 感情方面，觉得自己好像对她的重视度没有以前那么多了，以前都没这么觉得。直到平安夜我没有给她发消息导致她这么长时间以来就爆发了，我才意识到原来自己是那么的习惯了她，以至于忽略了她的感受。这一点我需要好好反省一下，毕竟那么努力也是为了以后能和她好好生活在一起，如果她都被我搞丢了，还图啥？不管工作再怎么忙，以后还是要多多和她沟通交流，倾听她的声音，感她之所感，想她之所想，慢慢达成默契。 作息时间好像没有那么规律了，去实验室的时间虽然基本上都是九点多，但是睡过点的次数也渐渐多了起来，以后去的时间应该更早，时间不等人。去得太晚是不应该的，虽然师兄们说让我好好享受学校的时光，但是不能这样度过。真正的享受应该是内心踏实地度过，每天能有所得，有所思，有所想。关于年末和同学们出去吃饭聚会啥的我都是比较倾向于大家的时间，希望不为难大家的时间，而不是说我生活作风变得随便懒散了，这里需要和有些同学澄清一下。真正让我感到担忧的是自己的意识松懈了。我认为时刻保持一颗忧虑的心能够让一个人不断地踏实前行，因为你一旦休息就可能会被超越。客观地评价一下自己吧，感觉还是需要沉下心来踏踏实实学习。很多时候节日太多，大家都约出去玩，搞得心里面比较浮躁，没法沉下来。这一点以后要注意，在后面的学习工作中应该加大投入。 要继续保持一颗锐意进取的心态，这才是最重要的！ 关于个人的谈吐和修养这一块还是要继续保持，尤其是在在女生面前还是要保持相对的绅士。不能够将自己的形象破坏了。文明用语很重要，不要受周围人的影响。关于自己的外在要更加注意了，出门在外，需要注意自身的形象，不到万不得已，都需要梳洗完毕，把身上整理完毕以后再出门。人们都在说经营，其实经营物品不难，经营自己很难。一个人在外面的形象如何，其实与每个人对自己的形象的经营是息息相关的。有一句话说的很好，即使我会通过美丽的外表发现一个丑恶的内心，我也不会通过邋遢丑陋的外表去窥探美丽纯洁的内心，外表没那么重要，但也没那么不重要！谈吐要更加斯文一点，不要满嘴一个NM，WC，MMP等等。如果能够文明用语表述的那就文明一点，毕竟说这些话还是比较掉底子的，除非是好基友好闺蜜面前。 关于2018年我有什么期待和想法呢？我想还是需要给自己定下一些目标和要求： 完成博客的相关系列教程，目前在2018年到来之前完成了设计模式的系列教程，去年码了一二十万字，今年争取翻一番。写出更多高质量的文章。 将一些学习的点逐个覆盖到，比如微服务，Java全部的技术栈等等，并且写成高质量的文章。 继续深入研究机器学习和数据挖掘，AndrewNG的视频还是要努力看完的，至少明白机器学习有哪些模型，分别能解决什么问题。自己以后选择方向发展的时候能够有的放矢。 学习数学，之前买了一本《程序员的数学》，还没有看，觉得很重要，还是抽空把它看完。 规律自己的作息时间，以后还是要早点起床，早点来实验室，哪怕大家都没有来。抓紧时间学习一些该学的知识，同时也要了解一些前瞻性的内容，为以后的发展留一个接口。 踏实做好自己的毕设，努力将系统做到极致，争取完成一篇高质量的论文。 继续保持健身的习惯，一旦停歇身体的反应非常明显，动起来才能够有好身体，动起来才能有好心态。 关于2018，我期待的事情还有很多，有一些就放在心里啦，不在这里透露了。也希望大家的2018能够一切顺利，能更加变成自己想要成为的那一个人，能够如愿完成自己的很多心愿。2018就要来了，你准备好了吗？","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://qinjiangbo.com/tags/2018/"},{"name":"年终总结","slug":"年终总结","permalink":"http://qinjiangbo.com/tags/年终总结/"}]},{"title":"[转]实用Python开源爬虫项目列表","slug":"practical-python-web-crawler-opensource-project-list","date":"2017-12-29T08:09:42.000Z","updated":"2017-12-29T08:43:15.000Z","comments":true,"path":"practical-python-web-crawler-opensource-project-list.html","link":"","permalink":"http://qinjiangbo.com/practical-python-web-crawler-opensource-project-list.html","excerpt":"","text":"WechatSogou [1] – 微信公众号爬虫基于搜狗微信搜索的微信公众号爬虫接口，可以扩展成基于搜狗搜索的爬虫，返回结果是列表，每一项均是公众号具体信息字典。 github地址：https://github.com/Chyroc/WechatSogou DouBanSpider [2] – 豆瓣读书爬虫可以爬下豆瓣读书标签下的所有图书，按评分排名依次存储，存储到Excel中，可方便大家筛选搜罗，比如筛选评价人数&gt;1000的高分书籍；可依据不同的主题存储到Excel不同的Sheet ，采用User Agent伪装为浏览器进行爬取，并加入随机延时来更好的模仿浏览器行为，避免爬虫被封。 github地址：https://github.com/lanbing510/DouBanSpider zhihu_spider [3] – 知乎爬虫此项目的功能是爬取知乎用户信息以及人际拓扑关系，爬虫框架使用scrapy，数据存储使用mongo github地址：https://github.com/LiuRoy/zhihu_spider bilibili-user [4] – Bilibili用户爬虫总数据数：20119918，抓取字段：用户id，昵称，性别，头像，等级，经验值，粉丝数，生日，地址，注册时间，签名，等级与经验值等。抓取之后生成B站用户数据报告。 github地址：https://github.com/airingursb/bilibili-user SinaSpider [5] – 新浪微博爬虫主要爬取新浪微博用户的个人信息、微博信息、粉丝和关注。代码获取新浪微博Cookie进行登录，可通过多账号登录来防止新浪的反扒。主要使用 scrapy 爬虫框架。 github地址：https://github.com/LiuXingMing/SinaSpider distribute_crawler [6] – 小说下载分布式爬虫使用scrapy,Redis, MongoDB,graphite实现的一个分布式网络爬虫,底层存储MongoDB集群,分布式使用Redis实现,爬虫状态显示使用graphite实现，主要针对一个小说站点。 github地址：https://github.com/gnemoug/distribute_crawler CnkiSpider [7] – 中国知网爬虫设置检索条件后，执行src/CnkiSpider.py抓取数据，抓取数据存储在/data目录下，每个数据文件的第一行为字段名称。 github地址：https://github.com/yanzhou/CnkiSpider LianJiaSpider [8] – 链家网爬虫爬取北京地区链家历年二手房成交记录。涵盖链家爬虫一文的全部代码，包括链家模拟登录代码。 github地址：https://github.com/lanbing510/LianJiaSpider scrapy_jingdong [9] – 京东爬虫基于scrapy的京东网站爬虫，保存格式为csv。 github地址：https://github.com/taizilongxu/scrapy_jingdong QQ-Groups-Spider [10] – QQ 群爬虫批量抓取 QQ 群信息，包括群名称、群号、群人数、群主、群简介等内容，最终生成 XLS(X) / CSV 结果文件。 github地址：https://github.com/caspartse/QQ-Groups-Spider wooyun_public[11] - 乌云爬虫乌云公开漏洞、知识库爬虫和搜索。全部公开漏洞的列表和每个漏洞的文本内容存在MongoDB中，大概约2G内容；如果整站爬全部文本和图片作为离线查询，大概需要10G空间、2小时（10M电信带宽）；爬取全部知识库，总共约500M空间。漏洞搜索使用了Flask作为web server，bootstrap作为前端。 github地址：https://github.com/hanc00l/wooyun_public spider[12] – hao123网站爬虫以hao123为入口页面，滚动爬取外链，收集网址，并记录网址上的内链和外链数目，记录title等信息，windows7 32位上测试，目前每24个小时，可收集数据为10万左右 github地址：https://github.com/simapple/spider findtrip [13 – 机票爬虫（去哪儿和携程网）。Findtrip是一个基于Scrapy的机票爬虫，目前整合了国内两大机票网站（去哪儿 + 携程）。 github地址：https://github.com/fankcoder/findtrip 163spider [14] – 基于requests、MySQLdb、torndb的网易客户端内容爬虫github地址：https://github.com/leyle/163spider doubanspiders[15] – 豆瓣电影、书籍、小组、相册、东西等爬虫集github地址：https://github.com/fanpei91/doubanspiders QQSpider [16] – QQ空间爬虫，包括日志、说说、个人信息等，一天可抓取 400 万条数据。github地址：https://github.com/LiuXingMing/QQSpider baidu-music-spider [17] – 百度mp3全站爬虫，使用redis支持断点续传。github地址：https://github.com/Shu-Ji/baidu-music-spider tbcrawler[18] – 淘宝和天猫的爬虫,可以根据搜索关键词,物品id来抓去页面的信息，数据存储在mongodb。github地址：https://github.com/pakoo/tbcrawler stockholm [19] – 一个股票数据（沪深）爬虫和选股策略测试框架。根据选定的日期范围抓取所有沪深两市股票的行情数据。支持使用表达式定义选股策略。支持多线程处理。保存数据到JSON文件、CSV文件。 github地址：https://github.com/benitoro/stockholm BaiduyunSpider[20] - 百度云盘爬虫github地址：https://github.com/k1995/BaiduyunSpider Spider[21] - 社交数据爬虫支持微博,知乎,豆瓣github地址：https://github.com/Qutan/Spider proxy pool[22] - Python爬虫代理IP池(proxy pool)github地址：https://github.com/jhao104/proxy_pool music-163[23] - 爬取网易云音乐所有歌曲的评论github地址：https://github.com/RitterHou/music-163 转载自：http://www.sohu.com/a/166385794_804770","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Python","slug":"开发技术/Python","permalink":"http://qinjiangbo.com/categories/开发技术/Python/"}],"tags":[{"name":"开源爬虫","slug":"开源爬虫","permalink":"http://qinjiangbo.com/tags/开源爬虫/"},{"name":"Python","slug":"Python","permalink":"http://qinjiangbo.com/tags/Python/"}]},{"title":"Weka机器学习实战之模型存储与读取","slug":"weka-machine-learning-practice-model-storage-and-load","date":"2017-12-28T02:57:26.000Z","updated":"2017-12-28T03:24:33.000Z","comments":true,"path":"weka-machine-learning-practice-model-storage-and-load.html","link":"","permalink":"http://qinjiangbo.com/weka-machine-learning-practice-model-storage-and-load.html","excerpt":"","text":"这一段时间突然想起来一件非常关键的事情，就是每次运行程序的时候模型都是重复训练的。试想一下，如果数据集非常庞大的时候，训练的时间将会被极大的放大，这对于系统来说是不可接受的。我们相有没有一种方式能够很快速地使用模型呢？答案是肯定的。 Weka训练模型保存可以看到前面不管是使用J48决策树也好，还是Kmeans也好，都是一次性的模型训练构建和使用，下一次启动程序的时候一样还是要重新训练，非常浪费时间。这里Weka为我们提供了一种非常不错的工具，可以将我们训练的模型持久化。就是SerializationHelper，这个类可以用来存储和读取模型文件的参数。具体代码如下： 12345678910111213/** * 保存模型名称 * @param classifier * @param modelName 模型名称 */public static void saveModel(Classifier classifier, String modelName) &#123; try &#123; SerializationHelper.write(MODEL_STORAGE_DIR + modelName + MODEL_EXTENSION, classifier); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 一般建议模型的保存目录设置在系统的一个拥有读写权限的目录当中，而不是在项目文件当中，这样项目打包的时候就不会很臃肿，而且管理起来也非常方便。 Weka训练模型读取好的，模型一般以.model后缀的形式保存起来，后面我们启动项目的时候需要使用到这个模型，那么如何加载呢？答案也是SerializationHelper，它负责读取模型文件中的参数，并以此构建一个决策树对象出来。具体代码如下： 12345678910111213141516/** * 读取模型 * @param modelName * @param &lt;T&gt; * @return */public static &lt;T&gt; T readModel(String modelName) &#123; Classifier classifier = null; try &#123; classifier = (Classifier) SerializationHelper.read(MODEL_STORAGE_DIR + modelName + MODEL_EXTENSION); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) classifier;&#125; 这里使用到了一点泛型的知识，相信会Java的同学这个基本都知道，就不做解释了哈。 模型存储和读取测试下面进行模型的存储和读取测试，还是以我们上一次说到的西瓜数据集为例，代码做一点点改变，以适配我们的这个类。首先是西瓜模型构建： 1234567891011121314/** * 训练生成分类器 * @return */public static Classifier generateClassifier() throws Exception&#123; Instances instances = loadDataSet(TRAINING_DATASET_FILENAME); // 初始化分类器 Classifier j48 = new J48(); // 训练该数据集 j48.buildClassifier(instances); // 模型保存 TrainningModelUtil.saveModel(j48, \"watermelon\"); return j48;&#125; 接着是模型的读取和应用： 123456789101112131415161718/** * 预测出当前数据最可能所属的类别 * @return */public static String predict(List&lt;String&gt; data, Instances trainingSet) throws Exception&#123; Classifier j48 = TrainningModelUtil.readModel(\"watermelon\"); // 创建Instance Instance instance = new DenseInstance(trainingSet.numAttributes()); // 分别添加待预测特征值 for (int i = 0; i &lt; data.size(); i++) &#123; instance.setValue(trainingSet.attribute(i), data.get(i)); &#125; // 需要能访问数据集 instance.setDataset(trainingSet); // 得出最可能所属类别 int index = (int)j48.classifyInstance(instance); return trainingSet.classAttribute().value(index);&#125; 测试方法，这里需要先执行generateClassifier()方法产生一个模型文件哈，然后才能执行下面的代码测试，否则会报错的： 12345678910111213141516public static void main(String[] args) &#123; try &#123; Instances instances = loadDataSet(TRAINING_DATASET_FILENAME); // 青绿,蜷缩,沉闷,清晰,凹陷,硬滑 [是] // 浅白,蜷缩,浊响,模糊,平坦,软粘 [否] List&lt;String&gt; data = Lists.newArrayList(\"浅白\",\"蜷缩\",\"浊响\",\"模糊\",\"平坦\",\"软粘\"); // 训练模型保存 // generateClassifier(); // 进行预测 String classOfData = predict(data, instances); System.out.println(\"class of data is: \" + classOfData); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果输出： 1class of data is: 否 结果是符合预期的，说明我们编写的代码是没有问题的。关于TrainningModelUtil类的完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.qinjiangbo.util;import weka.classifiers.Classifier;import weka.core.SerializationHelper;/** * @date: 28/12/2017 10:34 AM * @author: qinjiangbo@github.io * @description: 主要是用来保存训练好的模型到文件，以及从文件中读取训练好的模型 */public class TrainningModelUtil &#123; /** * 模型保存的目录 */ private static final String MODEL_STORAGE_DIR = \"/Users/richard/Documents/Weka Models/\"; /** * 模型文件的后缀 */ private static final String MODEL_EXTENSION = \".model\"; /** * 保存模型名称 * @param classifier * @param modelName 模型名称 */ public static void saveModel(Classifier classifier, String modelName) &#123; try &#123; SerializationHelper.write(MODEL_STORAGE_DIR + modelName + MODEL_EXTENSION, classifier); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 读取模型 * @param modelName * @param &lt;T&gt; * @return */ public static &lt;T&gt; T readModel(String modelName) &#123; Classifier classifier = null; try &#123; classifier = (Classifier) SerializationHelper.read(MODEL_STORAGE_DIR + modelName + MODEL_EXTENSION); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) classifier; &#125;&#125; 总结关于模型文件的保存是非常关键的一步，因为它关系到后面整体系统性能的好坏，试想一下，如果我们每一次都需要重新训练模型，那对于整个系统的性能伤害将是巨大的。所以，我比较建议先训练模型，保存为一个文件，然后通后面再过读取这个模型文件进行预测。这也是数据挖掘和机器学习的正规的方法论。","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"机器学习","slug":"数据科学/机器学习","permalink":"http://qinjiangbo.com/categories/数据科学/机器学习/"}],"tags":[{"name":"Weka","slug":"Weka","permalink":"http://qinjiangbo.com/tags/Weka/"},{"name":"机器学习","slug":"机器学习","permalink":"http://qinjiangbo.com/tags/机器学习/"},{"name":"模型存储","slug":"模型存储","permalink":"http://qinjiangbo.com/tags/模型存储/"}]},{"title":"常见14种设计模式汇总","slug":"summary-of-the-14-most-common-design-patterns","date":"2017-12-25T04:43:04.000Z","updated":"2017-12-25T05:15:05.000Z","comments":true,"path":"summary-of-the-14-most-common-design-patterns.html","link":"","permalink":"http://qinjiangbo.com/summary-of-the-14-most-common-design-patterns.html","excerpt":"","text":"装饰者模式包装一个对象以提供新的行为。文章地址：https://qinjiangbo.com/design-pattern-decoration.html 状态模式封装基于状态的行为，并且利用委托来实现各种状态之间的切换。文章地址：https://qinjiangbo.com/design-pattern-state.html 迭代器模式提供一种遍历对象却又不暴露它们内部实现的方法。文章地址：https://qinjiangbo.com/design-pattern-iteration.html 门面模式简化一系列类的访问接口。文章地址：https://qinjiangbo.com/design-pattern-facade.html 策略模式封装可相互替代的行为，并且利用委托来决定到底使用哪一个行为。文章地址：https://qinjiangbo.com/design-pattern-strategy.html 代理模式包装一个对象以控制它的访问。文章地址：https://qinjiangbo.com/design-pattern-proxy.html 工厂方法模式子类决定创建哪一个具体类。文章地址：https://qinjiangbo.com/design-pattern-factory-method.html 适配器模式包装一个对象并且为它提供不同的接口。文章地址：https://qinjiangbo.com/design-pattern-decoration.html 观察者模式当状态改变的时候允许对象被通知到。文章地址：https://qinjiangbo.com/design-pattern-observation.html 模板方法模式子类决定到底如何实现具体的算法。文章地址：https://qinjiangbo.com/design-pattern-template-method.html 组合模式客户端统对待一系列对象集合和单个对象。文章地址：https://qinjiangbo.com/design-pattern-composition.html 单例模式确保有且仅有一个对象被创建了。文章地址：https://qinjiangbo.com/design-pattern-singleton.html 抽象工厂模式允许一个客户创建一个对象簇而不用指定它们的具体对象。文章地址：https://qinjiangbo.com/design-pattern-abstract-factory.html 命令模式将请求封装成一个对象。文章地址：https://qinjiangbo.com/design-pattern-command.html","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"代理模式","slug":"代理模式","permalink":"http://qinjiangbo.com/tags/代理模式/"}]},{"title":"设计模式学习之模板方法模式","slug":"design-pattern-template-method","date":"2017-12-25T03:06:59.000Z","updated":"2017-12-25T05:19:14.000Z","comments":true,"path":"design-pattern-template-method.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-template-method.html","excerpt":"","text":"什么是模板方法模式模板方法模式(Template Method Pattern)在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法接口的情况下，重新定义算法的某些步骤。 理解模板方法模式这个模式是用来创建一个算法的模板的。什么是模板呢？其实模板就是一个方法，只不过这个方法可以有很多不同的实现方法而已。更具体地说，这个方法将算法定义成一系列步骤，其中的任何步骤都可以是抽象的，被子类根据实际情况具体实现。这样呢，即可以保证算法的整体结构不变，又可以让子类重新定义自己的算法。 模板方法模式类图 下面分别来说说各部分的作用： AbstractClass就是一个抽象方法，它定义了一些抽象的方法比如primitiveOperation1()和primitiveOperation2()，同时也定义了一个模板方法templateMethod()。模板方法在实现的过程当中使用到了这两个抽象方法，但是模板方法和它们的具体实现解耦了。 ConcreteClass是一个具体的方法，是上面的AbstractClass抽象类的子类，可能不止一个子类。这个类实现具体的操作，当模板方法需要这两个方法的时候就会调用它们。 实例分析-茶饮之道我们知道现在的奶茶的品类非常的多，有绿茶，红茶，珍珠奶茶，红豆奶茶，还有卡布奇诺等等。这些奶茶是如何被做出来的呢，工具都一样，流程也一样，但是做出来的产品却不同，秘密是什么？其实这里面就藏着我们今天的主角-模板方法模式。 先来分析一下做奶茶需要哪几步？ 可以看到这份培训手册中明确说明了咖啡和茶的生产工艺，都是有四个步骤， 烧，将水烧开 熬，在开水中把茶或者咖啡熬好 倒，把茶或者咖啡倒进杯子 添，添加一些调味剂 我们可以看到这几步就构成了大多数奶茶的生产流程。但是我们是不是应该将这些步骤封装一下呢？后面有什么新的产品上线就可以让店员快速学习上手。 下面我们看看如何抽象出这个产品： 定义茶品制作方法： 12345678910111213141516171819202122232425262728293031package com.qinjiangbo.template.methods;/** * Created by IntelliJ IDEA. * Date: 10/25/15 10:14 PM * Author: Richard */public abstract class CaffeineBeverage &#123; // 模板方法，封装了上述的四个步骤 public final void prepareRecipe() &#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125; // 具体方法，因为这一步大家都一样 public void boilWater() &#123; System.out.println(\"Boiling water...\"); &#125; abstract void brew(); // 具体方法，因为这一步大家都一样 public void pourInCup() &#123; System.out.println(\"Pouring in cup...\"); &#125; abstract void addCondiments();&#125; 茶的制造工艺： 12345678910111213141516171819package com.qinjiangbo.template.methods;/** * Created by IntelliJ IDEA. * Date: 10/25/15 10:22 PM * Author: Richard */public class Tea extends CaffeineBeverage &#123; @Override void brew() &#123; System.out.println(\"Steeping the tea...\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Adding the condiments...\"); &#125;&#125; 咖啡的制造工艺： 123456789101112131415161718package com.qinjiangbo.template.methods;/** * Created by IntelliJ IDEA. * Date: 10/25/15 10:23 PM * Author: Richard */public class Coffee extends CaffeineBeverage &#123; @Override void brew() &#123; System.out.println(\"Dripping coffee through filter...\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Adding sugar and Milk...\"); &#125;&#125; 后面其实我们可以依据这个模板写出很多奶茶的制作工艺的，扩展起来非常方便。 实例测试写了一个测试用例，比较简单： 12345678910111213141516171819202122package com.qinjiangbo.template.test;import com.qinjiangbo.template.methods.Coffee;import com.qinjiangbo.template.methods.Tea;/** * Created by IntelliJ IDEA. * Date: 10/25/15 10:26 PM * Author: Richard */public class TeaTest &#123; public static void main(String[] args) &#123; Tea tea = new Tea(); tea.prepareRecipe(); System.out.println(\"Above are about tea, following about coffee:\"); Coffee coffee = new Coffee(); coffee.prepareRecipe(); &#125;&#125; 输出的结果如下： 123456789Boiling water...Steeping the tea...Pouring in cup...Adding the condiments...Above are about tea, following about coffee:Boiling water...Dripping coffee through filter...Pouring in cup...Adding sugar and Milk... 结果是符合预期的。 模板方法模式 vs 策略模式其实大伙儿对模板方法模式和策略模式一直都很容易搞混，因为它们都是来改变一些方法或者策略来实现不同的目的。这里主要主要谈谈它们的不同吧。 [目的]模板方法模式的目的是定义一系列方法的一个轮廓，允许子类选择去实现其中的具体步骤；而策略模式的目的是能够定义一系列可以相互替换的算法。 [侧重点]模板方法模式更加侧重的是一条算法线上的方法点的多样性，线上的可以被替换的点是一定能够被执行的，只不过每一个点的行为可能不一样而已；但是策略模式更加侧重的是整条算法线的替换，它的各种算发现每次只能执行一条。 [方法可见性]模板方法模式中除了模板方法是公开的以外，其他的具体执行的方法点都是对外访问限制的；而策略模式中通常各个方法点都是可以访问到的。 [继承组合]模板方法模式基于的是类的继承思想，子类决定父类的某个抽象方法的具体实现；而策略模式基于的是对象的组合，将不同算法的对象组合起来从而实现算法的相互替换。 总结模板方法模式为我们提供了一组能够替换掉具体方法点的操作思想。其实这种思想在Java的JDK中也有具体的体现，比如Arrays.sort()方法，这个方法里面其实使用的就是模板方法模式，模板方法就是sort()。我们可以利用模板方法提供更为灵活的编码风格。上面最后一点说的[继承组合]不同点其实会有人提出疑问，不是说要多用组合，少用继承嘛？为啥现在还要用？这个问题应该这么来考虑，设计模式的初衷是找到最符合某一类问题的解决方法和模式，这个需要依据具体的情况具体分析，大多数情况下我们还是坚持多用组合，少用继承的思想。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"代理模式","slug":"代理模式","permalink":"http://qinjiangbo.com/tags/代理模式/"}]},{"title":"理解Java中三种代理模式","slug":"understand-three-proxy-design-patterns-in-java","date":"2017-12-24T02:15:02.000Z","updated":"2017-12-24T03:25:10.000Z","comments":true,"path":"understand-three-proxy-design-patterns-in-java.html","link":"","permalink":"http://qinjiangbo.com/understand-three-proxy-design-patterns-in-java.html","excerpt":"","text":"我们前一篇文章已经说明了什么是代理模式，本文就谈谈Java中的三种代理模式。它们分别是静态代理，JDK动态代理，以及Cglib动态代理。 静态代理所谓静态代理，就是经典的代理模式，一个代理者需要对应一个被代理者，如下图所示： 不过缺点也很明显，就是不够灵活，如果需要被代理的对象数量一增加，对于编写代理类的同学来说无疑是灾难。下面给出一个具体的例子： 代理接口类 123456789package com.qinjiangbo.spring.proxy;/** * @date: 21/12/2016 2:08 PM * @author: qinjiangbo@github.io */public interface Service &#123; void fork(String repository);&#125; 被代理类 12345678910111213package com.qinjiangbo.spring.proxy;/** * @date: 21/12/2016 2:11 PM * @author: qinjiangbo@github.io */public class GitService implements Service &#123; @Override public void fork(String repository) &#123; System.out.println(\"fork \" + repository + \" successfully!\"); &#125;&#125; 代理类： 1234567891011121314151617181920212223242526272829303132package com.qinjiangbo.spring.proxy;/** * @date: 21/12/2016 2:22 PM * @author: qinjiangbo@github.io */public class GitStaticProxy implements Service &#123; private GitService gitService; public GitStaticProxy(GitService gitService) &#123; this.gitService = gitService; &#125; @Override public void fork(String repository) &#123; logBefore(); gitService.fork(repository); logAfter(); &#125; private void logBefore() &#123; System.out.println(this.getClass().getName() + \" @@@ \" + \"before fork() invoked!\"); &#125; private void logAfter() &#123; System.out.println(this.getClass().getName() + \" @@@ \" + \"after fork() invoked!\"); &#125;&#125; 测试类： 12345678910111213141516package com.qinjiangbo.spring.proxy;import org.junit.Test;/** * @date: 21/12/2016 2:33 PM * @author: qinjiangbo@github.io */public class GitStaticProxyTest &#123; @Test public void testFork() &#123; Service service = new GitStaticProxy(new GitService()); service.fork(\"tomcat\"); &#125;&#125; 输出结果如下： 123com.qinjiangbo.spring.proxy.GitStaticProxy @@@ before fork() invoked! fork tomcat successfully! com.qinjiangbo.spring.proxy.GitStaticProxy @@@ after fork() invoked! JDK动态代理针对这一种情况，JDK也提出了对应的方式，那就是JDK动态代理，它允许你代理任何实现了某个接口的具体实现类。其实它基于的底层原理还是经典的代理模式，只不过它通过反射的原理动态地创建出了代理类。本质上还是通过实现一个共同的接口来代理对象的行为。 下面给出一个JDK动态代理模式的例子： 接口类还是不变，同上 123456789package com.qinjiangbo.spring.proxy;/** * @date: 21/12/2016 2:08 PM * @author: qinjiangbo@github.io */public interface Service &#123; void fork(String repository);&#125; JDK动态代理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.qinjiangbo.spring.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @date: 22/12/2016 6:30 PM * @author: qinjiangbo@github.io */public class GitJdkProxy implements InvocationHandler &#123; private Object target; public GitJdkProxy(Object target) &#123; this.target = target; &#125; public &lt;T&gt; T getProxy() &#123; return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this ); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; logBefore(); Object result = method.invoke(target, args); logAfter(); return result; &#125; private void logBefore() &#123; System.out.println(this.getClass().getName() + \" @@@ \" + \"before fork() invoked!\"); &#125; private void logAfter() &#123; System.out.println(this.getClass().getName() + \" @@@ \" + \"after fork() invoked!\"); &#125;&#125; 可以看到，它实现了一个InvocationHandler接口，这个接口中有一个方法叫做invoke(Object proxy, Method method, Object[] args)，它是这个代理类的具体执行方法。但是它是如何获取代理的呢？ 1234567public &lt;T&gt; T getProxy() &#123; return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this );&#125; 上面的这部分代码给出了答案，就是通过被代理类实现的接口反射地来创建这个代理类，本质上就是我们前面说到的经典的代理模式，基于共同的实现接口类。 测试类 12345678910111213141516package com.qinjiangbo.spring.proxy;import org.junit.Test;/** * @date: 22/12/2016 6:39 PM * @author: qinjiangbo@github.io */public class GitJdkProxyTest &#123; @Test public void testFork() &#123; Service service = new GitJdkProxy(new GitService()).getProxy(); service.fork(\"tomcat\"); &#125;&#125; 结果输出如下： 123com.qinjiangbo.spring.proxy.GitJdkProxy @@@ before fork() invoked! fork tomcat successfully! com.qinjiangbo.spring.proxy.GitJdkProxy @@@ after fork() invoked! Cglib动态代理Cglib全称是Code Generator Library，字节码生成库。大家也能猜的到它的原理是什么了吧？它是通过字节码技术动态地生成当前类的子类，从而实现对父类的代理。它的底层原理本上是继承，而不是实现。 我们来看看它是怎么实现代理的？不需要实现某个接口，但是为了方便起见，我们还是选择上面提到的GitService来进行这个测试。 12345678910111213141516171819202122232425262728293031323334353637package com.qinjiangbo.spring.proxy;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * @date: 24/12/2016 10:06 PM * @author: qinjiangbo@github.io */public class GitCglibProxy implements MethodInterceptor &#123; public &lt;T&gt; T getProxy(Class&lt;T&gt; clazz) &#123; return (T) Enhancer.create(clazz, this); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; logBefore(); Object result = methodProxy.invokeSuper(o, objects); logAfter(); return result; &#125; private void logBefore() &#123; System.out.println(this.getClass().getName() + \" @@@ \" + \"before fork() invoked!\"); &#125; private void logAfter() &#123; System.out.println(this.getClass().getName() + \" @@@ \" + \"after fork() invoked!\"); &#125;&#125; 在上面的代码中我们可以看到也是存在一个getProxy()方法，抽取出来如下： 123public &lt;T&gt; T getProxy(Class&lt;T&gt; clazz) &#123; return (T) Enhancer.create(clazz, this);&#125; 可以看出它是通过Enhancer.create(clazz, this)来创建这个clazz的子类的，直接在内存中生成一个当前类的子类，然后在intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy)方法中实现对父类行为的代理。 测试类如下： 12345678910111213141516package com.qinjiangbo.spring.proxy;import org.junit.Test;/** * @date: 24/12/2016 10:14 PM * @author: qinjiangbo@github.io */public class GitCglibProxyTest &#123; @Test public void testFork() &#123; Service service = new GitCglibProxy().getProxy(GitService.class); service.fork(\"tomcat\"); &#125;&#125; 测试结果如下： 123com.qinjiangbo.spring.proxy.GitCglibProxy @@@ before fork() invoked! fork tomcat successfully! com.qinjiangbo.spring.proxy.GitCglibProxy @@@ after fork() invoked! JDK动态代理 vs Cglib动态代理关于JDK动态代理和Cglib动态代理两种方式，这里我简单总结一下： [相同] 二者都能够动态地产生某个对象的代理对象，使用起来非常灵活。 [不同] JDK动态代理依据的底层原理是实现一个共同的接口，而Cglib动态代理依据的底层原理是创建某个类的子类。 [不同] 运行性能上JDK和Cglib其实差不多，没有传说中的Cglib比JDK快10倍的差距，至少在最近的几个JDK版本（6，7，8）是这样的，版本越靠后甚至JDK更快一点。 总结关于JDK动态代理和Cglib动态代理到底选择哪一种其实要根据自己的实际情况来确定，其实我所了解到的很多RPC框架比如HSF就使用的是JDK动态代理实现的远端服务请求和响应代理。当然Spring AOP中提供了这两种选择，大家可以在配置文件中自己指定对应的动态代理方式。默认情况下，Spring AOP会采用JDK动态代理来代理对象。当然我们也可以使用&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;来强制使用Cglib动态代理。 参考文献：Cglib 与 JDK动态代理的运行性能比较","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"代理模式","slug":"代理模式","permalink":"http://qinjiangbo.com/tags/代理模式/"}]},{"title":"设计模式学习之代理模式","slug":"design-pattern-proxy","date":"2017-12-22T03:13:34.000Z","updated":"2017-12-23T14:19:46.000Z","comments":true,"path":"design-pattern-proxy.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-proxy.html","excerpt":"","text":"什么是代理模式代理模式(Proxy Design Pattern)为另一个对象提供一个替身或占位符以控制对这个对象的访问。 理解代理模式代理模式所要解决的问题其实是要控制对某一个对象的访问，这句话怎么理解呢？就好比生活中我们需要去做某些事情，比如买房，出国旅游等，由于我们对买房，出国旅游的相关办理手续不是很熟悉，所以我们希望找一个人帮助我们去解决这个事情。委托他代理我们去找相关的机构办理相关的业务。注意，这个时候机构直接面对的对象是我们委托的人，而不是我们本人。虽然很多事情本来是要我们自己完成的，但是代理替我们更加好地完成了。 一些不同的代理控制 远程代理控制访问远程对象 虚拟代理控制访问创建开销大的资源 保护代理基于权限控制对资源的访问 代理模式类图 下面分别介绍类图中各个组件的作用： Proxy和RealSubject都实现了Subject接口，这允许任何客户都可以像处理RealSubject对象一样来处理Proxy对象。 Proxy持有Subject的引用，所以必要时它可以将请求转发给Subject。 RealSubject就是真实对象啦，也就是实际做事的那个对象，Proxy会控制对RealSubject的访问。 在某些例子中，Proxy还会负责RealSubject对象的创建和销毁。客户和RealSubject的交互都必须通过Proxy。因为Proxy和RealSubject实现了想用的接口（Subject），所以任何用到RealSubject的地方都可以用Proxy取代。Proxy也控制了对RealSubject的访问，在某些情况下，我们可能需要这样的控制。这些情况包括RealSubject是远程的对象，RealSubject创建开销大，或者是RealSubject需要被保护。 实例分析-CD封面虚拟代理我们知道使用CD播放机来播放CD的时候我们可以看到每一首歌曲的封面，其实这里面也是使用到了代理模式。现在其实播放CD的很少了，不过很久以前非常流行，那个时候电脑内存小，磁盘速度慢，因此打开一张图需要缓冲一段时间，因此需要在加载的时候给用户提供一个不错的提示，能让他“耐心”地等一会儿。 先展示这个CD封面加载模式的类图结构吧： 简单说明一下系统的逻辑，我们可以看到，代理ProxyImage比真实对象RealImage少了一个方法loadFromDisk()。这个非常重要，说明代理对象最终的目的是为了控制这个对象的访问而不是改变或者新增这个对象的行为。 创建一个Image接口： 12345678910package com.qinjiangbo.proxy;/** * @date: 23/12/2017 9:44 PM * @author: qinjiangbo@github.io * @description: */public interface Image &#123; void display();&#125; 然后先实现RealImage类： 12345678910111213141516171819202122232425package com.qinjiangbo.proxy;/** * @date: 23/12/2017 9:45 PM * @author: qinjiangbo@github.io * @description: */public class RealImage implements Image &#123; private String fileName; public RealImage(String fileName)&#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display() &#123; System.out.println(\"Displaying \" + fileName); &#125; private void loadFromDisk(String fileName)&#123; System.out.println(\"Loading \" + fileName); &#125;&#125; 再实现ProxyImage类： 123456789101112131415161718192021222324package com.qinjiangbo.proxy;/** * @date: 23/12/2017 9:46 PM * @author: qinjiangbo@github.io * @description: */public class ProxyImage implements Image &#123; private RealImage realImage; private String fileName; public ProxyImage(String fileName)&#123; this.fileName = fileName; &#125; @Override public void display() &#123; if(realImage == null)&#123; realImage = new RealImage(fileName); &#125; realImage.display(); &#125;&#125; 实例测试写一个带有main函数的类进行测试： 1234567891011121314151617181920package com.qinjiangbo.proxy;/** * @date: 23/12/2017 9:47 PM * @author: qinjiangbo@github.io * @description: */public class Main &#123; public static void main(String[] args) &#123; Image image = new ProxyImage(\"yesterday-once-more.png\"); // image will be loaded from disk image.display(); // separate line System.out.println(\"==================================\"); // image will be loaded directly image.display(); &#125;&#125; 结果如下： 1234Loading yesterday-once-more.pngDisplaying yesterday-once-more.png==================================Displaying yesterday-once-more.png 装饰者模式 vs 代理模式其实这个两个模式非常容易被人搞混，为什么呢？因为这两个模式在结构上几乎没什么区别。我们再来回顾一下装饰者模式的类图： 可以看到装饰者模式和代理模式都是需要实现一个公共的接口，不管是装饰者与被装饰者还是代理者与被代理者。当然还是有很多不一样的地方的，我们细细道来： 代理模式中只是对真实对象的“代表”，而不是“装饰”对象。 代理模式和装饰者模式虽然结构很像，但是目的意图完全不同。 比较重要的一点是代理模式能够实例化它代理的对象，而装饰者模式不行，它只能从外部传入进来。 远程方法调用Java中的远程方法调用调用就是代理模式的典型代表，我们可以看一下这个过程： 客户端调用某个对象的方法，代理接收到这个请求以后将相关方法、参数等信息通过序列化的方式发送给服务端，服务端收到以后完成本地方法调用。 服务端调用完成以后，返回给本地代理，代理奖将结果进行序列化传递给客户端，客户端收到结果，就像在本地一样，完全无感知。 总结代理模式非常的重要，以至于我后面还会重点写一篇文章来介绍代理模式在Java中的几种典型代表。它在我们的生产中有着非常重要的作用，比如我们最常见的Dubbo，HSF等RPC框架，都是基于代理模式来实现的。掌握好代理模式，我们也能自己实现一个RPC框架，这对于我们理解网络，代理，反射等各种技术要点理解都是有非常重要的提升和锻炼作用的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"代理模式","slug":"代理模式","permalink":"http://qinjiangbo.com/tags/代理模式/"}]},{"title":"Weka机器学习实战之性能度量","slug":"weka-machine-learning-practice-performance-evaluation","date":"2017-12-18T11:57:17.000Z","updated":"2017-12-18T13:32:03.000Z","comments":true,"path":"weka-machine-learning-practice-performance-evaluation.html","link":"","permalink":"http://qinjiangbo.com/weka-machine-learning-practice-performance-evaluation.html","excerpt":"","text":"性能度量(performance measure)反映了任务需求，在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评判结果；这意味着模型的“好坏”是相对的，什么样的模型是好的，不仅仅取决于算法和数据，还决定于任务需求。 这里就不具体展开啦，因为我也才刚开始学习，所以就从查准率、查全率与F1来说吧。错误率和精度虽常用，但是并不能满足所有的任务需求。 查准率、查全率从《机器学习》一书中引用的西瓜例子来说，假定瓜农拉来一车西瓜，我们用训练好的模型对这些西瓜进行判别和预测，显然，我们使用错误率衡量的只是有多少比例的西瓜被判定错误。但是如果我们关心是“挑出的西瓜有多少比例是好瓜”，或者“所有的好瓜中有多少比例被挑选了出来”，这个时候错误率就不够用了，需要使用其它的性能度量来衡量了。 再比如在信息检索中，我们经常会关心“检索出来的信息中有多少条是用户感兴趣的”，“用户感兴趣的信息中有多少被挑选了出来”。查准率(precision)和查全率(recall)更适合用于此类需求的性能度量。 对于二分类问题，可以将样本根据器真实类别与学习器预测的类别的组合划分为真正例（true positive）、假正例（false positive）、真反例（true negative）以及假反例（false negative）四种情形。令TP、FP、TN、FN分别表示其对应的样例数，则显然有TP+FP+TN+FN=样例总数。分类结果的“混淆矩阵”如下： \\begin{array}{c|c|c} \\hline & 正例(预测) & 反例(预测) \\\\ \\hline 正例(实际) & TP & FN \\\\ \\hline 反例(实际) & FP & TN \\\\ \\hline \\end{array}那么我们可能得出查准率P和查全率R的定义分别为： \\begin{equation} P = \\frac{TP}{TP+FP}, \\\\ R = \\frac{TP}{TP+FN}. \\end{equation}查全率和查准率是一对矛盾的度量。一般来说，查准率高时，查全率往往偏低，查全率偏高是，查准率往往偏低。 什么是F1呢？我们从前一节知道查全率和查准率是一对相互矛盾的度量。因此，衡量一个学习器的时候，我们没法非常客观地描述它的性能好坏，它可能分类很准确，但是可能不全面。因此这里引入一个新的度量—-F1。 F_1 = \\frac{2\\times P\\times R}{P+R} = \\frac{2 \\times TP}{样例总数+TP-TN}.说白了写成这个 \\frac{1}{F_1} = \\frac{1}{2} \\cdot \\left(\\frac{1}{P} + \\frac{1}{R}\\right).其实$F_1$就是基于查准率和查全率的一个调和平均数。这里引申一下，$F_\\beta$是加权调和平均数 \\frac{1}{F_\\beta} = \\frac{1}{1+\\beta^2} \\cdot \\left(\\frac{1}{P} + \\frac{\\beta^2}{R}\\right).其中$\\beta&gt;0$度量了查全率和查准率的相对重要性。 其实，在一些应用中，对查准率和查全率的重视程度有所不同，例如在用户商品推荐系统中，我们为了尽可能的打扰用户，更希望推荐内容确实用户感兴趣的，这个时候查准率更重要；而在逃犯信息检索系统中，更希望尽可能减少漏掉逃犯的情况，因此查全率更重要。而$F_1$的一般形式$F_\\beta$，更能让我们表达出对查全率和查准率的不同偏好，它的定义为： F_\\beta=\\frac{(1+\\beta^2)\\times P\\times R}{(\\beta^2\\times P)+R}.如果$\\beta=1$时退化为标准的$F_1$；$\\beta&gt;1$时查全率有更大的影响；$\\beta&lt;1$时查准率有更大的影响。 Weka性能评估以上一节决策树代码为例，我们使用如下代码进行Weka中J48决策树模型性能评价： 12345678910111213Instances instances = loadDataSet(TRAINING_DATASET_FILENAME);Classifier j48 = generateClassifier();// 使用同一个数据集进行交叉验证Evaluation evaluation = new Evaluation(instances);evaluation.crossValidateModel(j48, instances, 10, new Random(1));/** 打印算法的汇总信息 */System.out.println(\"** Decision Tress Evaluation with Datasets **\");System.out.println(evaluation.toSummaryString());System.out.print(\" the expression for the input data as per algorithm is \");System.out.println(j48);System.out.println(evaluation.toMatrixString());System.out.println(evaluation.toClassDetailsString()); 输出的结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657** Decision Tress Evaluation with Datasets **Correctly Classified Instances 661 94.5637 %Incorrectly Classified Instances 38 5.4363 %Kappa statistic 0.8799Mean absolute error 0.0691Root mean squared error 0.2228Relative absolute error 15.2992 %Root relative squared error 46.8739 %Total Number of Instances 699 the expression for the input data as per algorithm is J48 pruned tree------------------uniformity_of_cell_size &lt;= 2| bare_nuclei &lt;= 3: 2 (405.39/2.0)| bare_nuclei &gt; 3| | clump_thickness &lt;= 3: 2 (11.55)| | clump_thickness &gt; 3| | | bland_chromatin &lt;= 2| | | | marginal_adhesion &lt;= 3: 4 (2.0)| | | | marginal_adhesion &gt; 3: 2 (2.0)| | | bland_chromatin &gt; 2: 4 (8.06/0.06)uniformity_of_cell_size &gt; 2| uniformity_of_cell_shape &lt;= 2| | clump_thickness &lt;= 5: 2 (19.0/1.0)| | clump_thickness &gt; 5: 4 (4.0)| uniformity_of_cell_shape &gt; 2| | uniformity_of_cell_size &lt;= 4| | | bare_nuclei &lt;= 2| | | | marginal_adhesion &lt;= 3: 2 (11.41/1.21)| | | | marginal_adhesion &gt; 3: 4 (3.0)| | | bare_nuclei &gt; 2| | | | clump_thickness &lt;= 6| | | | | uniformity_of_cell_size &lt;= 3: 4 (13.0/2.0)| | | | | uniformity_of_cell_size &gt; 3| | | | | | marginal_adhesion &lt;= 5: 2 (5.79/1.0)| | | | | | marginal_adhesion &gt; 5: 4 (5.0)| | | | clump_thickness &gt; 6: 4 (31.79/1.0)| | uniformity_of_cell_size &gt; 4: 4 (177.0/5.0)Number of Leaves : 14Size of the tree : 27=== Confusion Matrix === a b &lt;-- classified as 438 20 | a = 2 18 223 | b = 4=== Detailed Accuracy By Class === TP Rate FP Rate Precision Recall F-Measure MCC ROC Area PRC Area Class 0.956 0.075 0.961 0.956 0.958 0.880 0.955 0.955 2 0.925 0.044 0.918 0.925 0.921 0.880 0.955 0.903 4Weighted Avg. 0.946 0.064 0.946 0.946 0.946 0.880 0.955 0.937 总结从上面的例子可以看到它的F1值达到了0.946，对于这个模型的结果而言，是一个非常不错的效果了。关于后面的MCC，ROC Area以及PRC Area等等评价指标后面再进行学习和介绍。 参考文献：周志华《机器学习》","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"机器学习","slug":"数据科学/机器学习","permalink":"http://qinjiangbo.com/categories/数据科学/机器学习/"}],"tags":[{"name":"Weka","slug":"Weka","permalink":"http://qinjiangbo.com/tags/Weka/"},{"name":"机器学习","slug":"机器学习","permalink":"http://qinjiangbo.com/tags/机器学习/"},{"name":"性能度量","slug":"性能度量","permalink":"http://qinjiangbo.com/tags/性能度量/"}]},{"title":"Tomcat从Nginx服务器获取客户端IP","slug":"tomcat-get-real-client-ip-from-nginx-server","date":"2017-12-11T11:43:39.000Z","updated":"2017-12-12T03:25:22.000Z","comments":true,"path":"tomcat-get-real-client-ip-from-nginx-server.html","link":"","permalink":"http://qinjiangbo.com/tomcat-get-real-client-ip-from-nginx-server.html","excerpt":"","text":"这篇文章的信息量有点多，因为需要从这一点衍生出不少容易踩的坑。先说说标题中的问题，主要是使用了Nginx做反向代理服务器，然后后端Tomcat服务器无法获取用户真实的IP地址，使用httpServletRequest.getRemoteAddr()一直都是127.0.0.1。我们先来说一说为什么是这样？ 为什么getRemoteAddr()一直是127.0.0.1？首先需要明白整体的架构图，如下： 可以看到，用户访问网站的时候是通过Nginx做了一层反向代理，请求被分发到后端的某一台Tomcat服务器。其中，用户请求到Nginx的时候IP地址是202.114.78.189，而Nginx反向代理到Tomcat服务器的时候是127.0.0.1。我们知道在网络中可能会存在一些中间结点，比如代理服务器，而这里的代理服务器就是Nginx。 好，Nginx能获取到用户的IP地址，这个没问题。那么，为什么Tomcat不能获取到用户的真实地址呢？那是因为Tomcat的用户地址就是Nginx啊，Tomcat并没有直接和用户连接，所以这里我们就不难理解，Tomcat通过方法httpServletRequest.getRemoteAddr()只能够获取到Nginx的真实地址，而这个架构图中Nginx服务器和Tomcat服务器又处于同一个局域网，所以为127.0.0.1很正常。那么如何来解决这个问题呢？ 使用Nginx透传用户IP的请求头信息其实前面的几篇文章已经将Nginx的这个配置给出了，如下： 12345678910111213server &#123; listen 80; server_name acs.qinjiangbo.com; access_log /var/log/nginx/access.log main; location / &#123; proxy_pass http://127.0.0.1:8080/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 可以看到上面的例子中使用了proxy_set_header命令，直观意思就是代理设置头方法，正是我们前面提到过的。这里解释一下$host，$remote_addr以及$proxy_add_x_forwared_for三个变量的意思。 $host这个就是客户端的主机名称。 $remote_addr这个就是客户端的主机地址。 $proxy_add_x_forwared_for这个就是在转发请求的时候加上一个X-Forwared_For头信息，而在这个头信息里面会加上客户端的真实IP地址。 这样后端就能通过这几个参数获取到客户端的真实地址了。但是一般我更加喜欢使用第二个配置，就是proxy_set_header X-Real-IP $remote_addr;这里，我需要在Tomcat里面写上一个能够读取X-Real-IP请求头信息的方法，这样就可以拿到真实客户端地址。 问题解决方案使用装饰器模式来封装HttpServletRequest类，可以达到更改某一个方法的行为的目的。也就是说我们需要使用一个能包装HttpServletRequest类的包装类，在这个包装类中，我们重写getRemoteAddr()方法。关于装饰器模式，我不想在这里再一次说了，有需要的可以看一下我的这篇博客《设计模式学习之装饰者模式》，需要注意的一点就是装饰者和被装饰者需要实现共同的接口，不然被装饰者没法被装饰者替换嘛！ 仔细看一下ServletRequest的类图我们就可以知道要使用哪一个类了。类图如下： 我们可以看到，HttpServletRequest接口继承自ServletRequest接口。ServletRequestWrapper类实现了ServletRequest接口，而HttpServletRequestWrapper类继承自ServletRequestWrapper类，所以直观上来看，HttpServletRequestWrapper类是可以作为HttpServletRequest类的装饰者的。我们需要自己写一个类继承自HttpServletRequestWrapper类，然后实现自己的方法逻辑。 实现RequestWrapper类我实现的包装类叫做RequestWrapper，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738package com.qinjiangbo.util;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;/** * @date: 11/12/2017 5:50 PM * @author: qinjiangbo@github.io * @description: * 装饰器类，主要用于处理Tomcat本地获取客户端IP一直都是127.0.0.1的情况 */public class RequestWrapper extends HttpServletRequestWrapper &#123; /** * X-Real-IP头名称 */ private static final String X_REAL_IP = \"X-Real-IP\"; /** * Constructs a request object wrapping the given request. * * @param request * @throws IllegalArgumentException if the request is null */ public RequestWrapper(HttpServletRequest request) &#123; super(request); &#125; @Override public String getRemoteAddr() &#123; // 直接获取X-Real-IP头的信息 String realIP = getHeader(X_REAL_IP); if (realIP != null &amp;&amp; !\"\".equals(realIP)) &#123; return realIP; &#125; return super.getRemoteAddr(); &#125;&#125; 拦截器和过滤器的区别实现了RequestWrapper类以后需要使用到它呀，我们希望原有的httpServletRequest.getRemoteAddr()方法不受影响，因为我这边通过RequestWrapper类已经实现了，希望后面的相同方法都能直接使用，我之前想到过SpringMVC的拦截器，但是这里就引出一个问题，就是过滤器和拦截器的区别。 简单地来说就是拦截器不能改变request和response，而过滤器能改变request和response，也就是说我们只有选择使用过滤器了。在知乎上看到一个很有意思的回答“spring中HttpServletRequestWrapper装饰者模式是如何理解的？ - ScienJus的回答 - 知乎”，我觉得非常经典： 拦截器模式 12345678910void run () &#123; Request request = new Request(); preHandle(request); service(request);&#125;void preHandler(Request request) &#123; //在这里修改Request的引用，不会影响到service方法的request request = new RequestWrapper(request); &#125; 过滤器模式 12345678910void run () &#123; Request request = new Request(); doFilter(request);&#125;void doFilter(Request request) &#123; //在这里修改Request的引用，会影响到service方法的request request = new RequestWrapper(request); service(request);&#125; 可以看到拦截器模式中，preHandle方法修改了request对象的引用，但是service(request)并没有任何变化，因为我们知道方法外的request对象引用并没有发生变化。而在过滤器模式中，doFilter方法也修改了request对象的引用，但是service(request)方法中能够获取到的都是装饰过的request对象。 实现HttpRequestFilter类我们需要实现自己的Filter类，通过这个过滤器将自己加工后的request注入到流程中去，代码如下： 1234567891011121314151617181920212223242526272829303132package com.qinjiangbo.util;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;/** * @date: 11/12/2017 5:57 PM * @author: qinjiangbo@github.io * @description: */public class HttpRequestFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // 替换一下 request = new RequestWrapper((HttpServletRequest) request); // 注入进去了 chain.doFilter(request, response); &#125; @Override public void destroy() &#123; &#125;&#125; web.xml配置注意事项我以为把上面的这些坑踩完了就没事儿了呢，没想到啊，在web.xml中又存在一个坑，就是Filter的URL映射模式。我以为和Servlet一样都是/，没想到这样添加进去并不行。下面系统总结一下过滤器的url-pattern相关问题。 参考了《Web.xml中设置Servlet和Filter时的url-pattern匹配规则》这篇文章相关儿内容，它从两个方面进行了系统的阐述，在这里我们重点关注url-pattern匹配规则。 url-pattern匹配规则url-pattern匹配原则就是找到唯一一个最适合的Servlet。Servlet匹配规则有以下几点： 精确路径匹配，模式/*和/test都存在的时候，会优先匹配/test。 最长路径匹配，模式/test/*和/test/a/*都存在的时候，会优先匹配/test/a/*。 扩展匹配，容器会根据匹配的拓展匹配，比如*.do，/test/*.do是不合法的模式。 默认匹配，如果容器前三中模式都没有匹配上，则会选择默认的Servlet来处理。 对于Filter，不会像Servlet那样只匹配一个Servlet，因为Filter的集合是一个链，所以只会有处理的顺序不同，而不会出现只选择一个Filter。Filter的处理顺序和filter-mapping在web.xml中定义的顺序相同。 最重要的一句话来了，一般在做全路径匹配的时候，Servlet的url-pattern是/，而Filter的url-pattern是/*。注意后面是多了一个*号的，我就是在这个上面踩了大坑。 总结在这一次的踩坑中，收获了很多，了解了Filter和Servlet的一些关联与区别，另外也了解到了如何在不改变原有代码设计的基础上增加新的行为特征。再次重温了一下装饰者模式，收获也很大。 鸣谢-参考文章感谢下面两位提供的一些思路，虽然没法当面感谢，但是还是在此谢过了！ spring中HttpServletRequestWrapper装饰者模式是如何理解的？ - ScienJus的回答 Web.xml中设置Servlet和Filter时的url-pattern匹配规则","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://qinjiangbo.com/tags/Nginx/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://qinjiangbo.com/tags/Tomcat/"},{"name":"getRemoteAddr","slug":"getRemoteAddr","permalink":"http://qinjiangbo.com/tags/getRemoteAddr/"}]},{"title":"Nginx使用Gzip压缩加速访问","slug":"nginx-speed-up-page-visiting-via-gzip-module","date":"2017-12-10T07:13:59.000Z","updated":"2017-12-10T07:38:09.000Z","comments":true,"path":"nginx-speed-up-page-visiting-via-gzip-module.html","link":"","permalink":"http://qinjiangbo.com/nginx-speed-up-page-visiting-via-gzip-module.html","excerpt":"","text":"Nginx作为一款性能非常高的Web服务器，广泛地应用于各大网站的后台。博主的毕设研究项目也使用了Nginx做反向代理，但是网站的首页访问速度非常慢，因此需要进一步开发Nginx的功能，于是就有了本文利用Gzip模块加速了。 Nginx配置使用Gzip压缩页面的时候，需要在http配置区域配置。例子如下： 123456789101112http &#123; # 添加Gzip压缩功能 gzip on; gzip_min_length 1k; gzip_buffers 40 4k; gzip_comp_level 6; gzip_types text/plain text/css application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript application/json; gzip_vary on; gzip_disable msie6; # 后面还有很多配置，在这里就省略了&#125; 配置项解释 gzip on;这个主要是开启gzip，没什么好说的。 gzip_min_length 1k;这个主要是定义需要被压缩文件的最小长度，这里定义的是1k，当然，也可以写成1024。 gzip_buffers 40 4k;这里第一个数表示缓冲的数量，第二个表示每一个缓冲区的大小。 gzip_comp_level 6;关于这个压缩级别，一般是1-9，去Stackoverflow上找了一下大神们的测试，发现4-6级别的效果是最理想的（压缩程度和压缩时间综合）。 gzip_types text/plain ... ;这个就是指定需要被压缩的文件类型，对照MIME类型就可以了。 gzip_vary on;开启后会在头里面加上Vary: Accept-Encoding，主要是给代理服务器开启的。 gzip_disable msie6;这里表示对IE6及以下浏览器不采用压缩，主要是这些浏览器也不支持这些特性。msie6是对IE6以及IE6以下浏览器的一个简称。 查看页面请求 访问https://acs.qinjiangbo.com，打开审查元素，查看网络请求就可以看到了： 总结通过在Nginx上开启Gzip压缩，页面的访问速度提升了约30%，还是很不错的，以前差不多是1.03s左右，现在差不多600~700ms。 如果你的网站静态资源非常多的话，还可以考虑使用Nginx的缓存，这样速度更快！","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://qinjiangbo.com/tags/Nginx/"},{"name":"Gzip","slug":"Gzip","permalink":"http://qinjiangbo.com/tags/Gzip/"}]},{"title":"Quartz定时任务注入Spring服务","slug":"inject-spring-service-bean-in-quartz-job","date":"2017-12-09T15:28:06.000Z","updated":"2017-12-09T17:02:38.000Z","comments":true,"path":"inject-spring-service-bean-in-quartz-job.html","link":"","permalink":"http://qinjiangbo.com/inject-spring-service-bean-in-quartz-job.html","excerpt":"","text":"前两天完成了Quartz和Spring的整合，见《Spring与Quartz整合实践》，但是当时给出的例子中并没有使用Spring的Service来实现一些功能，今天调试的时候问题就出现了。Quartz中的Job居然无法识别Spring的Service Bean对象？！ 在各大论坛找了很久，发现一点问题了。原因是Job类是由Quartz的Job工厂来加载的，而在Spring中，这个Job工厂加载的类和Spring工厂加载的类根本就不是同一类，因此Job里面的注入是失败的。让我们看一下源码。 源码分析先看看org.springframework.scheduling.quartz.SchedulerFactoryBean这个类的jobFactory属性，我们看一下它被设值的地方。 123456789101112131415161718192021222324@Overridepublic void afterPropertiesSet() throws Exception &#123; // 前面的代码太长了，省略掉了 // Get Scheduler instance from SchedulerFactory. try &#123; this.scheduler = createScheduler(schedulerFactory, this.schedulerName); populateSchedulerContext(); if (!this.jobFactorySet &amp;&amp; !(this.scheduler instanceof RemoteScheduler)) &#123; // Use AdaptableJobFactory as default for a local Scheduler, unless when // explicitly given a null value through the \"jobFactory\" bean property. this.jobFactory = new AdaptableJobFactory(); &#125; if (this.jobFactory != null) &#123; if (this.jobFactory instanceof SchedulerContextAware) &#123; ((SchedulerContextAware) this.jobFactory).setSchedulerContext(this.scheduler.getContext()); &#125; this.scheduler.setJobFactory(this.jobFactory); &#125; &#125; // 后面的代码也省略掉了&#125; 我们可以看到中间这一句注释Use AdaptableJobFactory as default for a local Scheduler, unless when explicitly given a null value through the &quot;jobFactory&quot; bean property.意思就是这个SchedulerFactoryBean会默认将AdaptableJobFactory作为它的Job工厂。除非它的jobFactory属性被显式地赋上了一个非空的值。而默认情况下，我们在Spring的XML配置中都不会指定这个属性，所以默认就是这个AdaptableJobFactory了。那我们来看一看这个AdaptableJobFactory具体做了什么工作？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class AdaptableJobFactory implements JobFactory &#123; @Override public Job newJob(TriggerFiredBundle bundle, Scheduler scheduler) throws SchedulerException &#123; try &#123; Object jobObject = createJobInstance(bundle); return adaptJob(jobObject); &#125; catch (Exception ex) &#123; throw new SchedulerException(\"Job instantiation failed\", ex); &#125; &#125; /** * Create an instance of the specified job class. * &lt;p&gt;Can be overridden to post-process the job instance. * @param bundle the TriggerFiredBundle from which the JobDetail * and other info relating to the trigger firing can be obtained * @return the job instance * @throws Exception if job instantiation failed */ protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception &#123; return bundle.getJobDetail().getJobClass().newInstance(); &#125; /** * Adapt the given job object to the Quartz Job interface. * &lt;p&gt;The default implementation supports straight Quartz Jobs * as well as Runnables, which get wrapped in a DelegatingJob. * @param jobObject the original instance of the specified job class * @return the adapted Quartz Job instance * @throws Exception if the given job could not be adapted * @see DelegatingJob */ protected Job adaptJob(Object jobObject) throws Exception &#123; if (jobObject instanceof Job) &#123; return (Job) jobObject; &#125; else if (jobObject instanceof Runnable) &#123; return new DelegatingJob((Runnable) jobObject); &#125; else &#123; throw new IllegalArgumentException(\"Unable to execute job class [\" + jobObject.getClass().getName() + \"]: only [org.quartz.Job] and [java.lang.Runnable] supported.\"); &#125; &#125;&#125; 这个类非常简单，我们重点看一下第二个方法createJobInstance，这个方法里面的工作就是通过反射的方式将我们的Job进行了实例化。但是这个Job并没有被加入到Spring容器中去，所以问题就找到了。现在我们需要做的事情非常简单，就是重载这个方法，将反射实例化的Job对象加入到Spring容器中，而能够做这个工作的是org.springframework.beans.factory.config.AutowireCapableBeanFactory。就是能够让我们平常经常使用@Autowired注解的那个Bean工厂。 问题解决这里我们需要继承这个org.springframework.scheduling.quartz.SpringBeanJobFactory，代码如下（我定义的类取名为AcsJobFactory.java）： 1234567891011121314151617181920212223242526package com.qinjiangbo.scheduler;import org.quartz.spi.TriggerFiredBundle;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.config.AutowireCapableBeanFactory;import org.springframework.scheduling.quartz.SpringBeanJobFactory;/** * @date: 09/12/2017 8:43 PM * @author: qinjiangbo@github.io * @description: */public class AcsJobFactory extends SpringBeanJobFactory &#123; @Autowired private AutowireCapableBeanFactory autowireCapableBeanFactory; @Override protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception &#123; // 调用父类方法 Object jobInstance = super.createJobInstance(bundle); // 注入对象 autowireCapableBeanFactory.autowireBean(jobInstance); return jobInstance; &#125;&#125; 这样Job工厂产生的类就直接进入Spring容器啦，我们就能够直接在Job中获取到Spring容器中的Service的Bean对象。修改Spring的XML配置如下： 12345678910111213141516171819&lt;!-- 全局定时任务调度器 --&gt;&lt;bean class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"&gt; &lt;property name=\"jobDetails\"&gt; &lt;list&gt; &lt;ref bean=\"proxyDumpJob\"/&gt; &lt;ref bean=\"blockDumpJob\"/&gt; &lt;ref bean=\"blockDeleteJob\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"triggers\"&gt; &lt;list&gt; &lt;ref bean=\"proxyDumpTrigger\"/&gt; &lt;ref bean=\"blockDumpTrigger\"/&gt; &lt;ref bean=\"blockDeleteTrigger\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 这里需要指定jobFactory属性的值 --&gt; &lt;property name=\"jobFactory\" ref=\"acsJobFactory\"/&gt;&lt;/bean&gt; 总结今天碰到这个问题也还是挺新鲜的，所以比较感兴趣，没想到发现了这个原因，收获还是很大的。关于Spring容器是如何加载的，Quartz是如何创造Job的，都需要在后面进一步地研究和深挖。能从源码上入手解决某一个问题的时候，才是对这个问题比较深入地理解。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://qinjiangbo.com/tags/Spring/"},{"name":"Quartz","slug":"Quartz","permalink":"http://qinjiangbo.com/tags/Quartz/"},{"name":"Bean注入","slug":"Bean注入","permalink":"http://qinjiangbo.com/tags/Bean注入/"}]},{"title":"利用FreeSSL升级网站系统到HTTPS","slug":"upgrade-website-to-https-via-freessl","date":"2017-12-09T03:47:26.000Z","updated":"2017-12-09T05:07:26.000Z","comments":true,"path":"upgrade-website-to-https-via-freessl.html","link":"","permalink":"http://qinjiangbo.com/upgrade-website-to-https-via-freessl.html","excerpt":"","text":"昨天折腾了一天，终于将自己的Hexo博客成功升级成了HTTPS加密传输协议，使用的是CloudFlare技术支持。但是我的博客系统其实是在Github Pages上进行托管的，因此我并没有手动配置HTTPS支持，而是通过CloudFlare的DNS服务进行反向代理，从而实现HTTPS。所以，我在想啊，对于有服务器的同学而言，前面通过CloudFlare反向代理的方式的确可以，但是使用的如果不是CloudFlare的服务呢？再说明本文的解决方案之前，先说说为什么不能使用CloudFlare的Origin Certificate。 CloudFlare的Origin Certficate是什么？我在CloudFlare的Crypto菜单下面发现了一个新大陆，就是Origin Certificate，满心欢喜的下载了证书，但是部署到自己的服务器以后，发现通过外网（不走CloudFlare的反向代理，只解析DNS）访问就会存在一个问题，总是会报一个错：certificate signed by unknown authority，这个就让我很郁闷了，后来发现这个证书有效期居然可以到十五年。 后来发现这个证书和我们自己申请的证书不一样，具体表现在这个证书仅仅只是为了配合CloudFlare的反向代理提供HTTPS服务。还记得我昨天写到的CloudFlare的HTTPS服务有三种类型，Flexible，Full SSL以及Full SSL (strict)吗，这个源站证书（Origin Certificate）就是为了配合这其中后两种类型的，因此不适用于通过外网直接访问源站的情形。 FreeSSL是一个好的解决方案找了一下，有人说Let’s Encrypt不错，我也看了一些文章，大家都觉得这个挺好的，我也觉得不错。不过今天我们的主题是FreeSSL，所以就单纯聊聊通过FreeSSL如何实现全站的HTTPS加密访问。 进入官网注册FreeSSL官网地址为https://freessl.org，进入以后，输入自己的邮箱注册。 然后它就会发一封激活邮件到你的邮箱，点击链接激活之后就自动登录了。 生成证书输入你的域名，以我的为例，我的是一个子域名acs.qinjiangbo.com，另外建议选择亚洲诚信(Trust Asia)，因为有效期为一年，而Let’s Encrypt是三个月。然后就跳转到了这个页面： 和我的配置保持一致就好了，然后就要到你的DNS域名解析服务商那里添加TXT类型的解析。我之前已经迁到CloudFlare上面来了，所以就在CloudFlare上直接修改了；如果你的是在阿里云或者腾讯云上面等，都是一样的操作。 验证并下载证书一般来说，等待一两分钟就可以验证并下载了。下载结果页如下： Nginx服务器配置下载下来的证书有两个文件，一个是full_chain.pem，另一个是private.key，这两个文件非常重要，千万不要搞丢了。我们进入服务器，将这两个文件放在/etc/https/目录下，这个https目录是自己创建的，当然你也可以取别的名字。 打开你的Nginx服务配置，在对应虚拟主机配置下面添加以下代码即可： 123456789101112131415161718192021222324# ACS系统配置server &#123; listen 80; listen 443; ssl on; ssl_certificate /etc/https/full_chain.pem; ssl_certificate_key /etc/https/private.key; server_name acs.qinjiangbo.com; access_log /var/log/nginx/access.log main; location / &#123; proxy_pass http://127.0.0.1:8080/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; # 重定向non-https流量到https if ($scheme != \"https\") &#123; return 301 https://$host$request_uri; &#125;&#125; 重启服务器重启Nginx服务器，就可以看到网站已经可以进行HTTPS访问了。 1nginx -s reload 访问https://acs.qinjiangbo.com可以看到页面上已经有小绿锁了。 总结关于HTTPS在本站上面的配置就总结到这里。Apache和IIS的方式和Nginx非常类似，就不多说了。关于使用Let’s Encrypt加密的方式以后有时间再介绍吧，因为和这个差不多。同时也欢迎大家使用爬虫来爬取这个网站，看看你能坚持多久？！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"http://qinjiangbo.com/tags/HTTPS/"},{"name":"FreeSSL","slug":"FreeSSL","permalink":"http://qinjiangbo.com/tags/FreeSSL/"},{"name":"网站","slug":"网站","permalink":"http://qinjiangbo.com/tags/网站/"}]},{"title":"Hexo博客系统支持HTTPS协议","slug":"hexo-blog-system-supports-https-protocol","date":"2017-12-08T12:28:01.000Z","updated":"2017-12-08T14:10:53.000Z","comments":true,"path":"hexo-blog-system-supports-https-protocol.html","link":"","permalink":"http://qinjiangbo.com/hexo-blog-system-supports-https-protocol.html","excerpt":"","text":"随着Google针对HTTPS协议的大力推广，越来越多的企业和个人开始使用HTTPS协议作为其网站的主要传输协议。博主也曾经考虑过使用HTTPS协议来实现博客内容的安全传输（防止运营商DNS劫持给我乱加一些广告），但是没有找到合适的方式。一个偶然的机会，发现有部分同学使用的是Hexo+Github的架构，但是使用的是HTTPS！！！怎么做到的？！带着这些疑问，我寻找着答案，其中一个最简单的解决方案就是使用CloudFlare提供的服务来实现HTTPS加密。 注册CloudFlare关于如何使用Github来搭建Hexo博客系统不在本文的讨论范围之内，如果你感兴趣的话可以访问这篇文章https://qinjiangbo.com/github-page-customed-domain-and-cdn.html看一看。好，首先访问CloudFlare的官网地址https://www.cloudflare.com如下： 注册成功以后，需要做一件事就是修改DNS配置。这个时候你需要回到你的域名服务商那里修改，我的域名是在万网上买的，所以去阿里云修改。 修改域名DNS服务器在修改域名DNS服务器之前，我们需要查看一下自己的CloudFlare给我们分配的DNS服务器地址是什么？点击CloudFlare菜单栏中的DNS菜单，往下找就可以看到分配的DNS服务器地址，一般是有两个： 12beth.ns.cloudflare.comhugh.ns.cloudflare.com 而阿里云默认的DNS服务器地址为： 12dns9.hichina.comdns10.hichina.com 修改完之后的情况如下： 添加域名解析我们需要在CloudFlare的DNS中添加我们域名的解析，一般是添加两个，一个是有www的，一个是没有的。如下： 需要注意的是这个解析的类型一定要是带橙色云团的，而不是灰色的。关于这两个类型的区别很简单：灰色的表示单纯地进行DNS解析就和阿里云的功能一样，但是橙色的表示除了进行DNS解析以外还进行CDN反向代理，也就是进行HTTPS加密。 添加SSL证书我们需要点击CloudFlare菜单栏中的Crypto进入配置SSL整数，一般来说默认就是Universal类型的。我们在设置SSL类型的时候，需要选择Flexible类型。关于SSL类型，一共有以下几种： Off: 一般来说，还有这个默认选项，也就是说访问者不会通过HTTPS来访问网站，任何HTTPS请求都会被重定向为HTTP请求。 Flexible SSL: 这个选项的意思就是你不能在你自己的服务器上配置HTTPS协议支持。访客访问你的网站是通过HTTPS协议的，但是CloudFlare反向代理将请求转发到你的源服务器上的时候使用的是HTTP协议。 Full SSL: 你的源网站是支持HTTPS的，安装的证书可能是不匹配你的域名或者证书可能是自签名的，这都是可以的。也就是说访客连接到CloudFlare以及CloudFlare连接到你的源网站使用的都是HTTPS协议。 Full SSL (strict): 这一个要求更严格了，你的源网站必须使用没有过期的可信的CA或者是CloudFlare提供的CA证书。CloudFlare会通过HTTPS协议来连接你的源网站，和Full SSL的区别就是Full SSL (strict) 会校验你的证书有效性，而Full SSL则不会校验。 设置PageRules点击CloudFlare菜单栏的Page Rules，就可以添加规则了，免费用户好像只能添加三条规则，不过我们可以使用通配符来表示更多的情况。我的规则如下： 总结完成以上的设置之后就需要静静地等待SSL配置生效，博主等了18个小时（免费用户最多可能等到24小时，而付费用户是需要15分钟），终于可以访问了。网上看，啦啦啦，有小绿锁了！ 注意事项：如果你的网站不想在SSL生效期间不能访问的话（一般会报一个SSL证书不匹配的错误），你可以将你的域名解析的地方更改为灰色云团就可以啦，更改以后等一两分钟就可以啦，通过以后再改为橙色云团。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"CloudFlare","slug":"CloudFlare","permalink":"http://qinjiangbo.com/tags/CloudFlare/"},{"name":"Hexo","slug":"Hexo","permalink":"http://qinjiangbo.com/tags/Hexo/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://qinjiangbo.com/tags/HTTPS/"}]},{"title":"Spring与Quartz整合实践","slug":"integration-of-spring-and-quartz","date":"2017-12-07T17:04:05.000Z","updated":"2017-12-08T14:42:37.000Z","comments":true,"path":"integration-of-spring-and-quartz.html","link":"","permalink":"http://qinjiangbo.com/integration-of-spring-and-quartz.html","excerpt":"","text":"什么是Quartz?Quartz是一款基于Java语言的作业调度框架。一般用来创建或简单或复杂的调度时间表，执行Java下任意数量的作业。 可以通过CronTrigger定义Quartz的调度时间表（例如0 0 12 ? * WED表示“每周三上午12：00”）。此外，时间表也可以通过SimpleTrigger，由Date定义触发的开始时间、毫秒的时间间隔和重复计数（例如“在下周三12：00，然后每隔10秒、执行5次”）。可以使用Calender定义例外的日程（例如“没有周末和节假日”）。 作业可以是实现了Job接口任意的Java类。作业监听器（JobListener）和触发器监听器（TriggerListener）通知作业的执行（和其他事件）。作业及其触发器可以被持久化。Quartz一般用于企业级应用程序，以支持工作流、系统管理（维护）活动，并在应用程序中提供实时的服务。Quartz还支持集群。 Quartz基本元素从上面的介绍可以看到，Quartz主要由三个部分组成，分别是调度器，作业详情以及触发器。 调度器调度器(Scheduler)的作用主要是通过作业详情(JobDetail)和触发器(Trigger)来执行特定的任务。调度器的生命周期从它的start()开始，一直到shutdown()方法结束。在使用调度器的时候，必须先执行start()方法，才能够开始任务的调度。当然了，在Spring当中，已经帮我们封装好了，所以直接声明一个调度器类就好了。 作业详情先说说作业(Job)吧，作业就是我们调度器需要执行的具体任务逻辑。在实际的代码中就是指实现了org.quartz.Job接口的任何类。orf.quartz.Job接口只有一个方法void execute(JobExecutionContext context)，因此任务调度时候执行的就是execute方法的逻辑。 那么作业详情(JobDetail)又是什么呢？作业详情其实是对作业的一个封装，会指定它的名称(name)和组别(group)。这两个属性非常重要，因为这两个属性是这个作业详情在整个调度系统中的唯一编号。我们可以通过作业详情向作业中传入一些数据(JobDataMap)，在运行时能通过execute方法的context参数获取到。context就是上下文参数，用于获取作业详情传递过来的数据。 1234567891011121314151617181920212223242526// define the job and tie it to our DumbJob classJobDetail job = newJob(DumbJob.class) .withIdentity(\"myJob\", \"group1\") // name \"myJob\", group \"group1\" .usingJobData(\"jobSays\", \"Hello World!\") .usingJobData(\"myFloatValue\", 3.141f) .build(); public class DumbJob implements Job &#123; public DumbJob() &#123; &#125; public void execute(JobExecutionContext context) throws JobExecutionException &#123; JobKey key = context.getJobDetail().getKey(); JobDataMap dataMap = context.getJobDetail().getJobDataMap(); String jobSays = dataMap.getString(\"jobSays\"); float myFloatValue = dataMap.getFloat(\"myFloatValue\"); System.err.println(\"Instance \" + key + \" of DumbJob says: \" + jobSays + \", and val is: \" + myFloatValue); &#125;&#125; 触发器触发器(Trigger)是什么呢？其实在传统的Java调度系统中，我们直接在调度器中指定执行时间，执行频率就可以了。但是在Quartz中，开发者将调度器的执行和触发两个步骤解耦了。这样做的好处是可以更加灵活地配置各种需求的任务。所以，触发器只是一个引起任务执行的条件。 触发器主要用于指定任务执行的时间，频率以及重复次数等等。 123456789101112HolidayCalendar cal = new HolidayCalendar();cal.addExcludedDate( someDate );cal.addExcludedDate( someOtherDate );sched.addCalendar(\"myHolidays\", cal, false);Trigger t = newTrigger() .withIdentity(\"myTrigger\") .forJob(\"myJob\") .withSchedule(dailyAtHourAndMinute(9, 30)) // execute job daily at 9:30 .modifiedByCalendar(\"myHolidays\") // but not on holidays .build(); Quartz使用方式下面给出一个Quartz的使用例子，纯Java客户端实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.qinjiangbo.scheduler;import org.quartz.JobDetail;import org.quartz.Scheduler;import org.quartz.SchedulerException;import org.quartz.Trigger;import org.quartz.impl.StdSchedulerFactory;import static org.quartz.JobBuilder.newJob;import static org.quartz.SimpleScheduleBuilder.simpleSchedule;import static org.quartz.TriggerBuilder.newTrigger;/** * @date: 06/12/2017 9:40 PM * @author: qinjiangbo@github.io * @description: */public class ProxyDumpJob &#123; // 先做一个Demo public static void main(String[] args) &#123; try &#123; Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); scheduler.start(); // 写一些逻辑 JobDetail jobDetail = newJob(HelloJob.class) .withIdentity(\"firstJob\", \"qinjiangbo\") .build(); // 设置触发器 Trigger trigger = newTrigger() .withIdentity(\"firstTrigger\", \"qinjiangbo\") .startNow() .withSchedule(simpleSchedule() .withIntervalInSeconds(5) .repeatForever()) .build(); // 启动定时任务 scheduler.scheduleJob(jobDetail, trigger); &#125; catch (SchedulerException e) &#123; e.printStackTrace(); &#125; &#125;&#125; HelloJob.java 123456789101112131415161718192021package com.qinjiangbo.scheduler;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import org.quartz.JobKey;import java.util.Date;/** * @date: 07/12/2017 10:44 AM * @author: qinjiangbo@github.io * @description: */public class HelloJob implements Job &#123; @Override public void execute(JobExecutionContext context) throws JobExecutionException &#123; System.out.println(new Date().toString()); &#125;&#125; 与Spring集成和Spring的集成和这个过程比较相似，只不过作业详情和触发器的实例化都是通过Spring的Bean工厂实现的了。 maven配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!-- 定时任务工具 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring框架 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;&lt;/dependency&gt; Quartz的Spring配置创建spring-quartz.xml文件，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- IP代理Dump任务 --&gt; &lt;bean id=\"proxyDumpJob\" class=\"org.springframework.scheduling.quartz.JobDetailFactoryBean\"&gt; &lt;property name=\"name\" value=\"firstJob\"/&gt; &lt;property name=\"group\" value=\"acs\"/&gt; &lt;!-- 组名可以随便取 --&gt; &lt;property name=\"durability\" value=\"true\"/&gt; &lt;property name=\"jobClass\" value=\"com.qinjiangbo.scheduler.AcsProxyDumpJob\"/&gt; &lt;/bean&gt; &lt;!-- IP代理Dump任务触发器 --&gt; &lt;bean id=\"proxyDumpTrigger\" class=\"org.springframework.scheduling.quartz.SimpleTriggerFactoryBean\"&gt; &lt;property name=\"name\" value=\"firstTrigger\"/&gt; &lt;property name=\"group\" value=\"acs\"/&gt; &lt;property name=\"startTime\" ref=\"now\"/&gt; &lt;!-- 注意：单位是毫秒 --&gt; &lt;property name=\"repeatInterval\" value=\"5000\"/&gt; &lt;property name=\"jobDetail\" ref=\"proxyDumpJob\"/&gt; &lt;/bean&gt; &lt;bean id=\"now\" class=\"java.util.Date\"/&gt; &lt;!-- 全局定时任务调度器 --&gt; &lt;bean class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"&gt; &lt;property name=\"jobDetails\"&gt; &lt;list&gt; &lt;ref bean=\"proxyDumpJob\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"triggers\"&gt; &lt;list&gt; &lt;ref bean=\"proxyDumpTrigger\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 作业类AcsProxyDumpJob.java 1234567891011121314151617181920package com.qinjiangbo.scheduler;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import java.util.Date;/** * @date: 07/12/2017 10:44 AM * @author: qinjiangbo@github.io * @description: */public class AcsProxyDumpJob implements Job &#123; @Override public void execute(JobExecutionContext context) throws JobExecutionException &#123; System.out.println(new Date().toString()); &#125;&#125; 任务执行情况启动tomcat服务器，可以看到控制台的情况如下： 1234567891011...2017-12-08 13:40:55 [INFO] - org.springframework.scheduling.quartz.SchedulerFactoryBean - SchedulerFactoryBean.java(645) - Starting Quartz Scheduler now2017-12-08 13:40:55 [INFO] - org.quartz.core.QuartzScheduler - QuartzScheduler.java(547) - Scheduler org.springframework.scheduling.quartz.SchedulerFactoryBean#0_$_NON_CLUSTERED started.Fri Dec 08 13:40:55 CST 20172017-12-08 13:40:55 [INFO] - org.springframework.web.servlet.DispatcherServlet - FrameworkServlet.java(508) - FrameworkServlet &apos;servlet&apos;: initialization completed in 9163 ms08-Dec-2017 13:40:57.192 INFO [http-nio-8080-exec-2] org.apache.tomcat.util.http.parser.Cookie.logInvalidHeader A cookie header was received [1512543852,1512550588,1512666728; Hm_lpvt_a0e256d0086924d62a9116fdbab18bdf=1512668909; __cfduid=dcd329b1d40b3086b0603537f1e8222d81512702662] that contained an invalid cookie. That cookie will be ignored.Note: further occurrences of this error will be logged at DEBUG level.Fri Dec 08 13:41:00 CST 2017Fri Dec 08 13:41:05 CST 2017Fri Dec 08 13:41:10 CST 2017...... 可以看到项目成功启动，任务也按照预先设定的成功执行。 总结Quartz作为一款非常优秀的调度框架提供了非常丰富的功能。但是也存在一些先天的不足，比如没有直接提供监控台，而阿里的SchedulerX做的比这个要好，目前已经在阿里云上推出了相关的产品，感兴趣的可以去了解一下。关于Quartz的系统架构以及Quartz和Spring Scheduling以及Java的调度系统等等这些调度器之间的区别，我会在后面的文章中陆续写到，欢迎大家持续关注。 参考资料：https://en.wikipedia.org/wiki/Quartz_(scheduler)","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://qinjiangbo.com/tags/Spring/"},{"name":"Quartz","slug":"Quartz","permalink":"http://qinjiangbo.com/tags/Quartz/"},{"name":"整合","slug":"整合","permalink":"http://qinjiangbo.com/tags/整合/"}]},{"title":"Weka机器学习实战之决策树","slug":"weka-machine-learning-practice-decision-tree","date":"2017-12-04T13:39:18.000Z","updated":"2017-12-18T11:53:28.000Z","comments":true,"path":"weka-machine-learning-practice-decision-tree.html","link":"","permalink":"http://qinjiangbo.com/weka-machine-learning-practice-decision-tree.html","excerpt":"","text":"之前读了周志华的《机器学习》，学习了决策树这一章的相关内容，觉得收获很大。尤其是作者提出的这个数据集，以它为例进行了非常精彩的论述。本文决定也采用《机器学习》书上的例子—-西瓜数据集。 数据集介绍西瓜数据集是作者自己独创的一个数据集，也是书的封面插图。数据集可以描述如下： 训练集12345678910青绿,蜷缩,浊响,清晰,凹陷,硬滑,是乌黑,蜷缩,沉闷,清晰,凹陷,硬滑,是乌黑,蜷缩,浊响,清晰,凹陷,硬滑,是青绿,稍蜷,浊响,清晰,稍凹,软粘,是乌黑,稍蜷,浊响,稍糊,稍凹,软粘,是青绿,硬挺,清脆,清晰,平坦,软粘,否浅白,稍蜷,沉闷,稍糊,凹陷,硬滑,否乌黑,稍蜷,浊响,清晰,稍凹,软粘,否浅白,蜷缩,浊响,模糊,平坦,硬滑,否青绿,蜷缩,沉闷,稍糊,稍凹,硬滑,否 测试集1234567青绿,蜷缩,沉闷,清晰,凹陷,硬滑,是浅白,蜷缩,浊响,清晰,凹陷,硬滑,是乌黑,稍蜷,浊响,清晰,稍凹,硬滑,是乌黑,稍蜷,沉闷,稍糊,稍凹,硬滑,否浅白,硬挺,清脆,模糊,平坦,硬滑,否浅白,蜷缩,浊响,模糊,平坦,软粘,否青绿,稍蜷,浊响,稍糊,凹陷,硬滑,否 数据集处理关于数据集的处理，还是和我们之前的套路一样，需要将它转换为Weka能够处理的格式—-arff文件。所以，我们需要在文件上加上这一个头，以便于Weka中的决策树实现J48训练器能够识别这个数据集。 数据集头部123456789@RELATION watermelon@ATTRIBUTE 色泽 &#123;青绿,乌黑,浅白&#125;@ATTRIBUTE 根蒂 &#123;蜷缩,稍蜷,硬挺&#125;@ATTRIBUTE 敲声 &#123;浊响,沉闷,清脆&#125;@ATTRIBUTE 纹理 &#123;清晰,稍糊,模糊&#125;@ATTRIBUTE 脐部 &#123;凹陷,稍凹,平坦&#125;@ATTRIBUTE 触感 &#123;硬滑,软粘&#125;@ATTRIBUTE class &#123;是,否&#125; 注意数据部分前面别忘记添加@DATA啦。 关于属性类型为String报错的问题我之前的写法是下面这样的： 123456789@RELATION watermelon@ATTRIBUTE 色泽 String@ATTRIBUTE 根蒂 String@ATTRIBUTE 敲声 String@ATTRIBUTE 纹理 String@ATTRIBUTE 脐部 String@ATTRIBUTE 触感 String@ATTRIBUTE class &#123;是,否&#125; 结果报错说不能识别String类型的属性，我就很郁闷了[老鸟别喷~]，排查了很久才发现这个地方应该是Nominal类型，也就是分类类型。其实大家可以看到这些属性的值都是在几个值之间切换的，所以它们是相对固定的，切记不要写成了String类型。 训练模型模型的训练我们使用的是J48分类器实现的，J48是是C4.5算法在Weka中的实现。针对ID3算法的不足做了很多优化。具体使用代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.qinjiangbo.algorithms.decisiontree;import com.google.common.collect.Lists;import com.google.common.io.Resources;import weka.classifiers.Classifier;import weka.classifiers.Evaluation;import weka.classifiers.trees.J48;import weka.core.DenseInstance;import weka.core.Instance;import weka.core.Instances;import weka.core.converters.ArffLoader;import java.io.File;import java.io.IOException;import java.net.URL;import java.util.List;import java.util.Random;/** * @date: 03/12/2017 9:52 PM * @author: qinjiangbo@github.io * @description: * 本类主要用于学习《机器学习》西瓜数据集的处理和预测 */public class WatermelonClassifier &#123; /** * 训练数据集和测试数据集是相同的，用于后面交叉验证 */ private static final String TRAINING_DATASET_FILENAME = \"decisiontree/watermelon-training.arff\"; private static final String TESTING_DATASET_FILENAME = \"decisiontree/watermelon-test.arff\"; public static void main(String[] args) &#123; try &#123; Instances instances = loadDataSet(TRAINING_DATASET_FILENAME); // 青绿,蜷缩,沉闷,清晰,凹陷,硬滑 [是] // 浅白,蜷缩,浊响,模糊,平坦,软粘 [否] List&lt;String&gt; data = Lists.newArrayList(\"浅白\",\"蜷缩\",\"浊响\",\"模糊\",\"平坦\",\"软粘\"); // 进行预测 String classOfData = predict(data, instances); System.out.println(\"class of data is: \" + classOfData); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 加载数据集 * @param fileName 训练集文件地址 * @return */ public static Instances loadDataSet(String fileName) &#123; Instances instances = null; try &#123; URL url = Resources.getResource(fileName); File file = new File(url.getPath()); ArffLoader arffLoader = new ArffLoader(); arffLoader.setFile(file); instances = arffLoader.getDataSet(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; instances.setClassIndex(instances.numAttributes()-1); return instances; &#125; /** * 训练生成分类器 * @return */ public static Classifier generateClassifier() throws Exception&#123; Instances instances = loadDataSet(TRAINING_DATASET_FILENAME); // 初始化分类器 Classifier j48 = new J48(); // 训练该数据集 j48.buildClassifier(instances); return j48; &#125; /** * 打印出当前数据最可能所属的类别 * @return */ public static String predict(List&lt;String&gt; data, Instances trainingSet) throws Exception&#123; Classifier j48 = generateClassifier(); // 创建Instance Instance instance = new DenseInstance(trainingSet.numAttributes()); // 分别添加待预测特征值 for (int i = 0; i &lt; data.size(); i++) &#123; instance.setValue(trainingSet.attribute(i), data.get(i)); &#125; // 需要能访问数据集 instance.setDataset(trainingSet); // 得出最可能所属类别 int index = (int)j48.classifyInstance(instance); return trainingSet.classAttribute().value(index); &#125;&#125; 测试模型选择了两个实例来对模型进行测试，其实上面的代码已经给出了，分别是青绿,蜷缩,沉闷,清晰,凹陷,硬滑 [是]和浅白,蜷缩,浊响,模糊,平坦,软粘 [否]。 第一组测试数据实例：青绿,蜷缩,沉闷,清晰,凹陷,硬滑 [是]，输出结果如下： 1class of data is: 是 第二组测试数据实例：浅白,蜷缩,浊响,模糊,平坦,软粘 [否]，输出结果如下： 1class of data is: 否 总结这个例子比较简单，主要是利用决策树对数据进行预测和分类，从这个实践的过程能学习到数据的预处理和一些评价的标准，比如准确率和召回率等等，关于这两部分后面的文章中我会进行对应地介绍。机器学习能帮助我们解决很多我们常规方式解决不了的东西。","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"机器学习","slug":"数据科学/机器学习","permalink":"http://qinjiangbo.com/categories/数据科学/机器学习/"}],"tags":[{"name":"Weka","slug":"Weka","permalink":"http://qinjiangbo.com/tags/Weka/"},{"name":"机器学习","slug":"机器学习","permalink":"http://qinjiangbo.com/tags/机器学习/"},{"name":"决策树","slug":"决策树","permalink":"http://qinjiangbo.com/tags/决策树/"}]},{"title":"Weka机器学习实战之KMeans","slug":"weka-machine-learning-practice-kmeans","date":"2017-12-02T07:29:58.000Z","updated":"2017-12-02T08:20:58.000Z","comments":true,"path":"weka-machine-learning-practice-kmeans.html","link":"","permalink":"http://qinjiangbo.com/weka-machine-learning-practice-kmeans.html","excerpt":"","text":"本文重点讲述如何使用Weka API中的Kmeans算法进行实践。这一篇是所有机器学习文章里面的第一篇，因此选择的是Kmeans算法来进行实践。废话不多说，开始吧！ 实践环境这里的环境主要是介绍使用的Maven包，pom文件如下： 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;nz.ac.waikato.cms.weka&lt;/groupId&gt; &lt;artifactId&gt;weka-stable&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;22.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 选择使用Google的Guava包是因为我们在载入数据集的时候会需要Guava工具包帮我们从classpath（这里是resources目录）下面直接载入进来。 准备数据集针对Kmeans算法，我选择的是比较经典的IRIS数据集。下载地址是：https://archive.ics.uci.edu/ml/datasets/iris。部分片段如下： 123456789105.1,3.5,1.4,0.2,Iris-setosa4.9,3.0,1.4,0.2,Iris-setosa4.7,3.2,1.3,0.2,Iris-setosa4.6,3.1,1.5,0.2,Iris-setosa5.0,3.6,1.4,0.2,Iris-setosa5.4,3.9,1.7,0.4,Iris-setosa4.6,3.4,1.4,0.3,Iris-setosa5.0,3.4,1.5,0.2,Iris-setosa4.4,2.9,1.4,0.2,Iris-setosa4.9,3.1,1.5,0.1,Iris-setosa 可以看到它是一种csv（Comma Separated Value）文件。但是我们前面讲到过，使用Weka处理数据的时候通常需要对它进行一下转换，转换为arff文件。因此，我们需要对数据集进行预处理。预处理的过程非常简单，由于数据集不大，所以直接在数据集里面添加一些元信息即可。 12345678910111213141516@RELATION iris@ATTRIBUTE sepal_length NUMERIC@ATTRIBUTE sepal_width NUMERIC@ATTRIBUTE petal_length NUMERIC@ATTRIBUTE petal_width NUMERIC@ATTRIBUTE class &#123;Iris-setosa,Iris-versicolor,Iris-virginica&#125;@DATA5.1,3.5,1.4,0.2,Iris-setosa4.9,3.0,1.4,0.2,Iris-setosa4.7,3.2,1.3,0.2,Iris-setosa4.6,3.1,1.5,0.2,Iris-setosa5.0,3.6,1.4,0.2,Iris-setosa5.4,3.9,1.7,0.4,Iris-setosa4.6,3.4,1.4,0.3,Iris-setosa Kmeans算法实践完整的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.qinjiangbo.algorithms.kmeans;import com.google.common.io.Resources;import weka.clusterers.SimpleKMeans;import weka.core.Instances;import weka.core.converters.ArffLoader;import java.io.File;import java.io.IOException;import java.net.URL;/** * @date: 27/11/2017 6:58 PM * @author: qinjiangbo@github.io * @description: * 使用KMeans算法将Iris数据集进行聚类 */public class KmeansCluster &#123; /** * 训练数据集文件地址 */ private static final String TRAINING_DATASET_FILENAME = \"kmeans/iris.arff\"; public static void main(String[] args) &#123; try &#123; // 进行聚类 process(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 加载数据集 * @param fileName 文件路径 * @return */ public static Instances loadDataSet(String fileName) &#123; Instances instances = null; URL url = Resources.getResource(fileName); File file = new File(url.getPath()); ArffLoader loader = new ArffLoader(); try &#123; loader.setFile(file); instances = loader.getDataSet(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return instances; &#125; /** * 操作数据集 * @throws Exception */ public static void process() throws Exception &#123; SimpleKMeans kMeans = generateClassifier(); // 打印聚类结果 System.out.println(kMeans.preserveInstancesOrderTipText()); System.out.println(kMeans.toString()); &#125; /** * 训练生成分类器 * @return * @throws Exception */ public static SimpleKMeans generateClassifier() throws Exception &#123; Instances instances = loadDataSet(TRAINING_DATASET_FILENAME); // 初始化聚类器 SimpleKMeans kMeans = new SimpleKMeans(); // 设置聚类要得到的簇数 kMeans.setNumClusters(3); // 开始进行聚类 kMeans.buildClusterer(instances); return kMeans; &#125;&#125; 关于代码中的步骤我就不一一介绍了，因为注释已经解释的很详细了，不过一定要记住操作的顺序： 加载数据集 初始化聚类器对象 开始聚类 打印聚类结果 Kmeans运行结果将以上的代码拷贝到你的编辑器中，编译执行你就能看到以下结果： 1234567891011121314151617181920212223242526Preserve order of instances.kMeans======Number of iterations: 3Within cluster sum of squared errors: 7.817456892309574Initial starting points (random):Cluster 0: 6.1,2.9,4.7,1.4,Iris-versicolorCluster 1: 6.2,2.9,4.3,1.3,Iris-versicolorCluster 2: 6.9,3.1,5.1,2.3,Iris-virginicaMissing values globally replaced with mean/modeFinal cluster centroids: Cluster#Attribute Full Data 0 1 2 (150.0) (50.0) (50.0) (50.0)==================================================================================sepal_length 5.8433 5.936 5.006 6.588sepal_width 3.054 2.77 3.418 2.974petal_length 3.7587 4.26 1.464 5.552petal_width 1.1987 1.326 0.244 2.026class Iris-setosa Iris-versicolor Iris-setosa Iris-virginica 总结如果你得到了上面的运行结果，说明你的代码运行完全正确。通过本文章的学习，我相信你已经掌握了Weka中基本的数据集处理及训练流程，后面再结合其它的算法能更加深入地理解机器学习的套路。","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"机器学习","slug":"数据科学/机器学习","permalink":"http://qinjiangbo.com/categories/数据科学/机器学习/"}],"tags":[{"name":"Weka","slug":"Weka","permalink":"http://qinjiangbo.com/tags/Weka/"},{"name":"机器学习","slug":"机器学习","permalink":"http://qinjiangbo.com/tags/机器学习/"},{"name":"Kmeans","slug":"Kmeans","permalink":"http://qinjiangbo.com/tags/Kmeans/"}]},{"title":"Weka数据集文件格式ARFF","slug":"dataset-format-of-weka-ARFF","date":"2017-11-28T05:21:22.000Z","updated":"2017-11-28T09:19:42.000Z","comments":true,"path":"dataset-format-of-weka-ARFF.html","link":"","permalink":"http://qinjiangbo.com/dataset-format-of-weka-ARFF.html","excerpt":"","text":"开始机器学习相关的探索啦！作为一名Java程序员，想学习机器学习相关的技术，那么如何入手呢？有很多选择的，Java也是机器学习非常热门的语言之一，虽然Python是老大。博主决定从Weka入手，逐渐熟习机器学习常用的算法，然后再学习SparkMLLib等。我认为如果想在机器学习领域继续深挖，那么Python的学习是非常有必要的，因为现在很多非常前沿的机器学习相关技术都是先在Python的平台上发布出来，比如Tensorflow等。好啦，废话不多说了，开始进入Weka的学习，第一步就是搞清楚Weka是什么？Weka处理的数据集又是什么？ Weka是什么？Weka是一种鸡，叫新西兰秧鸡。这种鸟类天生就不具备飞行的能力，而且只在新西兰被发现，所以叫新西兰秧鸡。另外，英文Weka这个名字的来源也是因为这种鸟的叫声就是这个样子的，weka…weka…weka…，这种鸟类长这个模样： 好了，言归正传，本文所指的Weka其实是一种机器学习的工具包，里面有一系列用于数据挖掘任务的机器学习算法。这些算法可以被直接应用于数据集也可以从你的Java代码中进行调用。Weka包含了数据预处理、分类、回归、聚类、关联规则和可视化的一系列工具。而且也非常适合开发出新的机器学习模式。 官网原文介绍如下： Weka is a collection of machine learning algorithms for data mining tasks. The algorithms can either be applied directly to a dataset or called from your own Java code. Weka contains tools for data pre-processing, classification, regression, clustering, association rules, and visualization. It is also well-suited for developing new machine learning schemes. Weka数据集格式-ARFF说到Weka的学习，它的数据集是跑不掉的，Weka处理的数据集通常是存放在一种叫ARFF格式的文件中的。那么，什么是ARFF呢？ ARFF定义ARFF全称是Attribute-Relation File Format，属性关系文件格式。ARFF文件是一种描述了一系列具有相同属性的实例的ASCII文本文件。具体一点来说，就是数据集主要是有两部分组成，一部分是属性描述，一部分是数据。属性描述的这一部分也叫头信息，一般是放在数据集开始，而数据部分叫数据信息，一般是跟在头信息的后面。 ARFF头信息ARFF的头信息包含这个关系的名称，还有一系列属性以及它们的数据类型。以IRIS数据集(https://archive.ics.uci.edu/ml/datasets/iris)为例，标准的IRIS数据集的头信息如下表示： 123456789% source: https://archive.ics.uci.edu/ml/datasets/iris@RELATION iris@ATTRIBUTE sepal_length NUMERIC@ATTRIBUTE sepal_width NUMERIC@ATTRIBUTE petal_length NUMERIC@ATTRIBUTE petal_width NUMERIC@ATTRIBUTE class &#123;Iris-setosa,Iris-versicolor,Iris-virginica&#125; 注意到了上面的以%开头的那行了吗？那一句是ARFF文件的注释。在ARFF文件中，注释通常都是以%开头的。另外@RELATION，@ATTRIBUTE，@DATA都是大小写不敏感的，都可以使用。 @RELATION声明通常来说，@RELATION声明应该是在ARFF文件的第一行出现，前面注释啥的不算哈！具体的格式如下：@RELATION &lt;relation-name&gt;，这里&lt;relation-name&gt;是一个字符串，表示这个关系的名称。如果这个字符串包含空格的话一定要记得加上空格，否则识别会出现问题的。另外对于名称也有要求，不要使用&#39;{&#39;, &#39;}&#39;, &#39;,&#39; 或者 &#39;%&#39;开头，或者是在ASCII表中低于\\u0021[!]的字符。 @ATTRIBUTE声明@ATTRIBUTE声明主要是用来指定属性的数据名称和类型，具体的格式如下：@ATTRIBUTE &lt;attribute-name&gt; &lt;data-type&gt;，一般来说，&lt;attribute-name&gt;的要求和上面&lt;relation-name&gt;的要求是一样的，Weka支持的数据格式&lt;data-type&gt;主要有以下几种： numeric integer is treated as numeric real is treated as numeric &lt;nominal-specification&gt; string date [&lt;date-format&gt;] relational for multi-instance data (for future use) 其它的几个估计大家挺好明白，而&lt;nominal-specification&gt;和date估计不太好明白，没关系，我们下面再讲。 Nominal属性所谓的Nominal属性就是后面列举一系列的值，比如{&lt;nominal-value1&gt;,&lt;nominal-value2&gt;,&lt;nominal-value3&gt;...}，IRIS数据集的class属性就是这么定义的：@ATTRIBUTE class {Iris-setosa,Iris-versicolor,Iris-virginica}。 date属性date属性的定义比较特殊，因为它还涉及到一个格式的问题，所以我们需要指定相关的格式：@ATTRIBUTE &lt;attribute-name&gt; date [&lt;date-format&gt;]。日期的格式是比较复杂的，比如yyyy-MM-dd或者是MM-dd-yyyy等等，因此需要指定。具体的例子如下：@ATTRIBUTE birthday DATE &quot;yyyy-MM-dd HH:mm:ss&quot;对应的可参考的数据集如下： 1234567@RELATION Timestamps @ATTRIBUTE timestamp DATE &quot;yyyy-MM-dd HH:mm:ss&quot; @DATA &quot;2001-04-03 12:12:12&quot;&quot;2001-05-03 12:59:55&quot; ARFF数据信息ARFF的数据信息主要是一系列的以,分隔的数据，并且开头的注解是@DATA，还是以IRIS数据集为例，它的标准数据信息如下表示： 1234567891011121314@DATA5.1,3.5,1.4,0.2,Iris-setosa4.9,3.0,1.4,0.2,Iris-setosa4.7,3.2,1.3,0.2,Iris-setosa4.6,3.1,1.5,0.2,Iris-setosa5.0,3.6,1.4,0.2,Iris-setosa5.4,3.9,1.7,0.4,Iris-setosa4.6,3.4,1.4,0.3,Iris-setosa5.0,3.4,1.5,0.2,Iris-setosa4.4,2.9,1.4,0.2,Iris-setosa4.9,3.1,1.5,0.1,Iris-setosa5.4,3.7,1.5,0.2,Iris-setosa4.8,3.4,1.6,0.2,Iris-setosa4.8,3.0,1.4,0.1,Iris-setosa @DATA声明ARFF文件的数据部分都是跟在@DATA声明后面的。关于数据部分没有什么过多注意的地方，主要是注意数据缺失的情况，比如： 12@DATA4.4,?,1.5,?,Iris-setosa 可以看到，第二个数据和第四个数据缺失，缺失的数据在ARFF文件中统一使用?问号代替。 总结关于ARFF文件的相关理解就是这些，重点是需要知道Weka需要处理什么样的数据文件，以及如何理解并产生这些数据文件。后面会陆续推出一些算法的实际学习过程，都是偏向实战型的，后面会在会用算法解决实际问题的基础上再加深理论上的理解。不过目前如果想要学习理论的同学可以去看看机器学习算法研究相关书籍哈。 参考文献：http://weka.wikispaces.com/ARFF+%28stable+version%29","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"机器学习","slug":"数据科学/机器学习","permalink":"http://qinjiangbo.com/categories/数据科学/机器学习/"}],"tags":[{"name":"Weka","slug":"Weka","permalink":"http://qinjiangbo.com/tags/Weka/"},{"name":"机器学习","slug":"机器学习","permalink":"http://qinjiangbo.com/tags/机器学习/"},{"name":"ARFF","slug":"ARFF","permalink":"http://qinjiangbo.com/tags/ARFF/"}]},{"title":"macOS命令行SSH中文显示","slug":"macOS-ssh-terminal-Chinese-character-display-setting","date":"2017-11-27T07:00:41.000Z","updated":"2017-11-27T07:12:28.000Z","comments":true,"path":"macOS-ssh-terminal-Chinese-character-display-setting.html","link":"","permalink":"http://qinjiangbo.com/macOS-ssh-terminal-Chinese-character-display-setting.html","excerpt":"","text":"使用macOS开发的同学对于终端的依赖程度应该是非常高的，虽然我们有ZOC，有iTerm等等工具，但是自家的能够用当然是希望使用自家的产品了。关于如何使用macOS系统自带的terminal应用连接远程Linux服务器我就不在这里介绍了，有需要的读者可以查询ssh命令是如何使用的。 那么本文其实就是做了一个记录，关于中文字符在macOS终端里面显示乱码的问题，这里其实解决方案非常简单，找到.bash_profile或者是.zshrc文件，一般在~/这个目录下。好的看看命令行操作，这里以.zshrc为例： 12$ cd ~$ vim .zshrc 按住shift+G到达最底部，添加这两行代码即可： 12export LC_ALL=en_US.UTF-8export LANG=en_US.UTF-8 注意需要source .zshrc来使配置生效。这样，我们重新打开一个终端就可以看到正确地显示中文了。 12345678910111213Last login: Mon Nov 27 15:10:15 2017 from 212.174.113.171Welcome to Alibaba Cloud Elastic Compute Service ![root@richard ~]# lltotal 16580-rwxr-xr-x 1 root root 181 Nov 11 01:38 deploy_tomcat.sh-rw-r--r-- 1 root root 81 Nov 21 23:10 README.md-rw-r--r-- 1 root root 16958311 Nov 27 11:53 ROOT.war-rwxr-xr-x 1 root root 46 Nov 10 23:50 start_tomcat.sh-rwxr-xr-x 1 root root 47 Nov 10 23:51 stop_tomcat.sh-rw-r--r-- 1 root root 0 Nov 27 15:09 中文文本测试.md[root@richard ~]# 我们可以看到中文文本测试.md这个文件正常显示了。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://qinjiangbo.com/tags/ssh/"},{"name":"macOS","slug":"macOS","permalink":"http://qinjiangbo.com/tags/macOS/"},{"name":"中文乱码","slug":"中文乱码","permalink":"http://qinjiangbo.com/tags/中文乱码/"}]},{"title":"应该活得清澈而纯净","slug":"should-be-clear-and-purified","date":"2017-11-27T04:40:14.000Z","updated":"2017-12-06T09:30:38.000Z","comments":true,"path":"should-be-clear-and-purified.html","link":"","permalink":"http://qinjiangbo.com/should-be-clear-and-purified.html","excerpt":"","text":"刷朋友圈看到了Vanessa在八月份去稻城亚丁时拍摄的几张图，觉得风景甚美，故选择其中两张作为博客的插图。看着如此清澈的水，如此明媚的阳光，心中不禁思索到，如果一个人的心境也能像这水一般清澈而纯净该多好！ 然而，做到这一点是非常难的！生活中太多太多的琐事牵绊着我们，让我们很少有时间慢下来。慢，应该是一种比较从容的姿态，一种应对自如的自信。 其实心里面一直以来计划了很多事情，想去内蒙古的大草原上开车自由地驰骋，想去丽江晒晒太阳，想去稻城呼吸新鲜的空气，想去千岛湖里划划船，想去拉萨的布达拉宫朝拜。实际情况是，到目前为止，一件事情也没有完成。究其原因，觉得是自己想法不够纯净，心里面顾忌的事情太多了。总是担心这个时间走不开，那个时间又太赶了，一来二去，一件想做的事情都没有做成。 每次看到别人去了什么地方什么地方都非常羡慕，默默点个赞，然后继续着日常的一天。倒不是羡慕别人有钱出去旅游，而是羡慕为什么他们能踏出这一步，我不能。内心总是非常期待着一次旅行，可是总是不如人意。记不清多少次自己打开旅行网站查询了这些地方的机票，车票以及攻略，然后默默地点击了关闭窗口。 心灵的空灵和纯净是一种修行的境界。前两天在知乎上看到一个人说，一个人心灵上获得了自由，他的眼睛里的污浊便会消失，目光会变得明亮而纯真。关于如何达到心灵的清澈和纯净，没有人给出明确的回答。我想这应该需要每个人自己不断地探索吧。我说说我自己的计划和想法。 Make it simple!让生活简单起来，每天定一个明确的目标，同一时间只处理一件事情，保证质量和效率。我以前也说过，我不太赞同把每天的计划写在纸上，因为那样很容易陷入为了做而做的境地。我比较赞同的是将计划融进心里，定长期计划而不是短期计划。因为总需要知道“计划赶不上变化”，而长期的计划则是相对稳定的，不容易被临时的变化打乱，就像科目三路考直线行驶的时候，眼睛要盯着前方而不是车头一样，车的方向不容易偏。 现在每天有一个必做的事情就是健身，相比刚开始的跑步+肌肉锻炼，现在更多地是偏向与肌肉锻炼了。但是女友给了一个不错的建议，就是健身不能只关注于肌肉的训练，还是需要重视跑步的基础训练，没有基础训练，后面的肌肉训练效果很难起来的。虽然不明白科学依据在哪儿，但觉得好有道理的样子，看来还还是需要恢复到跑步+肌肉锻炼的模式中去了。 另外一点就是需要多读一些书籍，让自己的想法慢慢纯净起来，将头脑中的太多太多的杂乱想法排除掉。Make it simple again!思想上的纯净，会体现在外在的行为和言语上，我相信这一方面很多人都需要进一步提升。大脑的创新性和纯净并不矛盾，创新性体现在对某一个事务的独特见解和想法，而纯净则体现在对于一些事情的专注和坚持。 让我想起了海子的那首诗，觉得这就是心灵的纯净与空灵了吧： 《面朝大海，春暖花开》 海子 从明天起，做一个幸福的人 喂马、劈柴，周游世界 从明天起，关心粮食和蔬菜 我有一所房子，面朝大海，春暖花开 从明天起，和每一个亲人通信 告诉他们我的幸福 那幸福的闪电告诉我的 我将告诉每一个人 给每一条河每一座山取一个温暖的名字 陌生人，我也为你祝福 愿你有一个灿烂的前程 愿你有情人终成眷属 愿你在尘世获得幸福 我只愿面朝大海，春暖花开。 这首诗用朴素清新的语句，写出了海子内心的那种真诚善良。但是又隐含着些许无奈和忧伤，虽然这一些这么美好，纯净，但是都是从明天起的啊，而海子却永远停留在了今天。 正在读这篇文章的朋友，我告要诉你，执行某个计划的时候，不要从明天起，而是从今天起，虽然海子那个时候是没有从今天起的现实条件的，但是我们有，我们可以从今天起。努力做好每一件事，用心地生活，好好对待生命中的每一个人。 生活，其实没有那么难！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"空灵","slug":"空灵","permalink":"http://qinjiangbo.com/tags/空灵/"},{"name":"纯净","slug":"纯净","permalink":"http://qinjiangbo.com/tags/纯净/"}]},{"title":"git修改全部提交记录","slug":"git-modify-commit-records","date":"2017-11-21T09:18:00.000Z","updated":"2017-11-21T09:49:41.000Z","comments":true,"path":"git-modify-commit-records.html","link":"","permalink":"http://qinjiangbo.com/git-modify-commit-records.html","excerpt":"","text":"最近使用Intellij IDEA进行开发的时候需要添加一个版本控制，不知道为何提交到Gitlab私库的时候用户名称全部显示为了Github上面的用户名称和邮箱。通过git log命令一查看全部提交都是这样的。因此需要找到一种能够修改上次或者全部提交记录的方式。对于Git的高级用法还没有系统研究过，所以，就上网查询了一下，发现git filter-branch真心不错，可以对所有的记录进行更正。 修改全部记录具体使用方式如下，在目标目录下执行这条命令即可： 12345$ git filter-branch -f --env-filter \\\"GIT_AUTHOR_NAME='[YOUR_NAME]'; \\GIT_AUTHOR_EMAIL='[YOUR_EMAIL]'; \\GIT_COMMITTER_NAME='[YOUR_NAME]'; \\GIT_COMMITTER_EMAIL='[YOUR_EMAIL]';\" HEAD 可以看到会出现以下输出： 12345678Rewrite 3368f52b1c24a8b9fcac3864089c08bfe0929d4d (1/7) (0 seconds passed, remaining 0 predicted) Rewrite 0a1444fab2235a67fb94a3f60ea3b8350c6c4b04 (2/7) (0 seconds passed, remaining 0 predicted) Rewrite 1fe88255450e24fac784d23530f0b463496d0ef7 (3/7) (0 seconds passed, remaining 0 predicted) Rewrite 577de20132b50faa4c874134973d5d2b8bb8ad2a (4/7) (0 seconds passed, remaining 0 predicted) Rewrite 931f04cb491427e5a504751ab1dc4bec4e059050 (5/7) (0 seconds passed, remaining 0 predicted) Rewrite bceaa47e80d55e2b8647ff2d847c7cd852c162ce (6/7) (0 seconds passed, remaining 0 predicted) Rewrite a0790a0780e70d62143287bf10f09783b00d4a00 (7/7) (0 seconds passed, remaining 0 predicted) Ref 'refs/heads/master' was rewritten 但是如果之前的这些变更我们已经提交到私库里面去怎么办呢？很简单，我们接下来使用git push -f命令强制让私库修改这些变更。 123456789$ git push -fCounting objects: 167, done.Delta compression using up to 4 threads.Compressing objects: 100% (152/152), done.Writing objects: 100% (167/167), 258.59 KiB | 3.15 MiB/s, done.Total 167 (delta 62), reused 0 (delta 0)remote: Resolving deltas: 100% (62/62), done.To https://gitlab.com/anti-crawler-system/DemoProject.git + a0790a0...52621a8 master -&gt; master (forced update) 接着去私库中查看就会发现已经完全修改好啦！ 修改上一次记录那修改上一次的提交记录呢？使用什么命令？答案是git commit --amend命令，具体使用方式如下： 1git commit --amend --author=\"NewAuthor &lt;NewEmail@address.com&gt;\" 总结关于Git的用法有很多，其实遇到我这种需要修改全部提交记录的情况并不常见，但是需要提前先了解一下，不然问题出现的时候都无所适从。修改提交者记录的原因有很多，但不管怎么样，使用这两个方法都是可以的。如果是需要合并提交记录的话可以使用git rebase命令，具体用法后面会给大家介绍的。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://qinjiangbo.com/tags/Git/"},{"name":"提交记录","slug":"提交记录","permalink":"http://qinjiangbo.com/tags/提交记录/"}]},{"title":"服务器SSH自动登录脚本","slug":"centos-auto-login-via-ssh","date":"2017-11-11T09:25:20.000Z","updated":"2017-11-11T10:08:04.000Z","comments":true,"path":"centos-auto-login-via-ssh.html","link":"","permalink":"http://qinjiangbo.com/centos-auto-login-via-ssh.html","excerpt":"","text":"发现一个有趣的事情，就是很久之前想过的一个问题，不知道解决方案，然后就忘记了。突然某一天（比如今天）又想起来了，于是乎趁这个机会要好好弄明白到底是怎么回事。这个问题就是Linux系统中如何实现对命令的自动回答。举个简单的例子哈，比如我们使用yum install命令进行安装的时候，如果没有加上-y参数，我们几乎很多时候都会在程序安装的过程当中被要求输入yes/no，如果不输入程序则停止住了。那么，如何实现自动化的处理呢？对于yum install命令而言，-y参数是最好的选择，因为简洁。 好了，对于本文所要讲述的脚本来说，是针对于SSH登录的。我们知道，很多时候我们一旦管理的机器多了以后，就需要记住不同的密码，这几乎是一项很大的挑战。所以，我们会使用一些工具，比如说SSH远程登录工具，但这是你可以使用GUI工具的前提。如果在纯CentOS环境下，我们应该如何使用命令去实现命令的自动应答呢？ expect命令答案就是expect命令，关于expect命令的具体使用方式，可以通过命令man expect来查看。本文主要介绍expect命令下最重要的四个命令： send 向进程发送字符串参数 expect 从进程接收字符串参数 spawn 启动新的进程 interact 允许用户交互 实例讲解针对于CentOS服务器自动登录，我们分析一下登录的流程，（1）通常是我们需要使用ssh连接，（2）然后会显示一个提示要求我们输入密码，（3）然后我们就输入密码，回车，（4）就登录成功了！ 好了，我们分别来看看怎么实现： 使用ssh命令连接1spawn ssh root@121.68.209.142 启动一个线程连接到服务器121.68.209.142。 显示一个提示要求输入密码1expect \"*password:*\" 注意expect命令里面支持通配符。可以抽取实际输出的字符串中的某一段作为判断的依据。 输入密码，回车12set password pas4wordsend \"$password\\r\" 这里使用了变量password来表示密码，实践的时候建议使用变量，这样便于修改和拓展。 人工交互当前面的操作都成功的时候，我们应该能正常登录啦，所以这个时候要将交接棒交给用户啦，我们需要来操作远程服务器，所以使用如下命令： 1interact 非常简单！ 实例源码12345678910#!/usr/bin/expect -f set timeout -1set password pas4wordspawn ssh root@121.68.209.142expect \"*password:*\"send \"$password\\r\"interact 注意shell脚本中的头是#!/usr/bin/expect -f表示我们使用的是expect命令工具，所以这个脚本启动的时候需要通过expect命令。拷贝这个代码，另存为aliyun.sh： 1expect aliyun.sh 就可以自动登录啦： 12345678910# expect aliyun.sh spawn ssh root@121.68.209.142root@121.68.209.142's password: Last failed login: Sat Nov 11 16:46:41 CST 2017 from 113.22.113.82 on ssh:nottyThere were 7 failed login attempts since the last successful login.Last login: Fri Nov 10 23:49:25 2017 from 211.191.151.221Welcome to Alibaba Cloud Elastic Compute Service ![root@richard ~]# 总结遇到问题还是要及时解决，问题总是这样的，如果某个时刻不解决，那你就会一直不清楚。所以唯一的方式就是主动地求知，去查找相关的资料，不一定要记住，但是要知道如何去利用它解决对应的问题。以expect命令来说，它的主要使命就是解决命令行里面的自动应答问题。所以，当你有相关的需求时，可以使用expect命令来解决。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"http://qinjiangbo.com/tags/SSH/"},{"name":"自动登录","slug":"自动登录","permalink":"http://qinjiangbo.com/tags/自动登录/"},{"name":"expect命令","slug":"expect命令","permalink":"http://qinjiangbo.com/tags/expect命令/"}]},{"title":"MySQL导入大文件调参","slug":"settings-of-mysql-when-importing-large-file","date":"2017-11-04T06:58:52.000Z","updated":"2017-11-04T07:14:15.000Z","comments":true,"path":"settings-of-mysql-when-importing-large-file.html","link":"","permalink":"http://qinjiangbo.com/settings-of-mysql-when-importing-large-file.html","excerpt":"","text":"今天利用MySQL导入数据的时候发生了一个错误，报错的信息是“MySQL server has gone away”。这个如何解决呢？我先说说我的工具，我导入数据使用的是Navicat Premium 12.0.13，然后MySQL使用的是Homebrew安装的。 写这篇文章目的主要是记录一下这个问题的解决方案，以免以后重蹈覆辙。其实答案很简单，就是调整MySQL一个配置项max_allowed_packet，我设置的是768M。Homebrew安装默认MySQL的配置文件在/usr/local/etc这个目录下。我们可以打开这个文件进行编辑： my.cnf12345# Default Homebrew MySQL server config[mysqld]# Only allow connections from localhostbind-address = 127.0.0.1max_allowed_packet = 768M 重启MySQL服务器： 1mysql.server restart 再次导入的时候就可以啦！ 总结这个问题其实可能还有其他的原因，有人会说有可能是因为超时，所以也需要改一下wait_timeout=2880000 interactive_timeout = 2880000这两个变量。具体的情况需要具体分析，不过也提供了一种可能的思路。最常见的原因就是本文所说的情况啦，基本上这么一改就会OK的。","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"MySQL","slug":"数据科学/MySQL","permalink":"http://qinjiangbo.com/categories/数据科学/MySQL/"}],"tags":[{"name":"导入数据","slug":"导入数据","permalink":"http://qinjiangbo.com/tags/导入数据/"},{"name":"大文件","slug":"大文件","permalink":"http://qinjiangbo.com/tags/大文件/"}]},{"title":"阿里云验证码服务实践","slug":"practice-of-aliyun-captcha-service","date":"2017-11-04T05:38:16.000Z","updated":"2017-11-04T06:47:10.000Z","comments":true,"path":"practice-of-aliyun-captcha-service.html","link":"","permalink":"http://qinjiangbo.com/practice-of-aliyun-captcha-service.html","excerpt":"","text":"在平时上网的时候，我们会见到很多不同的验证码，大多数都是图形验证码，有数字的，有大小写字母的，也有中文的等等。但是这些验证码往往特别容易被OCR技术识别，所以针对人的识别就显得没那么准确了。本文将借力阿里云的验证码服务，介绍一种滑动式的验证码服务实践。 传统验证码服务传统的验证码基本上都类似于下面这种：它的主要实现方式就是在一个图片上打印出一些文字，然后再添加一些噪声，起一个混淆的作用，主要是用来防止验证码破解服务的。但是借助现有的OCR技术基本上不用太花时间就可以被破解了。所以，使用的价值不大，因此，包括阿里巴巴在内的很多公司决定采用一种新的验证码方式，如下图所示： 这种方式相比于传统的验证码服务不容易被OCR识别，但是也有其他的方式去破解，它并不是绝对的安全，但是破解的成本非常高。 阿里云验证码服务这里引用阿里云的同学在云栖社区上发表的一篇文章验证码对抗之路及现有验证机制介绍，他分别介绍了阿里云滑动验证码和谷歌reCaptcha的技术体系： 阿里云滑动验证码 通过基于用户行为的第一道防御将对正常用户的打扰降低，使得正常用户可以以极小的代价通过滑动验证，而同时对不确定的用户实施知识型问题的验证，在拦截机器人的同时，保障业务的正常平稳运行。 谷歌reCaptcha 可以看到，google的模式与阿里的模式有些类似，所不同的是google所使用的验证码模式是点击，而阿里是滑动。 简单分析下google，对于第一步的点击验证，google更多的是通过其基于虚拟机的强混淆器对整个数据采集过程进行了加密，并综合了环境信息（如设备指纹、cookie、点击频率等信息）来进行判断，而第二步的知识验证也包括以下几种（部分在之前的图中没有出现）： 扭曲的图形 图形的分类 高级图形分类(会不断的出图，点完一张又一张) 可以看到二者在架构上是非常相似的，攻击者的成本会非常高！这也就达到我们使用验证码的目的了。 代码实践服务申请首先需要开通阿里云的滑动验证码服务，具体服务如下（这个位置不是太好找QAQ）： 接着拿好自己的accessKeys，这个在https://ak-console.aliyun.com/#/accesskey可以找到。好了，服务申请准备完毕。 项目搭建关于SpringMVC如何搭建我就不多说了，大家可以看我之前的博客，或者自己到网上查看。主要是两个文件需要编写，一个是jsp页面，另一个是后台对应处理的controller类。我们分别来编写这两个文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;示例-WEB版&lt;/title&gt; &lt;!-- 此段必须要引入t为小时级别的时间戳 --&gt; &lt;link type=\"text/css\" href=\"//g.alicdn.com/sd/ncpc/nc.css?t=1509677798218\" rel=\"stylesheet\"/&gt; &lt;script type=\"text/javascript\" src=\"//g.alicdn.com/sd/ncpc/nc.js?t=1509677798218\"&gt;&lt;/script&gt; &lt;!-- 引入结束 --&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 此段必须要引入 --&gt;&lt;div id=\"_umfp\" style=\"display:inline;width:1px;height:1px;overflow:hidden\"&gt;&lt;/div&gt;&lt;!-- 引入结束 --&gt;&lt;!-- 表单示例，请替换成您的业务表单 --&gt;&lt;div class=\"container\"&gt; &lt;form action=\"/verify\" method=\"post\"&gt; &lt;div class=\"ln\"&gt; &lt;div id=\"dom_id\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;input type='hidden' id='csessionid' name='csessionid'/&gt; &lt;input type='hidden' id='sig' name='sig'/&gt; &lt;input type='hidden' id='token' name='token'/&gt; &lt;input type='hidden' id='scene' name='scene'/&gt; &lt;div class=\"ln\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;!-- 表单示例结束 --&gt;&lt;!-- 此段必须要引入 --&gt;&lt;script&gt; var nc = new noCaptcha(); var nc_appkey = 'FFFF0000000001789A78'; // 应用标识,不可更改 var nc_scene = 'login'; //场景,不可更改 var nc_token = [nc_appkey, (new Date()).getTime(), Math.random()].join(':'); var nc_option = &#123; renderTo: '#dom_id',//渲染到该DOM ID指定的Div位置 appkey: nc_appkey, scene: nc_scene, token: nc_token, callback: function (data) &#123;// 校验成功回调 console.log(data.csessionid); console.log(data.sig); console.log(nc_token); document.getElementById('csessionid').value = data.csessionid; document.getElementById('sig').value = data.sig; document.getElementById('token').value = nc_token; document.getElementById('scene').value = nc_scene; &#125; &#125;; nc.init(nc_option);&lt;/script&gt;&lt;!-- 引入结束 --&gt;&lt;/body&gt;&lt;!-- 样式示例，请替换成自己的样式 --&gt;&lt;style&gt; body &#123; background: #f5f5f5; font-size: 14px; line-height: 20px; margin: 0; padding: 0; &#125; .container &#123; background: #fff; padding: 20px; margin: 20px; width: 400px; &#125; .ln &#123; padding: 5px 0; &#125; .ln .h &#123; display: inline-block; width: 4em; &#125; .ln input &#123; border: solid 1px #999; padding: 5px 8px; &#125;&lt;/style&gt;&lt;!-- 样式示例结束 --&gt;&lt;/html&gt; 页面效果如下： 我们再编写对应的Controller类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.qinjiangbo.controller;import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.IAcsClient;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.jaq.model.v20161123.AfsCheckRequest;import com.aliyuncs.jaq.model.v20161123.AfsCheckResponse;import com.aliyuncs.profile.DefaultProfile;import com.aliyuncs.profile.IClientProfile;import com.qinjiangbo.util.IpCounter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;@Controllerpublic class ValidationController &#123; private static Logger logger = LoggerFactory.getLogger(ValidationController.class); private static final String ACCESS_KEY = \"YOUR_ACCESS_KEY\"; private static final String ACCESS_SECRET = \"YOUR_ACCESS_SECRET\"; private static IAcsClient client = null; static &#123; init(); &#125; /** * 初始化验证服务 */ private static void init() &#123; IClientProfile profile = DefaultProfile.getProfile(\"cn-hangzhou\", ACCESS_KEY, ACCESS_SECRET); client = new DefaultAcsClient(profile); try &#123; DefaultProfile.addEndpoint(\"cn-hangzhou\", \"cn-hangzhou\", \"Jaq\", \"jaq.aliyuncs.com\"); &#125; catch (ClientException e) &#123; logger.error(\"验证码服务初始化失败！\"); &#125; &#125; @RequestMapping(\"/validate\") public ModelAndView validation(HttpServletRequest request) &#123; ModelAndView modelAndView = new ModelAndView(\"validation\"); return modelAndView; &#125; @RequestMapping(\"/verify\") public ModelAndView verify(HttpServletRequest httpServletRequest) &#123; String session = httpServletRequest.getParameter(\"csessionid\"); String sig = httpServletRequest.getParameter(\"sig\"); String token = httpServletRequest.getParameter(\"token\"); String scene = httpServletRequest.getParameter(\"scene\"); AfsCheckRequest request = new AfsCheckRequest(); request.setPlatform(3);// 1:Android 2:iOS 3:PC request.setSession(session); request.setSig(sig); request.setToken(token); request.setScene(scene); boolean success = true; try &#123; AfsCheckResponse response = client.getAcsResponse(request); if(response.getErrorCode() == 0 &amp;&amp; response.getData() == true) &#123; System.out.println(\"验证通过\"); &#125; else &#123; success = false; System.out.println(\"验证失败\"); &#125; &#125; catch (Exception e) &#123; logger.error(\"验证服务出错！\"); &#125; ModelAndView modelAndView = new ModelAndView(\"success\"); modelAndView.addObject(\"success\", success); return modelAndView; &#125;&#125; 关于成功的页面我就不写了，比较简单，里面就是根据${success}的值打印出是成功的还是失败的。 总结现在验证码的识别技术越来越先进，但是验证码的技术也越来越先进；其实我们都可以自己去实现那些传统的验证码，但是传统的验证码已经远远不能满足我们的需求了。这个时候我们就休要借力第三方强大的技术实力支持。我个人比较喜欢阿里云，所以就坚持使用阿里云的服务咯！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"阿里云","slug":"阿里云","permalink":"http://qinjiangbo.com/tags/阿里云/"},{"name":"验证码","slug":"验证码","permalink":"http://qinjiangbo.com/tags/验证码/"}]},{"title":"Drools与SpringMVC整合","slug":"integration-between-drools-and-springmvc","date":"2017-11-01T08:22:49.000Z","updated":"2017-11-02T06:56:49.000Z","comments":true,"path":"integration-between-drools-and-springmvc.html","link":"","permalink":"http://qinjiangbo.com/integration-between-drools-and-springmvc.html","excerpt":"","text":"本文主要介绍Drools6.4.Final版本与SpringMVC的整合。网上现有的教程大多数不能完整运行，本文将会提供具体的操作过程以及相应的注意事项，保证Demo代码是可以跑通的。 开发环境 macOS High Sierra Intellij IDEA 2017.2 Drools 6.4.0.Final SpringMVC 4.3.12.RELEASE JDK 1.8.0_144 搭建Maven项目关于具体如何创建一个Maven的Webapp项目我就不赘述了，其实在IDEA中可以一步一步选择的，下面贴出本项目的pom.xml文件。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qinjiangbo&lt;/groupId&gt; &lt;artifactId&gt;DroolsSpring&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;Drools SpringMVC&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 各个框架的版本 --&gt; &lt;properties&gt; &lt;spring.version&gt;4.3.12.RELEASE&lt;/spring.version&gt; &lt;drools.version&gt;6.4.0.Final&lt;/drools.version&gt; &lt;slf4j.version&gt;1.7.25&lt;/slf4j.version&gt; &lt;fastjson.version&gt;1.2.39&lt;/fastjson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Drools框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.kie&lt;/groupId&gt; &lt;artifactId&gt;kie-api&lt;/artifactId&gt; &lt;version&gt;$&#123;drools.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-core&lt;/artifactId&gt; &lt;version&gt;$&#123;drools.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt; &lt;version&gt;$&#123;drools.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.kie&lt;/groupId&gt; &lt;artifactId&gt;kie-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;drools.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Tomcat相关包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JUnit框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Slf4j日志框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Fastjson框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;DroolsSpring&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 接着在web.xml中配置相关的SpringMVC环境。 web.xml1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"2.5\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"&gt;&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:springContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;springServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:springContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 在介绍springContext.xml文件之前，有必要贴出一下项目的结构，以便于大家有一个更明确的认知。 好，现在分别介绍springContext.xml，springDrools.xml以及springMVC.xml三个文件。 springContext.xml1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置包扫描路径 --&gt; &lt;context:component-scan base-package=\"com.qinjiangbo\"/&gt; &lt;!-- 导入其他配置 --&gt; &lt;import resource=\"springDrools.xml\"/&gt; &lt;import resource=\"springMVC.xml\"/&gt;&lt;/beans&gt; springDrools.xml12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:kie=\"http://drools.org/schema/kie-spring\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://drools.org/schema/kie-spring http://drools.org/schema/kie-spring.xsd\"&gt; &lt;!-- Drools配置 --&gt; &lt;bean id=\"kiePostProcessor\" class=\"org.kie.spring.annotations.KModuleAnnotationPostProcessor\"/&gt; &lt;kie:kmodule id=\"kModule\"&gt; &lt;kie:kbase name=\"kBase\" packages=\"rules\"&gt; &lt;kie:ksession name=\"kSession\" type=\"stateful\"/&gt; &lt;/kie:kbase&gt; &lt;/kie:kmodule&gt;&lt;/beans&gt; springMVC.xml12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 开启MVC注解 --&gt; &lt;mvc:annotation-driven/&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; Fact模型在Drools中我们使用的Model被称之为事实(Fact)模型，本例中的事实模型是Message.java。 123456789101112131415161718192021222324252627package com.qinjiangbo.model;public class Message &#123; public static final int DEAD = 0; public static final int ALIVE = 1; private String message; private int status; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125;&#125; rules文件我们来编写一下相关的规则文件，一般是以.drl结尾。 1234567891011121314151617181920212223242526package rules;import com.qinjiangbo.model.*;rule \"rule1\" when /** * 当该实体的status属性为DEAD的时候，将该实体赋值给m， * 实体的message属性赋值给printMsg */ m:Message(status == Message.DEAD, printMsg: message); then // 系统输出和重新设置实体属性 System.out.println(printMsg); m.setMessage(\"I'm alive~\"); m.setStatus(Message.ALIVE); // 更新实体，触发规则 update(m);endrule \"rule2\" when Message(status == Message.ALIVE, printMsg: message); then System.out.println(printMsg);end Service类和Controller类在Service类中调用规则引擎相关的逻辑，在Controller中进行Web页面的交互。 123456789101112131415161718192021222324package com.qinjiangbo.service;import com.alibaba.fastjson.JSON;import com.qinjiangbo.model.Message;import org.kie.api.cdi.KSession;import org.kie.api.runtime.KieSession;import org.springframework.stereotype.Service;@Servicepublic class MessageService &#123; @KSession(\"kSession\") private KieSession kieSession; public String updateMessage() &#123; Message message = new Message(); message.setMessage(\"Left 4 Dead 2\"); message.setStatus(Message.DEAD); kieSession.insert(message); kieSession.fireAllRules(); return JSON.toJSONString(message); &#125;&#125; 注意上面的@KSession(&quot;kSession&quot;)注解在使用的时候要在springDrools.xml文件中声明kiePostProcessor为注解类型的org.kie.spring.annotations.KModuleAnnotationPostProcessor，否则会失效的。另外，这里使用的KieSession其实就是指代的StatefulKieSession类，不要使用KieSession去声明一个StatelessKieSession类的对象。这里要在springDrools.xml文件中把&lt;kie:ksession name=&quot;kSession&quot; type=&quot;stateful&quot;/&gt;类型声明为stateful。 12345678910111213141516171819202122232425262728package com.qinjiangbo.controller;import com.qinjiangbo.service.MessageService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controller@RequestMapping(\"/\")public class MessageController &#123; @Autowired private MessageService messageService; @RequestMapping(\"/\") public String index() &#123; return \"index\"; &#125; @RequestMapping(\"/update\") public ModelAndView update() &#123; ModelAndView modelAndView = new ModelAndView(\"success\"); String message = messageService.updateMessage(); modelAndView.addObject(\"message\", message); return modelAndView; &#125;&#125; 测试结果在浏览器中输入http://localhost:8080/update，就可以看到如下页面：Bingo，那就证明整合成功啦！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"规则引擎","slug":"规则引擎","permalink":"http://qinjiangbo.com/tags/规则引擎/"},{"name":"Drools","slug":"Drools","permalink":"http://qinjiangbo.com/tags/Drools/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://qinjiangbo.com/tags/SpringMVC/"}]},{"title":"利用Vultr搭建科学上网工具","slug":"build-vpn-service-with-vultr","date":"2017-10-30T07:24:34.000Z","updated":"2017-10-30T08:15:57.000Z","comments":true,"path":"build-vpn-service-with-vultr.html","link":"","permalink":"http://qinjiangbo.com/build-vpn-service-with-vultr.html","excerpt":"","text":"其实网上关于搭建科学上网的文章非常多，只不过百度搜索的时候没显示出来罢了，做这篇文章的目的主要是验证最新的科学上网服务搭建实践。首先当然是选择国外的服务商了，我没有选择亚马逊是因为它连接我电脑太慢了（其他人电脑估计不一样）。下面列举两个国外性价比比较高的服务商： Vultr Digital Ocean 大家可以去百度上搜索这两家公司。本文以第一家公司的产品为例，讲解一下科学上网环境如何搭建。 搭建服务器具体配置信息可以选择下面的实例，因为ShadowSocks本身并不会消耗太多的服务器资源，所以我选择最优惠的那种类型（估计这种就是为了科学上网服务的，哈哈）。 搭建好服务器以后我们需要登录服务器做一些操作： 1ssh root@[your_server_ip] 注意，服务器密码在服务详情里面： 安装ShadowSocks其实可以参考ShadowSocks在Github上的官方教程：https://github.com/shadowsocks/shadowsocks/tree/master 我们就直接输入命令安装啦： 1234apt-get install python-pip## 这个必须先安装，否则会报错 wget https://bootstrap.pypa.io/ez_setup.py -O - | pythonpip install shadowsocks 好啦，安装完成！ 服务端启动服务启动服务的命令也非常简单： 前台启动： 1ssserver -p 443 -k password -m aes-256-cfb 后台启动： 1sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start 上面的password要替换成你自己的密码，随便什么都可以，只不过别太简单。后面的nobody这个可以忽略，它是指以什么身份启动，这里默认就可以了。 客户端配置服务我使用的系统是MacOS High Sierra，所以我使用的客户端是ShadowsocksX-2.6.3.dmg。配置方式如下： 访问目标网页访问一下Google试试： Bingo！成功了！说明我们的配置是OK的！ 总结关于科学上网方案，其实有很多种选择，VPN和ShadowSocks都是使用比较多的情形，其实现在主流的服务提供商都是提供VPN服务。作为消费者本身来说，选择哪一种方式完全取决于当前的实际需要，其实我们也可以找一些ShadowSocks服务提供商（貌似特别难找，如果有的话欢迎在下面评论区留言，感激不尽！）。我自己之前使用的是DEVPN，但是七块钱一个月才分给我10G流量，不能忍，直接自己搭建一个多舒服！2.5美刀500G多划算。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"编程经验","slug":"经验感悟/编程经验","permalink":"http://qinjiangbo.com/categories/经验感悟/编程经验/"}],"tags":[{"name":"Vultr","slug":"Vultr","permalink":"http://qinjiangbo.com/tags/Vultr/"},{"name":"科学上网","slug":"科学上网","permalink":"http://qinjiangbo.com/tags/科学上网/"},{"name":"VPN","slug":"VPN","permalink":"http://qinjiangbo.com/tags/VPN/"},{"name":"ShadowSocks","slug":"ShadowSocks","permalink":"http://qinjiangbo.com/tags/ShadowSocks/"}]},{"title":"聊聊异地恋","slug":"talk-about-long-distance-relationship","date":"2017-10-25T11:02:32.000Z","updated":"2017-10-25T12:42:30.000Z","comments":true,"path":"talk-about-long-distance-relationship.html","link":"","permalink":"http://qinjiangbo.com/talk-about-long-distance-relationship.html","excerpt":"","text":"好久没有聊情感类的话题了，今天来说一说异地恋。关于异地恋每个人都会有不同的感受，有的痛苦，有的快乐，有的痛并快乐着。说实话，我属于那种幸福地痛并快乐着的人。关于感情这件事，世界上没有哪个人的感情和别人会一模一样的，每一段恋情都是独一无二的，因为别人无法复制你的恋情。 我不太喜欢读那些关于情感的软文，曾经问过一个朋友，她是一个情感微信公众号的作者，就能写出婆媳之间的相处之道，男女之间的感情之事，一问发现她还没恋爱过。这样的文章难免会有些缺乏说服力，也无法引起太大的共鸣。但是又有很多人喜欢看，为什么呢，因为他们写出来的东西都是一些非常常见的问题，只不过语言上表述的精彩了一点，但是细细一想，其实并没有多少味道，没有什么能沉淀下来的东西。 其实网上说了很多，什么时间和距离会慢慢将两个人越拉越远，最后逐渐成为路人。确实这样的例子不少，但是很少有人说异地恋也能很愉快地相处的。所以，曾经有个朋友问我，江波，看你现在继续读研，那你女朋友怎么办啊？她留在武汉工作吗？不在武汉工作你们不就分开了吗？我很直接地说，她不在武汉，而且我对我俩感情也很有信心。截至现在我们异地都快两年了，感情非常稳定。 我们曾经也很害怕毕业分手，也曾因为这个大吵一架。那时候她很容易没有安全感，生怕毕业之后我们俩就不了了之了。但是我们对这段感情是很严肃的，绝不仅仅只是所谓的“玩一下”。所以，当她缺乏安全感的时候，我就鼓励她，给她信心！现在我们对彼此都非常有信心，虽然也会经常吐槽彼此，也会经常小吵小闹。我的信心何来？我想主要是还是沟通。谈恋爱，谈什么？我认为需要谈价值观，谈消费观，谈性格特征，谈未来方向等等。 价值观。这是决定两个人能不能长久下去的关键因素，两个价值观不和的人是不太可能愉快地生活下去的。寻找另一半往往是找寻自己心仪的另一半，而另一半的选择往往和自身的价值观有关系。（如果是颜控当我没说，因为生气的时候，看一眼对方，妈呀，这么漂亮，算了，还是原谅她吧。女孩子也是，哎呀，这么帅，算了，我还是不生他的气好了。） 消费观。这点我必须要好好说一下，我和女友的消费观是很不相同的，她消费相对理性，谨慎；而我消费更多比较随性。由于这个消费观我们俩吵了很多次架，不过吵架不是目的，每一次吵架我们就解决了一些问题，而这些问题如果不及时解决，后面将会变成隐形炸弹。消费观是很多情侣之间以后必须面对的问题，如果你还没谈到，赶紧谈谈吧。 性格特征。性格特征没什么好说的，自己喜欢就好。喜欢她，你就需要包容她的一切，这句话有点俗套，但是管用。口口声声说爱她，结果到最后嫌弃这个嫌弃那个，我觉得不太好。其实并不是说要纵容对方，而是需要不断地和她磨合，慢慢影响彼此，让对方成为更好的自己。变成一个更好的性格，变成一个更强大的自己。如果烂泥扶不上墙，赶紧分手，别犹豫，否则越陷越深！ 未来方向。女孩子，如果一个男孩跟你谈未来，跟你规划这一切，恭喜你，他把你当成了最重要的人，他对你是认真的。我堂哥曾经跟我和我女友说过，毕业以后两个人是不太可能在一个城市的，如果以后想在一起，必须得有一个人做出牺牲。我女友想了一下，郑重地说道，如果要牺牲一方的话，她愿意。说实话，我挺感动的，心里也很窃喜遇到这么一个好女孩。未来的路谁也不可期，但是我们可以把握当下，努力拼搏，为后面两人在一起做最大的努力。 异地恋其实并不可怕，只有两个人心在一起，其实距离都是小事。可以参考的做法就是每天都保持一定的联系，视个频，来个电话，发条短信等等。每天给彼此分享自己身边的事情，让彼此之间拥有一些话题，因为如果很久都没有话题的话，感情就会慢慢淡薄了。这个是情侣们需要不断努力的。 异地恋，给彼此相对的自由，但是别给绝对的自由，也别压的太紧。最好的状态应该是彼此都活的比较自由轻松。毕竟感情不是用来束缚一个人的。最后希望异地恋的你过的开心愉快，也早日结束异地恋，和他（她）在一起吧！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"异地恋","slug":"异地恋","permalink":"http://qinjiangbo.com/tags/异地恋/"}]},{"title":"Dockerfile常用命令介绍","slug":"introduction-to-docker-instructions","date":"2017-10-16T07:30:40.000Z","updated":"2017-10-16T09:03:20.000Z","comments":true,"path":"introduction-to-docker-instructions.html","link":"","permalink":"http://qinjiangbo.com/introduction-to-docker-instructions.html","excerpt":"","text":"前面几篇文章介绍了Docker如何构建一个镜像以及如何运行一个容器，其实这个是在大家有Docker基础的前提下进行的，对于没有基础的同学，本文简单介绍一下Dockerfile中各个命令的用法是怎样的。 1. FROM格式：FROM &lt;image&gt;或者FROM &lt;image&gt;:&lt;tag&gt;第一条指令必须是FROM，而且，在同一个Dockerfile中创建多个镜像的时候，可以使用多个FROM指令（每个指令一次）。 2. MAINTAINER格式：MAINTAINER &lt;name&gt;指定维护者是谁。 3. RUN格式：RUN &lt;command&gt;或者RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]。前者将在shell终端中运行，即/bin/sh -c。后者使用exec执行。指定使用其它终端执行可以用后一种方式实现。比如RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]。每一条RUN指令执行的时候都会在当前镜像的基础上创建新的镜像，如果你的命令实在是非常长的话可以使用\\来分隔。 4. CMD支持三种格式： CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]使用exec执行，推荐方式。 CMD command param1 param2在/bin/sh中执行，提供给需要交互的应用。 CMD [&quot;param1&quot;, &quot;param2&quot;]提供给ENTRYPOINT的默认参数。 指定启动容器时执行的命令，每一个Dockerfile只能有一条CMD命令，如果有多条的话，只会执行最后一条。如果用户启动容器时指定了运行的命令，则CMD命令会被覆盖掉。 5. EXPOSE格式：EXPOSE &lt;port&gt; [&lt;port&gt;...]例如：EXPOSE 80 443 22这条命令告诉容器需要开放的端口号，以提供给互联系统使用，启动容器的时候需要通过-p或者-P来分配这些端口。使用-P的话，系统会随机指定一些端口映射过来，使用-p的话，需要自己具体指定端口与上述端口映射。比如：docker run -d -p 1022:22 -p 1080:80 -p 1443:443 nginx。 6. ENV格式：ENV &lt;key&gt; &lt;value&gt;就是指定一个环境变量，会被后续的RUN命令使用，并在容器运行时保持。比如： 1234ENV MYSQL_MAJOR 5.6ENV MYSQL_VERSION 5.6.20RUN curl -SL \"http://dev.mysql.com/get/Downloads/MySQL-$MYSQL_MAJOR/mysql-$MYSQL_VERSION-linux-glibc2.5-x86_64.tar.gz\" -o mysql.tar.gztar -zxvf mysql.tar.gz /usr/local/mysql 7. ADD格式：ADD &lt;src&gt; &lt;dest&gt;复制指定的&lt;src&gt;到容器的&lt;dest&gt;，其中&lt;src&gt;可以是Dockerfile所在目录的一个相对路径（文件或目录）；也可以是一个URL；还可以是一个tar文件（自动解压为目录）。 8. COPY格式：COPY &lt;src&gt; &lt;dest&gt;复制本地主机的&lt;src&gt;为容器的&lt;dest&gt;，目标路径不存在的时候，会自动创建。如果我们使用本地源目录的时候，推荐使用COPY命令。 9. ENTRYPOINT格式：ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]或ENTRYPOINT command param1 param2（shell中执行）。配置容器启动以后执行的命令，并且不能被docker run命令提供的参数覆盖。每一个Dockerfile只能有一个ENTRYPOINT命令，当存在多个的时候就只有最后一个会生效。 10. VOLUME格式：VOLUME [&quot;/data&quot;]创建一个本地主机或者其他容器挂载的挂载点，一般用来存储数据库和需要保持的数据等等。 11. USER格式：USER daemon指定运行容器时候的用户名或者UID，后续RUN也会使用指定的用户。 12. WORKDIR格式：WORKDIR /path/to/workdir由于Dockerfile中不能使用cd命令，所以我们想要在哪个目录下操作的时候就需要切换进来。为后续的RUN，CMD以及ENTRYPOINT指定工作的目录。可以使用多个WORKDIR命令，如果后面为相对路径，则是针对当前目录确定的。比如： 123WORKDIR /aWORKDIR bWORKDIR c 那么最后进入的目录就是/a/b/c，记住啦，别搞混了哦！ 参考书籍：《Docker技术入门与实战》","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Docker","slug":"架构师/Docker","permalink":"http://qinjiangbo.com/categories/架构师/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://qinjiangbo.com/tags/Docker/"},{"name":"命令","slug":"命令","permalink":"http://qinjiangbo.com/tags/命令/"}]},{"title":"利用Docker建立Gitlab私服","slug":"build-gitlab-private-repository-with-docker","date":"2017-10-13T13:13:17.000Z","updated":"2017-10-14T14:05:23.000Z","comments":true,"path":"build-gitlab-private-repository-with-docker.html","link":"","permalink":"http://qinjiangbo.com/build-gitlab-private-repository-with-docker.html","excerpt":"","text":"现在越来越多的公司开始使用Git来进行协作开发了，那么如何来管理项目中的代码呢？目前市面上做的非常优秀的工具有Github，几乎每一个开发人员都知道它。国内的有码云，也是一个非常优秀的代码托管平台。但是企业内部的代码不可能放到这些第三方平台托管，因为风险太大了，万一它们没处理好，我们的数据几乎等于和盘托出。所以，Gitlab顺势而生！今天重点介绍如何利用Docker搭建一个内部Gitlab代码托管平台。 安装Gitlab镜像使用docker search gitlab命令查询一下： 123456docker search gitlabNAME DESCRIPTION STARS OFFICIAL AUTOMATEDgitlab/gitlab-ce GitLab Community Edition docker image base... 1417 [OK]sameersbn/gitlab Dockerized gitlab web server 947 [OK]gitlab/gitlab-runner GitLab CI Multi Runner used to fetch and r... 230 [OK]gitlab/gitlab-ee GitLab Enterprise Edition docker image bas... 69 以上是前5条记录，我们需要下载第一条记录。可以看到这个是一个官方镜像，而且我告诉你哦，这个镜像有1G以上，所以，是不是需要搞一个代理呢？待会儿会说明具体如何操作。设置好代理之后，我们可以通过docker pull gitlab/gitlab-ce这个命令将镜像拉取下来。 添加Aliyun代理我使用的系统是MacOS High Sierra，所以，我直接在Docker工具里面添加了。你需要先到Aliyun注册一个账号（如果有的话当我没说），然后开通容器服务。具体步骤如下： 开通服务：https://www.aliyun.com/product/containerservice 选择镜像仓库控制台：https://cs.console.aliyun.com/ 获取镜像加速地址：https://cr.console.aliyun.com/ 我的代理地址是：https://9cc5rund.mirror.aliyuncs.com。设置代理的方式如下：下面的registry-mirrors:No certs for...警告可以忽略。 修改Gitlab内部配置下载好镜像之后，我们需要将其run起来。命令如下： 1$ docker run -d -p 80:80 -p 22:22 -p 443:443 gitlab/gitlab-ce 然后使用docker ps -a命令查看容器情况： 123$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe21b83825a9d gitlab/gitlab-ce \"/assets/wrapper\" 29 hours ago Up 4 hours (healthy) 0.0.0.0:22-&gt;22/tcp, 0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp practical_engelbart 这里需要进入容器修改一下里面的一个网络配置，否则后面我们git clone的时候可能没法连接。 1$ docker exec -it e21 vim /etc/gitlab/gitlab.rb 修改gitlab.rb： 123456789101112131415161718192021## GitLab configuration settings##! This file is generated during initial installation and **is not** modified##! during upgrades.##! Check out the latest version of this file to know about the different##! settings that can be configured by this file, which may be found at:##! https://gitlab.com/gitlab-org/omnibus-gitlab/raw/master/files/gitlab-config-template/gitlab.rb.template## GitLab URL##! URL on which GitLab will be reachable.##! For more details on configuring external_url see:##! https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlab# external_url 'GENERATED_EXTERNAL_URL'external_url 'http://192.168.31.145/'## Legend##! The following notations at the beginning of each line may be used to##! differentiate between components of this file and to easily select them using##! a regex.##! ## Titles, subtitles etc##! ##! More information - Description, Docs, Links, Issues etc. 上面的192.168.31.145是本机的ip地址。设置完毕以后重启容器： 1$ docker restart e21 OK！ 运行应用我们打开地址http://localhost，80端口可以省略端口号的。可能一开始会出现502的画面，就像这样：没关系，那是因为Gitlab的各项系统服务正在启动，过一会儿刷新就好啦。然后会要求设置新的密码，设置完成以后我们就进入了Gitlab的页面。创建一个项目Hexo-Workflow，如下：其中我们可以看到git clone的地址是git@192.168.31.145:Richard/Hexo-Workflow.git，在我们进行git clone之前，我们需要向Gitlab添加一下我们本机的SSH Key实现免登。具体页面如下：好的，添加完成以后，我们就可以在本地把这项目拉取下来啦。 12345678910$ git clone git@192.168.31.145:Richard/Hexo-Workflow.gitCloning into 'Hexo-Workflow'...The authenticity of host '192.168.31.145 (192.168.31.145)' can't be established.ECDSA key fingerprint is SHA256:SYHTQxwLpe9OaeQW6f/QRhtQDnXl+zkaQVtZzeObjGQ.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.31.145' (ECDSA) to the list of known hosts.remote: Counting objects: 13, done.remote: Total 13 (delta 0), reused 0 (delta 0)Receiving objects: 100% (13/13), 19.95 KiB | 6.65 MiB/s, done.Resolving deltas: 100% (2/2), done. 然后就和在Github提交代码等操作是一样。 总结Gitlab作为一种非常优秀的代码托管工具已经被广泛地应用到了各个大公司，一般是作为企业内部的代码托管工具。 搭建内部代码托管平台的好处不言而喻，关键是非常地易于管理，给管理员有很大的自主性，而不是受制于第三方平台的约束。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Docker","slug":"架构师/Docker","permalink":"http://qinjiangbo.com/categories/架构师/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://qinjiangbo.com/tags/docker/"},{"name":"gitlab","slug":"gitlab","permalink":"http://qinjiangbo.com/tags/gitlab/"}]},{"title":"利用Docker运行SpringMVC程序","slug":"run-springmvc-web-application-in-tomcat-with-docker","date":"2017-10-13T13:12:55.000Z","updated":"2017-10-14T14:00:45.000Z","comments":true,"path":"run-springmvc-web-application-in-tomcat-with-docker.html","link":"","permalink":"http://qinjiangbo.com/run-springmvc-web-application-in-tomcat-with-docker.html","excerpt":"","text":"本文主要介绍如何利用Docker来运行一个Web应用程序。因为博主是以Java为主，所以来讲一讲我们最熟悉的SpringMVC应用程序是如何在Docker中跑起来的。首先要检查一下我们需要的东西： Docker (https://store.docker.com/editions/community/docker-ce-desktop-mac) Tomcat (http://www-eu.apache.org/dist/tomcat/tomcat-8/v8.5.23/bin/apache-tomcat-8.5.23.tar.gz) JDK (http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz) 这三大件就是我们整个应用能启动成功运行的基础。 安装环境我们需要为这个应用建立一个镜像，首先创建一个目录用于存放Dockerfile以及Tomcat和JDK等环境。 1$ sudo mkdir centos_tomcat 进入centos_tomcat目录，下载我们必须的一些环境（Docker的安装就不演示了，默认看这篇文章的你已经安装好了Docker~）： 1234567$ cd centos_tomcat$ wget http://www-eu.apache.org/dist/tomcat/tomcat-8/v8.5.23/bin/apache-tomcat-8.5.23.tar.gz$ wget http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz$ tar -zxvf apache-tomcat-8.5.23.tar.gz$ tar -zxvf jdk-8u144-linux-x64.tar.gz$ lsapache-tomcat-8.5.23 jdk1.8.0_144 好了，目前这两个环境已经准备好了，我们现在需要准备一下Dockerfile和启动脚本。 编写启动脚本将启动脚本的命名定为run.sh，（貌似大家都在用这个名字，如果你觉得不对，可以随便改哈~），脚本如下： 123#!/bin/bash/usr/sbin/sshd -D &amp;exec $&#123;CATALINA_HOME&#125;/bin/catalina.sh run 注意到上面脚本中第一行为/usr/sbin/sshd -D &amp;，这是因为我们将需要这个容器提供SSH连接服务，也就是说，我们会继承上一篇博客实现的SSH镜像。这里的&amp;符号表示以后台服务启动。 编写Dockerfile关于SpringMVC项目如何的创建以及打包不在本文的讨论范围之内，如果你不明白的话可以查找相关的文章参考一下。我们已经创建好了一个应用叫SpringDocker，使用Maven进行构建，打成了一个war包。 我们的基础镜像是sshd_centos，脚本如下： 123456789101112131415161718192021222324252627# 指定基础镜像FROM sshd_centos# 维护者信息MAINTAINER qinjiangbo&lt;qinjiangbo1994@163.com&gt;# 设置环境变量ENV CATALINA_HOME /tomcatENV JAVA_HOME /jdk# 复制tomcat和jdk到镜像中ADD apache-tomcat-8.5.23 /tomcatADD jdk1.8.0_144 /jdk# 加入应用到镜像中ADD SpringDocker.war /tomcat/webapps# 添加启动脚本ADD run.sh /usr/local/sbin/run.shRUN chmod 755 /usr/local/sbin/run.shRUN chmod 755 /tomcat/bin/*.sh# 开放端口EXPOSE 8080# 容器启动执行脚本CMD [\"/usr/local/sbin/run.sh\"] 脚本写好了以后需要执行构建命令： 123456789101112131415161718192021222324252627282930313233343536373839404142$ docker build -t tomcat_centos . Sending build context to Docker daemon 396.5MBStep 1/12 : FROM sshd_centos ---&gt; f0560ea85754Step 2/12 : MAINTAINER qinjiangbo&lt;qinjiangbo1994@163.com&gt; ---&gt; Running in 3d71c2c9cf98 ---&gt; f0460a80934dRemoving intermediate container 3d71c2c9cf98Step 3/12 : ENV CATALINA_HOME /tomcat ---&gt; Running in f5c8cd1f054d ---&gt; 39e81d6b6091Removing intermediate container f5c8cd1f054dStep 4/12 : ENV JAVA_HOME /jdk ---&gt; Running in 4b4b8e85e787 ---&gt; 5573f336885eRemoving intermediate container 4b4b8e85e787Step 5/12 : ADD apache-tomcat-8.5.23 /tomcat ---&gt; fb62c6291978Step 6/12 : ADD jdk1.8.0_144 /jdk ---&gt; 19b628cc8a47Step 7/12 : ADD SpringDocker.war /tomcat/webapps ---&gt; e635cb335ec9Step 8/12 : ADD run.sh /usr/local/sbin/run.sh ---&gt; 632faa035eeaStep 9/12 : RUN chmod 755 /usr/local/sbin/run.sh ---&gt; Running in ce1d588035eb ---&gt; bf74faf09c94Removing intermediate container ce1d588035ebStep 10/12 : RUN chmod 755 /tomcat/bin/*.sh ---&gt; Running in e80f74764da3 ---&gt; cc700674e693Removing intermediate container e80f74764da3Step 11/12 : EXPOSE 8080 ---&gt; Running in 8f472a55cb02 ---&gt; 954525411f30Removing intermediate container 8f472a55cb02Step 12/12 : CMD /usr/local/sbin/run.sh ---&gt; Running in 81ed01144c89 ---&gt; 6712f0870a5bRemoving intermediate container 81ed01144c89Successfully built 6712f0870a5bSuccessfully tagged tomcat_centos:latest 注意到构建命令的最后还有一个.哈，表示当前目录，否则的话需要指定全路径的。使用docker images来查看我们已有的镜像： 1234567$ docker images REPOSITORY TAG IMAGE ID CREATED SIZEtomcat_centos latest 6712f0870a5b 29 seconds ago 615MBsshd_centos latest f0560ea85754 2 days ago 221MBnginx latest 1e5ab59102ce 4 days ago 108MBgitlab/gitlab-ce latest 453d64ae84c7 8 days ago 1.28GBcentos latest 196e0ce0c9fb 4 weeks ago 197MB 可以看到镜像已经构建完成。接下来就是运行我们的SpringMVC应用。 运行应用查看当前目录： 123$ lsDockerfile apache-tomcat-8.5.23 run.shSpringDocker.war jdk1.8.0_144 启动容器来运行应用： 12345$ docker run -d -p 8080:8080 -p 22:22 tomcat_centos203eafc6d2e0935ca77690a6decf1edc772281354f86295dd82028ca50c461a5$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES203eafc6d2e0 tomcat_centos \"/usr/local/sbin/r...\" 6 seconds ago Up 8 seconds 0.0.0.0:22-&gt;22/tcp, 0.0.0.0:8080-&gt;8080/tcp flamboyant_carson 输入http://localhost:8080/SpringDocker/查看一下页面效果：运行成功！","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Docker","slug":"架构师/Docker","permalink":"http://qinjiangbo.com/categories/架构师/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://qinjiangbo.com/tags/docker/"},{"name":"tomcat","slug":"tomcat","permalink":"http://qinjiangbo.com/tags/tomcat/"},{"name":"springmvc","slug":"springmvc","permalink":"http://qinjiangbo.com/tags/springmvc/"}]},{"title":"利用Docker创建SSH容器连接","slug":"create-ssh-connection-with-docker","date":"2017-10-11T06:28:15.000Z","updated":"2017-10-11T06:50:22.000Z","comments":true,"path":"create-ssh-connection-with-docker.html","link":"","permalink":"http://qinjiangbo.com/create-ssh-connection-with-docker.html","excerpt":"","text":"本文主要是记录如何利用Docker创建一个可以进行SSH连接的容器，关于Docker的基础命令大家可以自行找官方文档学习。创建Docker镜像主要有两种方式，一种是docker commit，另一种是Dockerfile，第一种的弊端非常明显，因为它不能适应快速变化的部署环境，需要进行手动操作，然后提交到镜像当中；而后一种则可以快速适应变化，只要有Docker的地方它就可以很好地运行。所以，我们来看一下如何利用CentOS7来创建一个可以连接SSH的容器吧！ 123456789101112131415161718192021222324# This Dockerfile is based on centos image# Version: 2017.10.10# Author: QinJiangbo# Command Format: Instruction [arguments / command] ..# 第一行必须指定基于的基础镜像FROM centos# 维护者信息MAINTAINER qinjiangbo&lt;qinjiangbo1994@163.com&gt;# 安装sshRUN yum install passwd openssl openssh-server -y &amp;&amp; yum clean allRUN ssh-keygen -ARUN mkdir -p /root/.sshADD authorized_keys /root/.ssh/authorized_keysRUN chown -R root:root /root/.sshRUN chmod -R 700 /root/.ssh# 开放端口22EXPOSE 22# 容器启动时执行指令CMD [\"/usr/sbin/sshd\", \"-D\"] 在执行这个脚本之前，需要在宿主机上先生成一个ssh文件，然后拷贝到当前目录[/root/sshd] 12sudo ssh-keygen -t rsacat /root/.ssh/id_rsa.pub &gt; authorized_keys 编译镜像： 1docker build -t sshd . 注意结尾是有一个.号的，表示当前目录。 然后再执行脚本： 1docker run -d -p 2222:22 sshd 最后在本地通过ssh就可以进入容器了： 123ssh root@localhost -p 2222Last login: Wed Oct 11 06:48:02 2017 from gateway[root@85a58df25d9c ~]#","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Docker","slug":"架构师/Docker","permalink":"http://qinjiangbo.com/categories/架构师/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://qinjiangbo.com/tags/docker/"},{"name":"centos","slug":"centos","permalink":"http://qinjiangbo.com/tags/centos/"},{"name":"ssh","slug":"ssh","permalink":"http://qinjiangbo.com/tags/ssh/"}]},{"title":"macOS下Vim配色方案","slug":"vim-colorscheme-in-macOS","date":"2017-10-11T02:50:18.000Z","updated":"2017-10-11T03:11:31.000Z","comments":true,"path":"vim-colorscheme-in-macOS.html","link":"","permalink":"http://qinjiangbo.com/vim-colorscheme-in-macOS.html","excerpt":"","text":"最近重装了macOS系统，结果以前的配置全部丢失了，然后又按照官网的要求重新安装了一下VIM的主题。结果发现一直和官方的配色对不上，不知道啥情况。之前的配置是这样的： 123syntax enableset background=darkcolorscheme solarized 对应的配色情况如下：什么鬼？！不是说好的靛青色背景吗？！官方也一直没有给出正面的回复，去Github主页查找也没有查找到对应的解决方案，直到找到一个论坛，也遇到了和我一样的问题，受他们回复的启发，我尝试加了两行配置，如下： 12345syntax enableset background=darklet g:solarized_termcolors=16let g:solarized_termtrans=1colorscheme solarized 添加完成，效果果然出来了，手动比上金星老师的标志性动作，完！美！ 贴上论坛的地址：http://bbs.feng.com/read-htm-tid-10995409-page-3.html","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"solarized","slug":"solarized","permalink":"http://qinjiangbo.com/tags/solarized/"},{"name":"vim","slug":"vim","permalink":"http://qinjiangbo.com/tags/vim/"},{"name":"配色","slug":"配色","permalink":"http://qinjiangbo.com/tags/配色/"}]},{"title":"毕玄分享会心得体会","slug":"thoughts-of-sharing-of-bixuan","date":"2017-09-28T15:53:00.000Z","updated":"2018-09-02T10:13:29.000Z","comments":true,"path":"thoughts-of-sharing-of-bixuan.html","link":"","permalink":"http://qinjiangbo.com/thoughts-of-sharing-of-bixuan.html","excerpt":"","text":"来阿里很早之前就听师兄们说起过毕玄大神，我也是因为HSF才更加了解他。我的第一印象就是敬佩，毕竟不是谁都能写出一个能承载日均访问量过亿的中间件的。希望通过这一次分享会更加进一步了解他的发展历程，对于自己也是一种指导，果然没有让我们失望，分享会满满的干货，收获非常大！ 关于毕玄大神的分享会其实红学会早在一星期前就摆起了海报，所以大家都知道是今天（09月28号下午15:00-17:00），所以我们两点四十就去占座了，不一会儿现场就满座了，可想而知他的影响力多大！ 毕玄主要从他在阿里的发展经历来说的，而每一件事情都对阿里产生了非常深远的影响。按时间的先后顺序主要是以下几件事情，下面详细展开。每一件事情他都会分享做这件事情的原因（为什么做）以及做了产生了什么影响。我觉得这点很重要，在我们日后的工作中也需要做到不仅知道how，更要知道why。 HSFHSF分布式服务框架研发，那是他来阿里的前两个月，压力很大，虽然一波三折，也踩过很多坑，但是HSF成功上线了，并且后来在集团内部全面推广开了。HSF使我们集团目前使用最广泛的分布式服务框架，几乎所有的开发同学都知道HSF。目前HSF的日平均调用量已经达到100亿次以上。关于为什么要做HSF？他给出了答案，就是淘宝网当时用户数量不断地上涨，访问量不断地加大，而他们面临着一个无法继续增加机器来解决日益增加的用户访问量的困境。这个时候需要技术上的突破，所以，当时的选择就是切分，数据库切分，业务拆分，一个大的应用一下子变成了一百多个小的应用，那么这些应用之间如何高效通信呢？考虑过使用JBOSS自带的通信机制，不过考虑到JBOSS太重了，不利于维护，所以后来就自己重新研发了一套，这就是HSF的由来。仔细想一想，其实每一个技术架构的演变都是有一个大的背景的。网站没有到这个量级的时候就不要轻易尝试业务拆分，否则只会浪费人力物力。 后来有人问到，关于HSF和Dubbo两个分布式RPC框架，毕玄是如何做出选择的，他首先肯定了Dubbo作为RPC框架的各种优势，比如Dubbo的上层做的很好，非常易于拓展，文档齐全，代码结构清晰，因此非常利于开源，而HSF则没有Dubbo这么有优势，但是他有做出了非常简洁的回答就是HSF经过历次双十一的考核，已经被证明是非常稳定的系统，而Dubbo没有经历过，所以我们不能冒这个风险，不能再相HSF刚开始上线的时候那样线上试错，因为我们再也无法承受这样试错带来的后果。所以，最后整个集团决定使用HSF作为最终的选型！ HBASE毕玄谈到HBASE的时候，说到当时全集团各个团队几乎使用到了市面上流行的所有的NoSQL数据库，比如MongoDB，HBASE等等。他对大数据这块也是比较陌生的，但是觉得比较有意思，所以就投身到了大数据的研究，想到整个集团使用了大量的Hadoop，所以整个NoSQL选型他们选择了HBASE，凡是集团和HBASE相关的问题和疑问都可以找他们解决。于是HBASE在集团的使用率越来越高，后来基本上全集团都在使用HBASE。这对中国的互联网行业产生了非常重大的影响，因为阿里使用HBASE，所以整个互联网行业基本上都在往HBASE上靠拢。HBASE也正因为此在中国一下子发展起来了。 T4我一开始看到这个也是非常不解的，T4是什么？毕玄解释道，在做T4之前，集团一台机器上同时只能跑3个应用，资源的利用率极低，浪费了大量的预算。所以，需要寻求一种能够使物理机的使用率大幅提升的解决方案。Linux虚拟化这个领域是毕玄从来没有接触过的领域，但是他需要做成这件事，怎么办呢？他找到了我们集团的神人-多隆。多隆研究了一下Linux的虚拟化技术，使得每一台机器上能同时跑20多个应用，一下子提高了机器的使用率，相当于给集团省了七分之六的机器，这可是一大笔预算啊。技术的提升带来的不仅仅是生产力的提高，还有生产成本的降低。 异地多活为什么要做异地多活呢？首先来介绍一下背景，之前阿里一直是在杭州部署的机房，我们都知道机房是特别特别耗电的，有一年电力特别紧张的时候杭州市政府不得不考虑停掉阿里的机房供电，要知道在民生问题前面什么都可以妥协，但是杭州市政府也没有不管阿里，于是调来了浙江最大的才有发电机供阿里的两个机房供电，这才勉强的度过了难关。毕玄说到，不能再这样被动了，如果明年还发生这种情况，如果明年停掉的是三个机房呢？所以我们得自己处理好这个问题，于是异地多活的项目便展开了，他带领着运维团队的同学们奋战了三年，终于做出了我们自己独特的解决方案，这个问题有多难，世界上还没有一家公司做成过，谷歌做过全球部署，但是也仅仅是广告业务，如果跑电商业务，一上线立马就挂，所以阿里巴巴还是第一家。异地多活成功地解决了异地容灾的问题，大大提升了服务的可用性。 混合云和混部主要说说混部吧，混部其实就是将在线计算和离线计算放在同一台机器上同时计算。说白了就是线上应用和离线应用一起公用资源。问题的关键就是解决CPU的使用率问题。离线计算的任务有一个特征就是给多少资源它就会吃掉多少资源，如果和线上的应用同时部署，那会立马占用线上的应用资源，这个可是一个比较难的挑战。我们给出的解决方案就是改写了CPU线程的调度器，然后又做了一些其他黑科技的工作，带来的效果就是机器的数量没有增加，而整个系统的性能却大大提升，能服务更多的请求。毕玄说到后面我们的目标就是要做到没有一台离线机器，全部都要做成线上机器。因为每一年我们需要采购N多台离线机器，每一台机器不说多的，几十万差不多是有的，所以这个成本是巨大的。混部和混合云给集团节约了巨大的成本。还是那句话，技术的提升带来的不仅仅是生产力的提高，还有生产成本的降低。 心得感悟 毕玄大神：“见过猪跑非常重要” 从被动解决问题到主动发现问题 自己能力的提升价值没有整个团队能力的提升价值大 对自己实施的项目负责到底，直到觉得没有突破的点了","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"毕玄大神","slug":"毕玄大神","permalink":"http://qinjiangbo.com/tags/毕玄大神/"},{"name":"分享会","slug":"分享会","permalink":"http://qinjiangbo.com/tags/分享会/"}]},{"title":"谈谈校园招聘的感受","slug":"talk-about-campus-recruitment","date":"2017-09-18T14:58:17.000Z","updated":"2017-09-18T16:59:49.000Z","comments":true,"path":"talk-about-campus-recruitment.html","link":"","permalink":"http://qinjiangbo.com/talk-about-campus-recruitment.html","excerpt":"","text":"最近不管是QQ群还是微信群都被招聘的信息塞的满满的，这就是秋季校园招聘，各大企业都来学校进行无数场宣讲会，各有各的特色，有的说现场面现场给Offer，有的说薪水给的非常高，有的说企业以后前景非常好等等，各有各的特色。忽然想起自己在去年刚上研究生说的一句话，在研一好好准备一年，厚积薄发，准备在研二的秋招上进行海投，就不信不能砸中一家自己喜欢的，说起这句话的时候仿佛就在昨天。 谈谈大家面试的观感先说说我俩室友对于校园招聘的感受，@文安和@毛毛都有自己的准备。文安之前在腾讯做前端，然后放弃腾讯的前端，毅然投身到后端的研发中，对于这个决定我表示敬佩，因为不是谁都能有勇气做这个决定的。他在我心中一直都是一个非常励志的存在，有自己明确的目标，并且能持续不断地为之努力。文安现在面试是Java研发工程师，其实最早他是想做C++或者Python相关的，但不知怎么地，就或多或少被我带到Java的坑里了。但是我想说，you made the right choice！文安真正意义上的准备面试其实是从今年元月份(2017-01-01)以后开始的，准备了大半年，从Java菜鸟一直到Java大鸟，可以看到他的进步是非常明显的。他是如何学习的呢？一个笔记本电脑，一本Thinking in Java，慕课网，一个印象笔记，that’s all！慕课网的视频非常多，如何在有效地时间内最有效地掌握这些知识，他有自己的思考和方法，他会在看视频的时候跟着老师一起敲一遍代码，其实这个也是我一直提倡的，同学们自己以后学编程的时候也需要注意，看一万遍还不如自己动手敲一遍。与此同时，他会把每天看过的知识点记录到印象笔记，就这样，他的思维非常成体系，非常系统，这就是扎实的基础！也非常开心地看到他现在也收获了，去了携程实习，我相信他转正是没什么问题的！这就是文安，非常值得让人点赞！ 再说说毛毛，毛毛本科的时候就和我是同班同学，他的基础非常不错。他动手能力非常强，所以这也是他面试时候的优势。感觉他就是一个乐天派，比如春季招聘的时候，我和文安就会跟他说，你要赶紧准备面试的一些知识了，别搞到最后来不及，但是他一点也不着急。虽然这么说，但是他自己其实心里面有自己的打算，不紧不慢，跟着自己的节奏。还有一点，他看的书都是非常不错的，都是经过很多人一起推荐得出的，因此也能给他吸收有效知识省不少时间。这一点也非常重要，大家需要根据自己的节奏去学习，还需要对自己所学习的书籍有一个宏观的认识，就是这本书的评价如何，避免自己读了一本“让自己没有收获”的书。目前他已经很轻松面完了华为，估计很快就能拿到OFFER了。透露一个秘密，毛毛游戏玩的可是非常不错的，王者大神！有机会的可以找他切磋切磋。 微信里面有一个秋招群，是实验室的同学们组的，每天都会收到大家在群里面的消息，大家最近这段时间也都是非常的忙，其实不仅仅是在准备面试，更多的时候也是在思考自己以后的方向和去向。有的同学不想去北京，想去深圳，有的同学不想留杭州，想去北京，上海等等。我觉得这些思考非常宝贵，人很少有时间这么直面自己的内心，我想跟大家说的是，follow your heart，全力以赴了，你们最后做的决定一定都是正确的！ 如何准备秋招其实面经大家写的非常多了，有需要的可以自己去牛客网查看。这里主要说说大致的思路，针对不同的人群给出不同的建议。 对于完全没有基础的同学而言，你需要早一点准备的，就像文安一样，时间的跨度稍微长一点。大家可以根据对应的技术栈梳理出自己需要掌握的知识点。并且结合自己的实际情况形成自己的知识体系。一定不要模仿，每个人的情况都不一样，别人的方法成功了，在你这儿可不一定哦！所以，一定要对自己有一个客观全面的认识，不妨将这些技术栈全部罗列到一张纸上，然后结合实际情况客观地给每个打分，0-5分表示掌握的程度，如果大多数都是3分以下，那说明你需要好好评估一下自己准备的时间了，估计一下自己到校园招聘还有多久，如果还很长，那么你可以细细地规划，如果就在眼前了，我建议你挑重点看，挑基础看。校招面试考查的更多还是面试者对于整个技术体系的基本掌握情况。当然，如果你想脱颖而出，不妨再看看使用的比较多的技术架构的原理是如何实现的，最好能读一下开源项目的源码，面试能讲出一二都是能让人印象深刻的。 对于有基础的同学而言，对于整个技术栈还是需要过一遍，不过可以非常快地过一遍，不需要花太多时间。以研发岗位为例，重点应该关注在整个行业目前所使用的技术栈有哪些，你的意向公司使用的技术栈是什么，有没有开源出去，如果有的话，它的技术原理是什么，技术架构是什么，这些如果你能提前准备，在面试的时候面试官一定会对你有印象，至少一点，他会认为招你进来不用花太多的培训时间，培训成本低。有时间一定要看看优秀开源项目的源码实现，如果没时间，至少应该了解它的架构设计，对于其中的妙处，你需要看看源码，了解它是如何这么巧妙的实现的。 研发同学，算法为王不管是哪个企业，在招聘研发工程师的一定会考一考他的算法基本功，其中快速排序已经快被考烂了，大家对于七种常见的排序一定要非常清楚，至少伪代码能写出来。它们的最优情况复杂度是多少，最坏情况复杂度又是多少，这些不用背，但是需要通过自己的理解得出来。还有的就是字符串的操作了，可能会问到KMP算法，还有哈夫曼算法，不一定要求现场写代码，但是基本原理还是需要知道。 除此之外，OJ里面会经常有些题目被挑出来考查，比如LeetCoe或者是LintCode，这两个都是非常优秀的在线测评系统，大家可以在上面刷刷题，活跃活跃自己的思维。算法这个东西其实并不难，重点是要多做，你做得多了就知道这个套路了，以后遇到类似的问题你能很快地给出自己的解决方案，这就足够了。如果你想在算法领域有所建树，那建议你深挖下去，自己创造一套更优的算法，这也算是对这个行业的一个巨大贡献了。 树立信心，Yes, I can!想想当初面试腾讯和阿里的时候紧张的不行，虽然别人说你可以的，但是自己心里还是有点忐忑不安，害怕说错话，害怕答不上来。但是我想说的是，你越是这样想，越紧张，越影响你正常的学习和工作。我的建议是，暂时不要想它，好好想一想怎么准备才是王道，其实当你投身准备的时候，你反而不着急了，不紧张了，因为那些导致你紧张的问题都被你解决了。准备的越充分，越有信心！一直都在说的一句话，机会是留给有准备的人，真正踏实准备了，你就是最好的状态去迎接挑战，没什么好畏惧的！一句话与君共勉：If not now, when? If not me, who?","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"校招","slug":"校招","permalink":"http://qinjiangbo.com/tags/校招/"}]},{"title":"多谈架构，少谈框架","slug":"talk-more-architecture-less-framework","date":"2017-09-04T14:52:26.000Z","updated":"2017-09-10T13:01:20.000Z","comments":true,"path":"talk-more-architecture-less-framework.html","link":"","permalink":"http://qinjiangbo.com/talk-more-architecture-less-framework.html","excerpt":"","text":"很久没有写过非技术类的博客了，最近一直都在忙工作上的事情，都没有时间来总结一下最近的生活感想。突然想到思维这个主题，其实很久都不知道思考和思维的区别，甚至说和思想的区别，今天就来好好聊一聊。 多谈架构，少谈框架搞技术的人其实很容易明白这二者的区别，架构包括很多方面，比如你网站使用的技术栈（比如SpringBoot + Shiro + MySQL + FreeMarker等等），你网站使用的设计风格（扁平化，拟物化等等），这一些都属于架构的范畴。而框架的范畴则小很多，我们说SpringBoot它就是一个框架，一个微服务框架。再说说谷歌设计风格Meterial就属于扁平化风格。粗略地说，框架其实是一个更具体的实现，而架构这是着一些具体实现的一个抽象集合。 那么，我为什么举这个例子呢？对于技术人员而言，框架是对一些复杂操作的封装，使得我们完成一些功能的时候更加方便简洁，而架构需要你对整体有一个全面的认识，需要你有对应的领域知识，能够建立起一个领域模型，这样你的架构才能行得通。通过这样一描述，其实不难发现，架构对技术人员的要求远远比框架对技术人员的要求要高。因此，一般来说，架构都是那些架构师的工作了，如果我们想往上走，具备对应的领域建模能力是必不可少的。也不是否定框架的价值了，框架的价值也是巨大的，但是其实在平时的工作中，大多数程序员都是浅度用户，只是会很熟练的使用用，而没有花时间去深究底层的原理，其实如果深究底层的原理，又转变为了一个架构上的事情了，就是这个框架本身的架构设计了。 为什么比做什么更重要这句话说得有点空，那我自己的经历来说吧，在面试的过程中，一般面试官都会问你做过什么项目？然后你以为他会针对其中的某个技术难点来做分析，so，你准备了很久技术上的答案。然而，在问过这些技术问题之后，一般他们都会问为什么要做这个问题？这个时候其实大多数面试者都会犹豫一阵子才能勉强给出一个说得通的答案，但是如果我们平时就多多思考我们到底为什么要做我们现在的事情，这个或许更有意义！对业务的思考和对技术的思考同样重要。因为你知道技术上怎么实现，但是你不知道它能解决我们实际生产当中的什么痛点，这个就很悲剧了，那其实这个技术是没有产生它应有的价值的。再就是我们做成了一个好的产品之后，我们再回过头来问问自己为什么要做这个？其实这个时候往往就是我们沉淀自身的时候，不论是技术的沉淀也好还是业务的沉淀也好，对我们以后的工作和决策都是非常有益的。 思考应该是一个人的常态。记得小时候自己最讨厌做数学题，尤其是思考题，为什么呢？因为它很难，要花时间好好思考，而那些计算题则非常简单，不用多大思考就可以解出来。但是往往能把思考题做出来的同学其实最后取得结果都非常不错，为什么呢？因为这里体现的是一个思维的锻炼过程，如果一个人长期不思考，他的思维势必会慢慢“钝化”，思考问题的方式也会变得更不上时代，想问题没有那么全面。思考不是说非得每天做一些很难的事情，而是让自己形成一个习惯就是，凡事多多想想自己为什么要做它？它能解决什么痛点？它的价值是什么？只有多多思考这些问题之后，我们才能有的放矢，其实想好以后，做起来都非常地简单了。 思考、思维和思想 思考其实是一个具体的动作和过程，体现的是你对某一事情正在进行的一些脑力动作。 思维其实是指思考的方式方法，用于解决某一个特定的问题场景。 思想其实是一个更大的范围，它指一套成熟的方法论，对于解决诸多问题都有非常好的指导和借鉴意义。 平时，思维和思想这两个词其实离我们还是挺远的，因为都不怎会碰到。而思考这个词则会被提及的非常多，“需要多多思考”，“思考人生的意义和价值”，“思考一个难题”等等，这些都是我们平时会谈及的话题，那么，思考作为一种具体的切实的“动作”，我们应该如何应对呢？拥抱思考是这个问题最好的解决方式，不管是生活中还是工作中的事情，凡事多问问为什么总是没有错的，只有问得多了你才会对这些问题有更深的理解，即使以前可能会对它存在一些误解等等。 思维和思想也非常的重要，但是它们使我们在不断地思考过后所产生的一个结果，这个结果的产生是自然的，因为思考的多了，自然就会形成自己的一套看待问题的方式和方法，这些就是思维和思想。思维某种意义上来说是一种能力，表示你对这个问题的一种独到的思考方式，而思想某种意义上其实是你的一种收获，表示你通过不断地思考所总结出来的一个普适的方法论。 总结其实主要就是要明白为什么比做什么更重要以及多谈谈架构，少谈谈框架。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://qinjiangbo.com/tags/思维/"},{"name":"思考","slug":"思考","permalink":"http://qinjiangbo.com/tags/思考/"}]},{"title":"高性能MySQL之多版本并发控制MVCC（六）","slug":"high-performace-mysql-mvcc","date":"2017-08-31T15:40:50.000Z","updated":"2017-09-02T15:07:59.000Z","comments":true,"path":"high-performace-mysql-mvcc.html","link":"","permalink":"http://qinjiangbo.com/high-performace-mysql-mvcc.html","excerpt":"","text":"锁的代价前面一节讲到过死锁，以及事务型数据库中需要经常地检测死锁的问题，提出的对应解决方案就是使用行级锁，将需要锁定的行锁定起来。那么，这里就不得不说到锁的代价了，其实锁定一行的代价还是很高的，因为它对其它事务来说就是在短期内不可用的了，这对数据库的吞吐量来说是极大的损害！ 那么有没有什么方法能有效地减少锁的的创建呢？这就是我们接下来要介绍的MVCC啦。MVCC其实是行级锁的一个变种，但是很多情况下它都避免了锁的创建操作，所以整个数据库的用在锁的开销很低。实现的方式主要是非阻塞的读操作和锁定必须行的写操作。 MVCC多版本并发控制MVCC的实现，是通过保存数据在某个时间点的快照来实现的。这句话怎么理解呢？如果妳看过前面的几篇文章，就会明白事务的一致性特性，也就是说不管什么时候，每个事务看到的数据都是一致的。根据事务的开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的，但是对于这个事务本身来说，数据必须是要是一致的。 版本控制 Version Control这里以MySQL的默认存储引擎InnoDB为例，说一说MVCC是如何实现的？InnoDB中，MVCC是通过在每一行记录后面保存两个隐藏的列来实现的。分别是创建时间gmt_create和过期时间（或删除时间）gmt_expire。这里存储并不是真实的时间值，而是系统的版本号，这个版本号是会依次累加的。比如说事务N开始的时候系统的版本号为666，那么这个事务的版本号就会从666开始，也就是说gmt_create会存储为666。主要是到了后面对数据进行操作的时候可以和记录的版本号作对比，看数据是否已经被修改了。 MVCC的CRUD具体操作为了具体地给大家解释MVCC下数据库的CRUD四种操作是如何执行的，我们以MySQL在REPEATABLE READ（可重复度）的隔离级别下，看看MVCC的具体操作。 SELECTInnoDB会根据以下的两个条件来检查每条记录： InnoDB只查找版本早于当前事务版本的数据行（也就是说，其它大于当前系统版本号的数据行都是在本事务开始后被操作过的），这样可以确保事务读取的行都是事务自己插入或者修改过的，或者是事务开始前就已经存在的。 行的删除版本要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行，在事务开始之前未被删除。 只有符合上述两个条件的记录，才能被返回作为查询的结果。 INSERTInnoDB为新插入的每一行数据保存当前系统版本号作为数据行版本号。 DELETEInnoDB为删除的每一行数据保存当前系统版本号作为当前的数据行的删除标识。 UPDATEInnoDB插入一行新的数据，保存当前的系统版本号作为这一行的版本号，同时保存当前的版本号到原来的那行数据作为它的删除版本号。 总结保存这两个额外的版本号其实对于大多数读操作来说，都是不需要加锁操作的。这样设计我们前面也说过了，有利于减少系统因为加锁带来的巨大开销，这样性能也会更好！但是不足之处就是每一条记录都需要额外的空间，需要做更多的一致性检查工作。 MVCC只会在REPEATABLE READ和READ COMMITTED两个隔离级别下工作，为什么呢？因为其他两个隔离级别READ UNCOMMITTED和SERIALIZABLE和MVCC是不兼容的，READ UNCOMMITTED只会读取最新的数据行记录，不是当前的事务版本号之前的数据行哦！SERIABLIZABLE则是会对所有的数据行都会加锁，WTF！多么耗空间啊！大家在实际的生产环境下没有特别严格的需要千万不要随便使用最后一种事务隔离级别SERIALIZABLE，它可是性能杀手！","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"MySQL","slug":"数据科学/MySQL","permalink":"http://qinjiangbo.com/categories/数据科学/MySQL/"}],"tags":[{"name":"事务","slug":"事务","permalink":"http://qinjiangbo.com/tags/事务/"},{"name":"MVCC","slug":"MVCC","permalink":"http://qinjiangbo.com/tags/MVCC/"}]},{"title":"高性能MySQL之死锁（五）","slug":"high-performace-mysql-dead-lock","date":"2017-08-30T15:10:50.000Z","updated":"2017-08-30T15:54:21.000Z","comments":true,"path":"high-performace-mysql-dead-lock.html","link":"","permalink":"http://qinjiangbo.com/high-performace-mysql-dead-lock.html","excerpt":"","text":"死锁本文聊一聊事务中的死锁现象。死锁的定义是什么？死锁是指两个或者多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定相同的资源时，就很容易产生死锁。或者是多个事务同时锁定某一个相同的资源时，也非常容易产生死锁哦！ StockPrice表实例分析假设现在有两个事务同时针对StockPrice表进行相关的操作，如下： 事务一： 1234START TRANSACTION;UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 AND date = '2015-05-01';UPDATE StockPrice SET close = 19.80 WHERE stock_id = 3 AND date = '2015-05-02';COMMIT; 事务二： 1234START TRANSACTION;UPDATE StockPrice SET high = 20.12 WHERE stock_id = 3 AND date = '2015-05-02';UPDATE StockPrice SET high = 47.20 WHERE stock_id = 4 AND date = '2015-05-01';COMMIT; 这两个事务同时执行会发生什么呢？我们可以看到哈，事务一和事务二都执行完第一条SQL语句时，事务一因为操作了stock_id为4且date为2015-05-01的记录，因此锁定了第一条记录；同时事务二因为操作了stock_id为3且date为2015-05-02的记录，因此锁定了第二条记录；那么它们在执行第二句的时候，大家都是获取不到这个资源的，因为这个资源分别被两个事务占用了，这就形成了一个典型的死锁。解决的办法很简单，回滚其中的一个事务即可，因为这样就释放掉了其中一条记录的锁，以致于另一个事务可以正常地执行下去。 MySQL死锁解决方案在MySQL中，死锁是如何解决的呢？一般来说，数据库系统提供了两种解决死锁的办法：死锁检测和死锁超时。 死锁检测是如何做到的呢？数据库会检测到存在循环依赖，这个时候就表示发生了死锁，因为没有一个资源的条件能得到满足。一般来说，InnoDB能够比较迅速地检测到死锁的存在，并立即返回一个错误给用户。这种解决方式非常的有效，能够有效地避免用户进行一些无效地查询，以及慢SQL的出现。 死锁超时是另一种非常常规的解决思路，就是当查询的时间超过多少秒的时候，数据库引擎放弃执行这条SQL，但是这种方式不太友好，会产生大量的重复查询，浪费数据库资源。 InnoDB目前的做法就是将数据库中持有最少行级排他锁的事务进行回滚，这样其它的事务就有机会去获取对应的资源。 死锁产生原因死锁产生的原因主要有两个：数据的冲突和存储引擎实现方式不同。一般来说，死锁产生的时候只需要回滚其中一个或多个事务就可以打破死锁的局面，让其它事务继续进行下去。我们再额外地执行被回滚的事务即可。","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"MySQL","slug":"数据科学/MySQL","permalink":"http://qinjiangbo.com/categories/数据科学/MySQL/"}],"tags":[{"name":"事务","slug":"事务","permalink":"http://qinjiangbo.com/tags/事务/"},{"name":"死锁","slug":"死锁","permalink":"http://qinjiangbo.com/tags/死锁/"}]},{"title":"高性能MySQL之事务隔离级别（四）","slug":"high-performace-mysql-isolation-level","date":"2017-08-28T15:50:50.000Z","updated":"2017-08-28T16:29:10.000Z","comments":true,"path":"high-performace-mysql-isolation-level.html","link":"","permalink":"http://qinjiangbo.com/high-performace-mysql-isolation-level.html","excerpt":"","text":"事务概念回顾这里再回顾一下事务的概念：事务一组原子性的SQL查询。事务处理系统一般包括四个特性ACID（原子性Atomicity，一致性Consistency，隔离性Isolation以及持久性Durability）。今天重点聊一聊这里面的隔离性Isolation。 隔离级别隔离性远比想象的要复杂很多，因为涉及到系统各个事务之间的数据更新操作可见性。一般来说，隔离级别会分为四种： READ UNCOMMITTED（读未提交） READ COMMITTED（读已提交） REPEATABLE READ（可重复度） SERIALIZABLE（序列化） 这四种隔离级别的程度从上往下是依次加深的，各个事务操作的可见性逐渐变弱。下面分别说说这四种隔离级别的具体特征： READ UNCOMMITTED（读未提交）在这个隔离级别中，任何事务中对数据库修改的操作，对其他事务都是可见的。也就是说，当前事务修改了数据库的某一条数据，还没有提交这个事务的时候，另一个事务就已经能够读取到这个修改后的数据了。这往往不是我们所需要的，因此也容易发生DIRTY READ（脏读）。从性能上来说，这个隔离级别并不会比其他的隔离级别高很多，而相反，它带来的数据不一致性问题会造成更大的问题，因此，博主建议一般情况不要在数据库中设置这个隔离级别。 READ COMMITTED（读已提交）这个隔离级别就是说，一个事务只有将自己提交以后，所做的操作对其他的事务才可见。这很符合我们事务的定义，不是吗？但是往往会存在一个问题就是，在这个隔离级别下，一个事务查询两次执行的结果可能是不一样的。因为可能一个事务查询两次执行的间隙有一个事务提交了，那么这个查询查出来的结果就不一样的。因此这个级别也叫不可重复度（NON-REPEATABLE READ）。 REPEATABLE READ（可重复度）这个隔离级别是相对前一个而言的，该级别保证了同一个事务中的同一个操作多次执行的结果是相同的。这个隔离级别是MySQL的默认隔离级别。但是理论上这个隔离级别还是不能阻止幻读（PHANTOM READ），所谓幻读，就是某个事务在读取某一范围的数据时，另一个事务在一段数据中添加了一些新的数据，当前事务读出了一些原本没有的数据，就是幻读！MySQL中InnoDB通过MVVC（多版本并发控制）解决了幻读的问题。 SERIALIZABLE（序列化）这个是最高的隔离级别，这个很暴力的就是直接在表的每一行加上一个锁。这样能保证每一条数据的更新都是原子性的。但是带来的问题是数据库的性能大大降低。一般不建议使用这个隔离级别，太耗性能了！ SQL四种隔离级别对比 隔离级别 脏读可能性 不可重复度可能性 幻读可能性 加锁读可能性 READ UNCOMMITTED Yes Yes Yes No READ COMMITTED No Yes Yes No REPEATABLE READ No No Yes No SERIALIZABLE No No No Yes","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"MySQL","slug":"数据科学/MySQL","permalink":"http://qinjiangbo.com/categories/数据科学/MySQL/"}],"tags":[{"name":"事务","slug":"事务","permalink":"http://qinjiangbo.com/tags/事务/"},{"name":"隔离级别","slug":"隔离级别","permalink":"http://qinjiangbo.com/tags/隔离级别/"}]},{"title":"高性能MySQL之事务（三）","slug":"high-performace-mysql-transaction","date":"2017-08-20T13:15:50.000Z","updated":"2017-08-27T15:15:14.000Z","comments":true,"path":"high-performace-mysql-transaction.html","link":"","permalink":"http://qinjiangbo.com/high-performace-mysql-transaction.html","excerpt":"","text":"事务先说说什么是事务？不同的同学对这个概念有很多不同的理解。我以前对事务就有很长时间的不理解，单纯认为事务是一件很复杂的事情，到底多复杂，我也不清楚，总之就是需要处理各种操作的事情。现在给出一个比较准确的定义哈，数据库中的事务就是指一组原子性的SQL查询，或者说一个独立的工作单元。这句话怎么理解呢？你一共要执行一些SQL语句去完成某个操作对吧，但是完成的过程当中，执行到一半的时候，某个语句失败了，那么这个时候你的这些SQL语句就完不成这个操作了，因为数据有问题了，也就是说，在一个事务内的所有SQL语句，要么全部成功完成一个操作，要么就全部失败回滚。 银行应用示例假设一个银行的数据库中存在两张表，分别是支票表（checking）和存储表（savings）。现在要从一个用户A想要从他的支票账户里面转移200元到存储账户，那么他需要经过三个步骤： 检查支票账户月是否高于200元 从支票账户里减除200元 在存储账户里添加200元 这三个步骤的操作必须包括在同一个事务当中，任何一个步骤失败，则必须回滚所有的步骤。那么应该如何来做呢？ 在MySQL中，我们可以使用START TRANSACTION语句来表示开启了一个事务，然后要么使用COMMIT提交事务将修改的数据持久化入库，要么就使用ROLLBACK撤销所有的修改。事务SQL的示例如下： 12345START TRANSACTION;SELECT balance FROM checking WHERE customer_id = 10249076;UPDATE checking SET balance = balance - 200 WHERE customer_id = 10249076;UPDATE savings SET balance = balance + 200 WHERE customer_id = 10249076;COMMIT; 这些SQL啥子意思呢？也就是说，这几句SQL只要有一句比如UPDATE savings SET balance = balance + 200 WHERE customer_id = 10249076;执行失败了，那么整体就必须回滚！也就是说前面执行的UPDATE checking SET balance = balance - 200 WHERE customer_id = 10249076;就会被撤销，不再会写入库中去。 ACID四原则前面提到了事务的基本概念，说到事务，不说ACID等于耍流氓！所以，这里好好聊聊ACID四中类型。分别是原子性（Atomicity），一致性（Consistency），隔离性（Isolation）和持久性（Durability）。一个设计良好的系统，必须具备这几个特性。下面分别说说这个几个特性： 原子性Atomicity一个事务必须被视为一个不可分割的最小工作单元，整个事务中所有的操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。 一致性Consistency数据库总是从一个一致性的状态转换到另一个一致性的状态。在银行示例这个例子中，一致性确保了，当系统执行完第三、四条语句之间时崩溃，支票账户中也不会损失200元，因为事务还没有被提交，所以事务中的操作是不会写入到数据库中的。 隔离性Isolation通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。也就是说，前面的第三条语句执行完，第四条语句还没有开始执行的时候，可能会有另一个汇款的程序开始执行，这个时候另一个程序看到的支票账号余额还是减掉200元以前的状态，前一个事务所做的操作对这个程序是不起作用的，也就是说“是不可见的”。后面会谈到事务的几个隔离级别。 持久性Durability一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，数据库也能保证你的数据不会丢失。 One More一个实现了ACID特性的数据库，相比没有实现ACID的数据库，通常会需要更强的CPU处理能力，更强大的内存和更多的磁盘空间。","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"MySQL","slug":"数据科学/MySQL","permalink":"http://qinjiangbo.com/categories/数据科学/MySQL/"}],"tags":[{"name":"事务","slug":"事务","permalink":"http://qinjiangbo.com/tags/事务/"},{"name":"MySQL","slug":"MySQL","permalink":"http://qinjiangbo.com/tags/MySQL/"}]},{"title":"Hexo新增PDF阅读功能","slug":"add-pdf-reader-to-hexo","date":"2017-07-12T14:58:26.000Z","updated":"2017-07-12T16:29:49.000Z","comments":true,"path":"add-pdf-reader-to-hexo.html","link":"","permalink":"http://qinjiangbo.com/add-pdf-reader-to-hexo.html","excerpt":"","text":"根据之前插入视频的经验，发现PDF的展示也非常类似，于是捣鼓捣鼓，来研究一下在博客中展示PDF的问题。展示PDF有什么作用呢，主要是后面如果我觉得哪些书籍比较重要，我可以直接在博客给大家分享出来，大家可以直接在线阅读，非常方便。 插入PDF的代码如下： 1&lt;embed src=\"\" width=\"100%\" height=\"550\" type=\"application/pdf\"&gt; 我们以《Effective Java 2nd》为例，同时也是跟大家分享这本书。地址：https://of7vtvi79.qnssl.com/Effective%20Java%202nd.pdf。 书籍地址：https://of7vtvi79.qnssl.com/Effective%20Java%202nd.pdf 大家可以尽情地阅读这本书啦！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"PDF","slug":"PDF","permalink":"http://qinjiangbo.com/tags/PDF/"}]},{"title":"Hexo新增视频播放功能","slug":"add-video-player-to-hexo","date":"2017-07-10T16:23:25.000Z","updated":"2017-07-12T16:29:03.000Z","comments":true,"path":"add-video-player-to-hexo.html","link":"","permalink":"http://qinjiangbo.com/add-video-player-to-hexo.html","excerpt":"","text":"今天逛了一下hexo.io的官方插件市场，发现一个插件挺不错，名字叫hexo-tag-tencent，同时支持优酷和腾讯视频的播放，很方便。 安装方式1npm install --save hexo-tag-tencent 使用方式作者原话：markdown 文档直接将视频分享代码粘贴就可以插入视频。 优酷视频 腾讯视频 纯H5视频 Your browser does not support the video tag. 更新发现hexo-tag-tencent插件并没有做什么有用的事情，就是将ID改了一下加入进来，拼接了字符串，所以直接将其删除了。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"视频","slug":"视频","permalink":"http://qinjiangbo.com/tags/视频/"}]},{"title":"实习中期总结思考","slug":"review-of-mid-term-internship","date":"2017-07-10T15:36:44.000Z","updated":"2017-07-11T16:51:57.000Z","comments":true,"path":"review-of-mid-term-internship.html","link":"","permalink":"http://qinjiangbo.com/review-of-mid-term-internship.html","excerpt":"","text":"一转眼已经实习一个多月了，收获很大，不管是从技术上还是从业务上。对于自身的视角有了一个更加全面地开拓，变得更加open了。但是从这一次的中期Review来看，还是存在一些盲点和不足的地方，这些都是需要值得注意和警惕的，也是下一步工作中必须踏实完成和改进的地方。 主要从两个方面来总结，一个是取得的收获，另一个是存在的不足。 取得的收获最先接触的就是WebX开发框架，WebX是一个非常优秀的MVC开发框架，采用约定大于配置的思想，减少了各方（后台接口开发，前端模板开发，UI设计等等）的沟通成本，并行开发模式提升了整体的开发效率。这段时间关于WebX的学习分为了几个阶段，首先是看文档初步了解WebX开发框架是什么，各个组件模块有什么用；其次是自己对着开源的WebX网站编写了一个Demo，并成功运行；然后再看看在项目中我们是如何使用WebX框架的，具体用到了哪些功能模块；最后就是结合WebX的源码理解整个WebX框架的设计模式和架构。对照着Spring MVC开发框架来看的话，二者还是存在一些相同点的，比如二者都是独立的MVC开发框架，都可以依赖Spring IOC容器来实现Bean依赖的管理，都有拦截器的概念。不同点其实也有很多，首先是Spring MVC是基于对Servlet的封装，然后实现了请求的路由，而WebX是基于对Filter的封装，WebX选择Filter是因为它可以返还控制权（实际上是一个责任链模式的体现），而Servlet不能返还控制权；另外一点就是RESTful风格的URL请求路由，Spring MVC支持RESTful风格而WebX不支持，现在好像WebX加了一个拓展包用来支持RESTful风格路由了；对于拦截器二者其实差不多，只不过Spring MVC称之为interceptor而WebX称之为pipeline，都可以针对不同的请求制定不同的执行方式。学习WebX也是对自己关于MVC框架认识的一个拓展，收获很大。 后面有陆陆续续学习了集团的几个中间件，包括HSF，Pandora，Pandora Boot， Alitomcat，Tengine，Notify，Tair，Config Server，Diamond以及TDDL等，中间件的学习花了两个星期的时间。当时和各位师兄交流之后，决定按照先学会如何使用，然后在项目中将其灵活运用，最后再深挖的思路去学习。由于文档非常完备，因此学习的比较快，同时针对每一个中间件都做了相应的Demo来巩固自己的理解，收获很大。但是完成这些其实也只是停留在了师兄们建议的第二步，在项目中实际运用，距离深挖还是有一定的差距。 对于业务方面来讲，由最初的对伙拼项目完全陌生到现在能基本熟悉整个业务流程，还是有一些收获。对业务的学习主要体现在三个方面，一个是@博善师兄带着做几个项目小需求来理解整个项目，另一个是@博善师兄结合具体的业务场景给我介绍相应的业务逻辑和业务流程，最后一个就是自己针对伙拼项目以前的项目文档来学习和理解现有的业务。其实收获就是对于整个业务架构有了一个最基本的认识。 关于集团的各个项目管理工具以及项目发布系统，比如aone，aenv，psp等，都是随着需求的开发不断向前进展而逐渐熟悉的，现在基本上能比较熟练的使用相应的功能。由于系统依然还是非常复杂的，所以后续还是要花时间去了解一些其他能够快速提升自己的工作效率的功能。 存在的不足虽然取得了一些收获，但是存在的不足还是非常明显的。下面分别从技术上和业务上来说。 技术上来说的话，还没有达到师兄们提出的深挖这个层次，其实对于任何一门技术，不能只求如何取用，更加要知道怎么实现的，知道如何实现的比知道如何使用收获大的多。对于WebX来说，目前虽然知道WebX如何使用，但是还不能够非常完整地说出WebX底层的实现机制，请求是如何进入如何被处理，最后是如何返回的，整个WebX的架构是怎么样的等等。这些都是需要继续深入学习和理解的。后面的话我会针对WebX的学习写一到两篇自己的深入学习和深入理解的文章。 对于中间件的学习也是如此，中间件可以说是集团所有业务的一个最核心的支撑了，不管是双十一还是我们伙拼的大促，无时不刻都在使用集团的中间件作支撑。因此，用好中间件是基本要求，但是对于中间件背后原理的理解也是非常重要的。现在项目中使用最多的中间件就是HSF，Tair， Notify以及TDDL。做Review的时候还提到了Dubbo和MetaQ，关于这两个中间件我会再花时间多多学习和深入理解。目前对于HSF，Tair以及Notify底层的实现还是理解不够的，对于Tair可能还有所了解，因为可以和Redis做一个简单的对比，但也还是要重点去了解，去学习。HSF和Dubbo的对比，MetaQ和Notify的对比这些都是要在自己对于整个技术栈深入理解之后才能给出标准的答案。 业务上问题是这次Review当中询问的重点，主要是运营-卖家-买家的顺序来阐述的。对于业务的理解其实是不够的，对于整个商品活动报名的流程也只是最基本的一个了解，更谈不上知道后台的数据是如何在各个链路节点当中流动的细节了。在脑海中对于伙拼的业务还是需要进一步的打通，重点在于理解而不是在于死记硬背。后面在业务上还是需要多和@费斯和@博善两位师兄多多沟通，要争取全部弄懂。现在对于MKC和DA以及交易这边和我们具体在业务上存在哪些联系，具体是如何和我们进行交互的还不是很熟悉，然后对于后台小二运营工具的熟悉也不够，一方面是有些工具没有权限访问，另一方面是自己还没有接触到这一块业务。比较重要的一个地方就是数据库的设计不熟，每张表对应的是什么样的业务场景不熟悉，表中具体有哪些字段不熟悉，这一些也是后面要重点接触和理解的。 另外自身对于伙拼业务的思考不够深入，没法提出比较有建设性的意见或者建议，原因主要有两点，第一是自己首先对业务不熟悉，不知道各个部分如何组合最优化，如何改进能使业务更灵活，更完善；第二是自己对于业务这个层面的理解是缺乏的，对于业务的发展以及业务的安排没有很好的认识和思考，没法透传各种数据背后带来的价值，也就是说后面必须对数据要敏感起来。 几点思考 技术上深挖的这个深挖到底是一个什么样的深度需要好好判断，既不能研究的太浅，也不能陷在其中不能自拔以至于耽误了正常的工作。 业务的思考应该从哪些方面给出着手思考？是思考如何提升GMV还是核买数量？从技术的角度思考如何提升这些指标？从业务的角度又应该如何思考提升这些指标？","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"阿里巴巴","slug":"阿里巴巴","permalink":"http://qinjiangbo.com/tags/阿里巴巴/"},{"name":"实习总结","slug":"实习总结","permalink":"http://qinjiangbo.com/tags/实习总结/"}]},{"title":"百技培训感悟","slug":"thinking-of-alibaba-baiji","date":"2017-07-05T01:09:26.000Z","updated":"2018-09-02T10:12:56.000Z","comments":true,"path":"thinking-of-alibaba-baiji.html","link":"","permalink":"http://qinjiangbo.com/thinking-of-alibaba-baiji.html","excerpt":"","text":"这三天参加完百技（百年技术）的培训，不论是从职业的发展还是从技术的提升，都有很大的收获！感谢集团给我们提供的一个大家提升自我，互相认识的机会，同时也接触到了集团的技术大牛！ 虽然心中有千言万语，但是由于笔者手拙，没法用非常优美的文字表述，所以就简单地聊一聊啦。本次感悟主要从四个方面来聊聊吧： 初次体验 百技点滴 课程收获 个人展望 初次体验第一次收到班主任@昭坤的百技通知邮件时，心里面的第一感受是惊喜，第二个是好奇。首先说说惊喜，之前一直听师兄说过“百技”一般是给应届毕业生或者社招生做的培训，突然发现集团也给实习生安排了，有点“受宠若惊”。其次感到好奇是因为从来没有具体地了解过百技的培训到底是什么样的，正所谓久闻不如一见，还是要先体验体验再说。 “百技”的时间安排是从7月3号到7月5号，时间是三天，对实习生来说，个人感觉这样安排还是比较合理的。第一次来到西溪园区，比想象中更大，整个园区给人的舒适程度非常高，到处都能给人一种生活的气息~ “百技”给我的另一个初印象就是这是一个分享会，而不是单纯的讲课。讲师与同学们的互动非常多，现场的气氛非常活跃，我猜这也是为什么阿里巴巴的技术氛围那么浓厚的原因之一吧！正是有这一种开源分享的技术文化，阿里巴巴的技术才会越来越强大。 想起当初HR问我为什么来阿里的时候，我的回答是阿里巴巴的技术文化氛围非常不错，自己很想融入这个优秀的团体。的确，从各个平台比如InfoQ和OpenSource China了解来看是这样的—-阿里技术人总是会在各个大会分享自己的宝贵经验，但是这些从别人报道那儿了解到的和自己亲身经历过的感受是完全不一样的。亲身经历过的人都会或多或少能更加具象地了解这个讲师，他所做的工作，以及他对自己所做的领域的理解和思考，这一切都是让我们受益匪浅的宝贵财富。 百技点滴在“百技”的这三天，身边的发生的点点滴滴非常多，从刚开始的小组成员之间的热烈讨论，到积极和分享的大牛讲师互动，以及最后整个团队一起协同合作，都有很多很多的收获。 “百技4组—-我们白着呢”，没错，这就是我们的队名。整个团队的成员都是来自于不同的部门，大家所负责的工作也不尽同，有做前端开发的，有做Java后台开发的，也有做算法研究的等等。尽管大家都各有不同，但是大家都有很多共同的话题，而且聊得很开心。这也是我之前一直提到过的“味道”，我觉得来阿里的同学身上都有一种“阿里味道”，这种味道是“分享”，“乐观”以及”开放“。 对于“百技”老师提出的每一个问题，我们都积极热烈地讨论，并及时地和老师互动。在互动的过程当中我们不仅仅是了解了别人对这个问题的看法，其实更多的也是激起了自己的一些思考。每一次和老师的互动都是对于自身思维的一种锻炼和提升。其中我记得@孤尽老师说过，“能把做过的事情提炼为思维，这个能力很重要！”对于这句话，我的理解是其实做的事情再多，如果不善于总结，不善于自省，其实是没办法形成思维的，没办法形成体系化的解决问题的能力的 。 除了课堂上和老师的互动以外，课间班主任@昭坤也组织我们做了很多游戏，比如你划我猜，用各自的方言读一段文字等，既培养了大家团队协作的能力，又活跃了气氛。总的来说非常赞！ 课程收获“百技”的课程安排还是比较紧凑的，每一天的课程都安排的很满，另外老师们也是百忙之中抽空前来为我们做一次很棒的分享，表示感谢！下面主要是说一说这三天里我收获非常大的几场分享。 尽在双十一首先是来自天猫团队的@霜波老师，她为我们分享的是“阿里双十一技术演变”。阿里巴巴从2009年的第一场双十一开始，成交额在每年逐步上升，由最初的5.9亿到2016年的1207亿。双十一也从当时的一个大促活动变成了整个集团现在的年度大考，全民的狂欢节，这是一个巨大的飞跃。我一直很好奇阿里是如何支撑起这么盛大的一场活动的，也看过很多相关的资料，但是都没有老师分享来的具体。她说最开始的时候，负责双十一的人其实也不多，整个系统的稳定性不是很好，系统经常性的会出现一些问题，尤其是在2011年以前。因此2012年的时候，在双十一之前，天猫团队召集卖家代表组织了一场沟通会，问他们有什么期待，原以为卖家会说希望自己的商品卖的更好，或者是希望平台为他们带来更过的流量，都不是。卖家代表们说了一个共同的词—-“稳定”，他们希望系统在双十一当天稳定。老师也解释道为什么是“稳定”这个词，不仅仅是阿里巴巴在为双十一做准备，所有的卖家也在为双十一做准备的，他们借了钱屯了高于平常3-5倍的货，如果平台不稳定的话，对所有的卖家来说意味着什么，只有破产。一听到这里，其实对于我的触动还是非常大的，因为以前一直考虑的是买家的情况，并没有考虑到卖家的情况。其实当卖家选择在淘宝天猫上参加双十一活动的时候，我们就肩负起了非常重大的责任。系统的稳定性上不能打折扣，这也是我未来在自己的岗位上严格要求自己的一点，不能有丝毫的马虎，因为我们身上的担子很重。 说到双十一的技术变化，最开始的OPS（Order Per Second）是400，到去年双十一的175000，这是非常大的一个飞跃。系统的架构也在发生着巨大的变化，早期的时候系统还是相对比较简单的，就是商品的展示与销售，到了去年的AR技术，直播技术，以及个性化的导购页展示。其中有一个非常重要的技术得提出来，就是全链路压测，正是因为有了全链路压测技术，这几年的双十一基本上没有出现什么重大的稳定性问题，所以说技术上的革新是至关重要的。 @霜波老师也提到了自己加入阿里的理由，她当时是在UT斯达康工作，阿里给她递来了橄榄枝，一开始她是拒绝了，因为按照当时的情况来看的话留在UT斯达康她可以获得更好的报酬等等。但是阿里的同事还是坚持给她打电话，把手机都打烫了，她感受到了阿里的诚意，因此放弃眼前的工作毅然加入阿里。她说阿里是一家有梦想的企业，阿里的同学们都是有活力有激情的年轻人，这样的公司是有未来的！听完这席话，说实话挺感动的，阿里对于人才的渴望，阿里人的活力和激情都体现了出来。 数据安全数据安全是来自于阿里云安全团队的@载者老师，其实在六月一号入职的时候，HR部门师兄已经给我们简单地说了集团的数据安全。但是@载者老师是从技术人的角度去解读集团的数据安全。马老师说过，阿里最宝贵的财富就是数据，阿里以后要做一家数据公司，而不是纯电商公司。可想而知，对于阿里巴巴来说，没有什么比数据更重要的了！ @载者老师先简单地介绍了数据安全的一些简单的概念，同时也介绍了集团的数据安全要求。他给出了一些近期集团发生的数据安全的例子，比如有运营的同学家里人在淘宝上开店这个情况并没有上报，而且利用职务之便获取了很多交易相关的信息给家人作参考，这个是非常严重的；有的同学在离职的当天，私自拷贝大量的数据到自己的个人存储设备里面，准备带离公司；还有的同学偷偷地将一些p7，p8的同学的个人信息采集下来，卖给外面的猎头，这个也是非常严重的。这一幕幕都非常的触目惊心。 如果个人信息安全得不到保障，会造成什么样的后果？轻则会不断地接收到骚扰电话，重则过于敏感的信息可能会导致一个人结束自己的生命，人命大于天，因此数据的安全同样也大于天。用户将数据交给平台管理，平台就有责任在任何一个环节保障用户的数据安全，不论是对内，还是对外！因此我的理解是，在工作中不要利用权限去访问一些与自己无关的数据，尽量做到最小化办公，精简化办公。 集团开发规约集团开发规约是由@孤尽老师给我们讲解的，@孤尽老师是我们滨江园区的ICBU技术部的。为什么见到他会很激动呢，因为他是《阿里巴巴Java开发手册》的作者。早在来阿里之前，今年的三月底四月初我就在InfoQ上下载了这个手册，觉得满满的干货，不论是是从编程的风格还是从代码中需要避免踩的坑，手册里面都有详细的介绍，甚至包括MySQL数据库规约以及工程规约。《阿里巴巴Java开发手册》我完整地读过四遍，主要是时间长了记忆会模糊，并且每次读的时候都有新的感受和收获。了解一本书背后的故事往往收获可能会大于这本书本身的价值。 @孤尽老师讲述了他在创作这本书的时候所经历的一些困难和挫折，听完还挺励志的。他首先分析了在集团开发规约推出之前各个团队的现状，举了一个非常形象的例子，在小组层面，每个组有自己的一套规范，到部门层面，每个部门又有自己的规范，然后再到BU层面，每个BU又有自己的规范，想象一下，统一这个代码规范是有多么的困难。改变一个人的思维和习惯永远是很困难的，尤其是程序员。也遭受过很多质疑，比如业界已经有了非常完备的Google Code Style，为什么现在还要自己造一个Ali Code Style？一时间他也知道自己不可能说服很多人，得先做出来再说。于是在工作之余，他开始动手做了，后面也开始有人陆续加入到这个行动当中。经过一百多次的改版，才最终形成了我们现在看到的这个集团开发规约，的确是挺不容易的。 大家都说阿里是一家梦想驱动型的企业，其实从早期的阿里人将阿里巴巴从0做到1就可以看出来了。其实在@孤尽老师的身上也说明了这一点，很多时候认为一件事情非常有价值，觉得有义务去做这个事情，肯定会被质疑。其实在他之前，有无数的阿里前辈前赴后继地去做这个事情，但是直到他这里这个事情才做成了，我认为原因是他坚持了下来。他说，KPI固然很重要，但是不能因为KPI而限制了自己的梦想，要敢于坚持自己的梦想，当然了也要协调好自己的工作和梦想之间的平衡，因为阿里是一个比较讲究落地的企业。 “梦想”，“坚持”以及“不忘初心”是这堂课给我最大的收获。 个人展望三天的“百技”结束了，但是却引发了我的很多思考和感悟，不论是技术还是职场。可能现在的想法里面还有很多不成熟的地方，还是需要持续地思考、自省，反复地吸收新的东西并消化。 阿里需要什么样的技术人才？我说说我的想法，我认为首先是乐观的人，一个人如果不乐观，他是无法看到未来的。如果阿里巴巴在十几年前不乐观的话，很难坚持到现在的，乐观至关重要。具体来说，乐观的人应该要做到对自己所从事的事业的热爱，其次是要有信心做下去，即使失败了，也要相信这个事情一定能成功！其次是能吃苦能受委屈的人，阿里称之为“皮实”，可能工作中确实会遇到一些困难和挫折，要敢于吃苦，受得了委屈，不能有玻璃心，同时对于自己负责的项目有Owner意识。再就是能够经常反省自己的人，自己是不是还有哪些地方做的不够好，是不是还有什么地方可以提升并且改进的。我觉得经常反省自己就是在给自己做“体检”，只有不断地及时发现自己存在的问题才会更好地改进它并且提升自我。再就是很聪明的人，这里的聪明不仅仅限于智商，其实也包括情商。我认为智商可以决定一个人是不是能够做某一件事，但是情商会决定一个人是不是能够把这一件事做好，做完美。对于工作中情商高的人，和他（她）合作的人也会非常的愉快，而他（她）也就能拥有更多的机会，最后我认为是很重要的一点，对于所有的技术人来说，持续学习是非常非常重要的。知识是在不断革新的，只有不断地学习，才会让自己更加强大，虽然很多知识在工作中不一定用得到，但是一旦要用的时候就能够及时地拿出来了。这里我不得不提到我们组的师兄们，虽然业务很多很忙，但很多时候还是会抽时间出来看书学习，时间管理的很好，这种精神很感染我，向他们看齐！总的来说，我认为阿里的技术人应该具备的品质就是： 积极乐观 能吃苦能受委屈 Owner意识，有责任有担当 经常自省 聪明 持续学习，终身学习 我觉得这一些都是我未来需要继续努力并持续努力的方向。我相信，有了想法，脚踏实地，稳步前行，就可以把一件事做好！关于职业的规划其实和主管@费天以及师兄@博善都有聊过。和主管@费天聊过以后，我明白了集团现在的一个大方向，就是强调数据化和算法。举个例子，以前运营对于数据其实是黑盒，现在需要做的就是将所有的链路可视化，能清楚地知道哪个环节出现了问题，哪个环节给整体带了明显的提升，便于更好地决策。还有算法，算法是一个程序员的基本功，要重视算法。关于技术和业务的关系也更明确了，主管@费天说，技术是为业务服务的。这句话我想了想很有道理，因为如果一个人技术再厉害，如果对业务一无所知，其实对整体的增益是非常少的。我觉得一个懂业务的程序员才是一个合格的程序员。和师兄@博善平时聊得比较多，什么都聊，最大的收获就是一种快乐工作、认真生活的态度，另外还有对于技术的极致追求。对于某一个问题，师兄会思考如何做更优，而不是仅仅限于做完，我觉得这一点也是我后面工作中需要多多学习的一点。 最后再说一说需要感谢的人。其实需要感谢的人和事有很多，首先是集团，能提供这么好的一个机会给实习生确实是非常有诚意的，体现了对实习生的重视。再就是这一次“百技”的班主任@昭坤和我的小伙伴们，感谢大家这三天的陪伴，三天非常短但是这些回忆和收获确是会一直被我珍藏。爱你们！！！ 还有阿里的各位大牛讲师，你们的分享很精彩，让我收获颇多，其实最重要的不是知道某个领域的知识，而是学会一种学习和工作的态度以及思考的方式。最后必须得感谢的是对我影响最大的我们新三板业务小组的各位师兄们和主管。一个月以来，主管和各位师兄对我非常的照顾，不论是权限的申请还是问题的解答都是非常及时和迅速的，为你们点赞！我也会在接下来的工作中继续努力，为新三板贡献自己的力量！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"阿里巴巴","slug":"阿里巴巴","permalink":"http://qinjiangbo.com/tags/阿里巴巴/"},{"name":"百年技术","slug":"百年技术","permalink":"http://qinjiangbo.com/tags/百年技术/"}]},{"title":"Velocity编程指南（五）","slug":"velocity-programming-guide-5","date":"2017-07-02T10:01:35.000Z","updated":"2018-04-02T09:04:00.000Z","comments":true,"path":"velocity-programming-guide-5.html","link":"","permalink":"http://qinjiangbo.com/velocity-programming-guide-5.html","excerpt":"","text":"本章作为这个系列的最后一章，主要是讲如何在Java代码中运行Velocity模板引擎，还是一贯的套路，使用Maven项目来演示，主要从以下几个方面来讲： pom依赖 程序演示 结果展示 注意事项 总结 pom依赖在网站http://www.mvnrepository.com中搜索“velocity”，就可以得到这个依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt;&lt;/dependency&gt; 这样相应的Jar包就会自动下载了。 程序演示新建一个Java类VelocityDemo，如下： VelocityDemo.java 12345678910111213141516171819202122232425262728293031323334import org.apache.velocity.Template;import org.apache.velocity.VelocityContext;import org.apache.velocity.app.Velocity;import org.apache.velocity.app.VelocityEngine;import java.io.StringWriter;/** * @date: 22/06/2017 12:46 AM * @author: qinjiangbo@github.io */public class VelocityDemo &#123; public static void main(String[] args) &#123; VelocityEngine velocityEngine = new VelocityEngine(); String path = \"/Users/Richard/IdeaProjects/Velocity/src/main/resources\"; velocityEngine.setProperty(Velocity.FILE_RESOURCE_LOADER_PATH, path); velocityEngine.setProperty(Velocity.INPUT_ENCODING, \"UTF-8\"); velocityEngine.setProperty(Velocity.OUTPUT_ENCODING, \"UTF-8\"); velocityEngine.init(); Template template = velocityEngine.getTemplate(\"alibaba.vm\"); VelocityContext context = new VelocityContext(); StringWriter writer = new StringWriter(); template.merge(context, writer); System.out.println(writer.toString()); &#125;&#125; alibaba.vm 12#set($we = &quot;Alibaba&quot;)This is an $&#123;we&#125; day. 结果展示整个程序运行以后的结果如下所示： 1This is an Alibaba day. 注意事项上面的代码中需要特别关注的一点就是Velocity引擎对象velocityEngine的属性值设置，如果不设置Velocity.FILE_RESOURCE_LOADER_PATH这个值，Velocity引擎对象根本找不到对应的工作空间，也就无法识别这个alibaba.vm模板了。很多教程给出Java例子的时候都没有给出这个值的设置情况。 总结终章结束。希望大家结合本教程的例子，动手实际地在IDE里面跑一遍，这样很多问题才会暴露出来，才会得以解决。有任何问题可以给我留言，可能的话我会在第一时间给予回复。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Velocity","slug":"Velocity","permalink":"http://qinjiangbo.com/tags/Velocity/"},{"name":"模板引擎","slug":"模板引擎","permalink":"http://qinjiangbo.com/tags/模板引擎/"}]},{"title":"Velocity编程指南（四）","slug":"velocity-programming-guide-4","date":"2017-07-02T08:18:42.000Z","updated":"2018-04-02T09:03:50.000Z","comments":true,"path":"velocity-programming-guide-4.html","link":"","permalink":"http://qinjiangbo.com/velocity-programming-guide-4.html","excerpt":"","text":"无论是哪种编程语言，都应该支持一些函数，VTL也不例外，只不过在Velocity中我们不叫它函数，叫它宏（Macro），宏允许我们定义一系列的动作，并且重复使用它。使用的时候主要是创造一些自定义的新命令，什么命令都可以，都可以通过#号来表示。 #macro命令来简单看一下Velocity宏的使用吧： 123#macro ( tr )&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;#end 怎么使用的呢？#tr()就可以了。Velocity引擎会自动解析这个#tr命令，然后将相应的内容填充到模板中。我们称这为一次宏调用（Macro Invocation）。 宏结构macro在Velocity中，一个宏的定义通常是由#macro命令开始，#end命令结束，中间一段是宏体macro body。我们的业务逻辑基本上都是写在宏体里面的。和函数一样，macro也是可以传参数的，下面我们演示一个传递两个参数的宏定义（macro definition）： 123456789101112#macro( tablerows $color $values ) #foreach( $value in $values ) &lt;tr&gt;&lt;td bgcolor=$color&gt;$value&lt;/td&gt;&lt;/tr&gt; #end#end#set( $greatlakes = [&quot;Superior&quot;,&quot;Michigan&quot;,&quot;Huron&quot;,&quot;Erie&quot;,&quot;Ontario&quot;] )#set( $color = &quot;blue&quot; )&lt;table&gt; #tablerows( $color $greatlakes )&lt;/table&gt; 引擎解析的结果就是： 1234567&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=\"blue\"&gt;Superior&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td bgcolor=\"blue\"&gt;Michigan&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td bgcolor=\"blue\"&gt;Huron&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td bgcolor=\"blue\"&gt;Erie&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td bgcolor=\"blue\"&gt;Ontario&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 我们来说一说上面定义的这个宏的结构：由#macro命令开头，参数有tablerows，$color和$values。注意，tablerows前面没有美元符号，说明它不是变量，那么它是什么呢？tablerows是这个宏（macro）的名字，也就是说这个宏可以通过#tablerows来进行调用。很明显，$color和$values两个是变量，是作为参数传递进来的。 宏参数argumentsVelocity中宏只能够传递特定类型的参数，如下所示： 引用，就是以美元符号$开头的东西 字符串常量，比如&quot;hello&quot;，&quot;alibaba&quot;等 数值常量，比如102, 1999等 整形范围，比如[0..102]，[$start..$end]等 对象数组，比如[&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;]等 布尔型数值，trueorfalse 来一段： 12345#macro( callme $name )My name is $name.#end#callme( &quot;Alibaba&quot; ) 结果是My name is Alibaba.宏调用成功！注意宏的参数问题，如果传递过来的是一个方法的结果，那么这个方法会被宏重复执行。因为在宏里面，参数只是被替换到宏体里面的对应位置而已，然后才开始解析执行。举个栗子： 123456#macro ( repeat, $x )$x, $x, $x#end## 假设$date.now()等于当前时间#repeat( $date.now() ) 结果是三个不一样的时间，原因是什么？不是把$date.now()的结果传递到宏体中去了吗？三个$x应该是一样的啊，但是在Velocity中，不是的！它只是把$date.now()替换到$x中，然后才开始执行，所以三个结果分别都不一样。不要和Java中的函数调用搞混了！ 格式化issues关于Velocity的格式化问题，有几个需要注意的地方，没有什么说必须写多行还是写一行的规矩，其实解析的结果都一样。但是我们推荐还是要标准化，格式化，这样便于代码的可读性。下面两个例子做个对比： 好的例子 1234#set( $fruits = [&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;strawberry&quot;] )#foreach( $fruit in $fruits ) $fruit#end 坏的例子 12#set( $fruits = [&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;strawberry&quot;] )#foreach( $fruit in $fruits ) $fruit #end 很明显，第一个例子可读性非常好，第二个例子的可读性相对差很多。另外，多余的空格（excess whitespace）会被Velocity引擎移除掉。也就是说下面两段代码的效果是一样的： 12345678910111213Send me#set( $foo = [&quot;$10 and &quot;,&quot;a pie&quot;] )#foreach( $a in $foo )$a#endplease.#################################Send me#set($foo = [&quot;$10 and &quot;,&quot;a pie&quot;]) #foreach ($a in $foo )$a #end please. 不过很明显下面的那种写法不是我们推荐的。 范围操作range operators范围操作就是针对[n..m]遍历的操作，n和m必须是整数。有一些有趣的例子可以看看： 12345678910111213141516171819202122## Range: 1 2 3 4 5First example:#foreach( $cnt in [1..5] ) $cnt#end## Range: 2 1 0 -1 -2Second example:#foreach( $cnt in [2..-2] ) $cnt#end ## Range: 0 1Third example:#set( $range = [0..1] )#foreach( $cnt in $range ) $cnt#end## Not a range (不在 #set or #foreach 命令中)Fourth example:[1..3] 输出结果： 1234567891011121314151617181920First example: 1 2 3 4 5Second example: 2 1 0 -1 -2Third example: 0 1Fourth example:[1..3] macro进阶想一下下面的例子执行结果是什么？ 1234567891011#macro( inner $foo ) inner : $foo#end#macro( outer $foo ) #set($bar = &quot;outerlala&quot;) outer : $foo#end#set($bar = &apos;calltimelala&apos;)#outer( &quot;#inner($bar)&quot; ) 答案是outer : inner : outerlala。为什么不是outer : inner : calltimelala？这里需要注意的是宏定义里面都是参数替换，所以，#inner($bar)直接被替换到宏outer里面去了，里面又重新定义了$bar这个变量，所以以这个为准。再来一个： 123456#macro( foo $color ) &lt;tr bgcolor=$color&gt;&lt;td&gt;Hi&lt;/td&gt;&lt;/tr&gt; &lt;tr bgcolor=$color&gt;&lt;td&gt;There&lt;/td&gt;&lt;/tr&gt;#end#foo($bar.rowColor() ) 说明一下，看过前面介绍的同学都会知道，这里的$bar.rowColor()会被重复执行两次，而不是一次。原因是$bar.rowColor()直接被替换到foo宏体里面去了。正确的写法是什么？ 12#set( $color = $bar.rowColor() )#foo($color) 这样$bar.rowColor()就不会执行多次了。 字符串拼接concatenation字符串拼接主要是要注意变量与普通字符串常量的隔离。千万不要用+号来拼接字符串，直接把字符串放在一起就好了。比如： 123#set( $type = &quot;staff&quot; )#set( $group = &quot;Alibaba&quot; )He is an excellant $group$type! 结果是He is an excellant Alibabastaff!如果加一个字符串呢？ 123#set( $type = &quot;staff&quot; )#set( $group = &quot;Alibaba&quot; )He is an excellant $groupGroup$type! 结果是He is an excellant $groupGroupstaff!原因是Velocity将groupGroup当做一个变量了。这个时候做一个小调整就可以啦，如下： 123#set( $type = &quot;staff&quot; )#set( $group = &quot;Alibaba&quot; )He is an excellant $&#123;group&#125;Group$&#123;type&#125;! 如果怕$group或者是$type未定义导致页面上出现$group这样的字符串，我们推荐使用带感叹号的方式访问变量： 123#set( $type = &quot;staff&quot; )#set( $group = &quot;Alibaba&quot; )He is an excellant $!&#123;group&#125;Group$!&#123;type&#125;! 总结到此为止，Velocity的VTL模板语言的语法终于讲完了，都是一些在工作中需要特别注意的点，希望大家反复琢磨琢磨，每一个例子争取自己都跑一遍。关于具体怎么用Java代码去跑一个这样的例子，我在下一章会给大家详细的介绍。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Velocity","slug":"Velocity","permalink":"http://qinjiangbo.com/tags/Velocity/"},{"name":"模板引擎","slug":"模板引擎","permalink":"http://qinjiangbo.com/tags/模板引擎/"}]},{"title":"Velocity编程指南（三）","slug":"velocity-programming-guide-3","date":"2017-06-29T15:21:49.000Z","updated":"2018-04-02T09:03:47.000Z","comments":true,"path":"velocity-programming-guide-3.html","link":"","permalink":"http://qinjiangbo.com/velocity-programming-guide-3.html","excerpt":"","text":"前面说了Velocity的VTL语法，关于Velocity的对象，引用等有了比较清晰的认识。但是，Velocity本身有哪些强大的功能呢？本章我们就来讨论一下Velocity中有哪些非常强大的命令（directives）和操作。 命令directives在Velocity中，我们重点需要了解的命令列举如下，以便于大家提前有一个简单的认识。 #set()[单行命令] #literal()[多行命令] #if() / #elseif() / #else[多行命令] #foreach()[多行命令] #include()[单行命令] #parse()[单行命令] #stop()[单行命令] #macro()[单行命令]（后面一章会学习） #set命令很简单就可以想到，#set命令主要是设置一个值对吧，具体点来说就是给一个引用赋值。我们直接来点例子吧： 12345## 赋给一个变量值#set( $name = &quot;alibaba&quot; )## 赋给一个属性值#set( $customer.Favourite = $name ) 从上面的例子我们可以看到等号左边的被赋值的引用类型只能是变量引用或者是属性引用，其它的类型都无效，这和我们的Java中的赋值语法是一致的。重点是等号右边的元素可以是一下类型： 变量引用（Variable reference） 字符串常量（String literal） 属性引用（Property reference） 方法引用（Method reference） 数值常量（Number literal） 链表（List） 映射（Map） 表达式（Expression） 比如说下面的这些都是可以的： 1234567891011121314151617181920## 变量引用#set( $fruit = $selectedFruit )## 字符串常量#set( $fruit.flavor = &quot;sweet&quot; )## 属性引用#set( $fruit.amount = $cart.total )## 方法引用#set( $fruit.color = $colorlist.selectColor($select) )## 数值常量#set( $fruit.value = 123 )## 链表#set( $fruit.sorts = [&quot;Apple&quot;, &quot;Pear&quot;, &quot;Orange&quot;] )## 映射#set( $fruit.shapes = &#123;&quot;Apple&quot; : &quot;round&quot;, &quot;Pear&quot; : &quot;conical&quot;&#125;) 多说一句：如何获取Velocity中的链表List和映射Map中的值呢？以上面的例子来说，对于List，我们可以就类似于java.util.List的方式来取值，像这样$fruit.sorts.get(0)；对于Map，一样的，类似java.util.Map，如$fruit.shapes.get(&quot;Apple&quot;)。 至于表达式嘛！我们看一看： 1234#set( $value = $hello + 1 )#set( $value = $hello - 1 )#set( $value = $hello * $world )#set( $value = $hello / $world ) 加减乘除其实都是OK的。 给引用赋空值null一般来说，Velocity是不允许给引用赋空值的，就是说，如果这个引用所指向的是一个非空的值，那么后面给它赋空值以后，它的值是不会变的，还是之前的值。怎样解除这个限制呢？Velocity从1.5版本以后给出了自己的方案，就是设置一个运行时属性directive.set.null.allowed为true，否则是不能设置控制的。下面给出一个简单的例子说明一下： 12345#set( $result = $query.criteria(&quot;fruit&quot;) )The result of the first query is $result#set( $result = $query.criteria(&quot;customer&quot;) )The result of the second query is $result 如果说$query.criteria(&quot;fruit&quot;)返回的是apple ，而$query.criteria(&quot;customer&quot;)返回的是null，上面的代码运行结果是什么？好好想一下： 123The result of the first query is appleThe result of the second query is apple 没错！你想的是正确结果！那我们下面来一个难度更高一点的：我们使用一个#foreach命令来遍历一个集合中所有非空的元素，如下： 1234567#set( $criteria = [&quot;fruit&quot;, $name ,&quot;customer&quot;] )#foreach( $criterion in $criteria ) #set( $result = $criterion ) #if( $result ) $result #end#end 说明一下，上面的代码中$name没有赋任何值，也就是说它为空，想一下，这段代码的运行结果会是什么？ 123fruitfruitcustomer 为什么？因为第一个元素被访问以后$result的值变为了fruit，由于第二个元素是空的，所以$result的值不变，还是fruit，但是第三个元素的值是customer不为空，那么$result呗赋值成功。 正确的做法应该是什么呢？怎样不重复地输出整个List中非空的元素呢？ 12345678#set( $criteria = [&quot;name&quot;, &quot;address&quot;] )#foreach( $criterion in $criteria ) #set( $result = &quot;&quot; ) #set( $result = $criterion ) #if( $result != &quot;&quot; ) $result #end#end 结果就是 12fruitcustomer Bingo！ 字符串常量#literal命令当我们使用#set命令的时候，其实即使是在双引号中括起来的变量，一样的会被解析出来，就像这样： 123#set( $hello = &quot;I LOVE&quot; )#set ( $world = &quot;ALIBABA&quot; )#set ( $mylove = &quot;$hello $world&quot; ) 结果就是I LOVE ALIBABA。惊不惊喜？意不意外？如果我们仅仅只是想表达$hello $world这个字符串呢，何解？答案是#literal命令和单引号。分别看一看： 单引号 123#set ( $name = &apos;hello&apos; )#set ( $hobby = &apos;$name&apos; )我的兴趣是$&#123;hobby&#125;. 结果是我的兴趣是$name.然后再看看#literal命令。 #literal命令 1234#set ( $name = &quot;hello&quot; )#literal()我的名字是$name.#end 结果是我的名字是$name.并不是我的名字是hello.为什么？因为在#literal命令体里面，所有的命令都失效了，全部都会被当做纯文本来处理。 #if / #elseif / #else命令和所有的编程语言一样，Velocity的模板语言也有自己的流程控制逻辑，通过#if / #elseif / #else命令来实现的。这个不用多说，给出一个demo就可以体会了： 123456789101112#set ($direction = 15)#set ($wind = 6)#if( $direction &lt; 10 ) &lt;strong&gt;Go North&lt;/strong&gt;#elseif( $direction == 10 ) &lt;strong&gt;Go East&lt;/strong&gt;#elseif( $wind == 6 ) &lt;strong&gt;Go South&lt;/strong&gt;#else &lt;strong&gt;Go West&lt;/strong&gt;#end 值得注意的是，如果一个引用没有被赋值，那么默认为空，在条件判断的时候为false。这一点和Java中的对象为空判断保持一致。 #foreach命令我们知道在Java中我们通过foreach循环遍历一个集合或者数组，同样的，在Velocity中，我们同样也是通过#foreach命令来遍历一个集合或者数组的。在Velocity中，使用#foreach命令的时候，第一个变量是循环遍历变量，第二个变量是需要被迭代遍历的集合或者数组等，中间使用关键字in来连接。使用方式比较简单： 12345&lt;ul&gt; #foreach( $product in $allProducts ) &lt;li&gt;$product&lt;/li&gt; #end&lt;/ul&gt; Velocity#foreach命令支持的Java类型是以下几种： 任何数组类型 java.lang.Collection，使用obj.iterator()返回的迭代器遍历 java.lang.Map，使用map.values().iterator()返回的迭代器遍历 java.lang.Iterator，直接使用这个迭代器遍历 java.lang.Enumeration，Velocity会把枚举包装成迭代器再遍历 注意：不推荐直接使用java.lang.Iterator和java.lang.Enumeration来直接遍历，因为它们不支持循环多遍，迭代器循环完一遍以后指针就不在前面了，再次遍历就取不到元素了。 遍历的时候我们需要统计这个元素的次序怎么办？很简单，Velocity为我们提供了步数（$velocityCount）和步长（counter）的支持。可以在运行时配置它，如下： 1234567# Default name of the loop counter# variable reference.directive.foreach.counter.name = velocityCount# Default starting value of the loop# counter variable reference.directive.foreach.counter.initial.value = 1 从上面可以看到，$velocityCount这个名字是可以被替换成任何你想要的名字的。但是，一般我们用默认的就行啦，很多Java框架解析的时候一般也是使用默认框架的。 单次遍历 12345&lt;table&gt; #foreach( $customer in $customerList ) &lt;tr&gt;&lt;td&gt;$velocityCount&lt;/td&gt;&lt;td&gt;$customer.Name&lt;/td&gt;&lt;/tr&gt; #end&lt;/table&gt; 嵌套遍历 123456#foreach ($category in $allCategories) Category # $velocityCount is $category #foreach ($item in $allItems) Item # $velocitycount is $item #end#end 为了避免死锁，Velocity还针对#foreach命令给出了一个限制的办法，就是设置一个运行时变量的值： 12# The maximum allowed number of loops.directive.foreach.maxloops = -1 默认为-1，表示不作限制。 加载资源#include和#parse命令Velocity中资源有两种方式，一种是普通文件，另一种是模板文件。针对普通文件和模板文件加载的命令也是不一样的，不能搞混了。一般来说#include命令是用来加载普通文件的，而#parse命令被用来加载模板文件。从命令的英文名字上也可以看出来对吧，include表示包括的意思，parse表示解析的意思。模板文件比普通文件多的是一些待解析的Velocity命令。 加载普通文件 12345## 加载普通文件one.txt#include( &quot;one.txt&quot; )## 加载多个文件#include( &quot;one.txt&quot;,&quot;two.txt&quot;,&quot;three.txt&quot; ) 另外，我们还可以使用引用的形式表示待加载文件。 12345## 将文件one.txt赋给变量$file0#set( $file0 = &quot;one.txt&quot; )## 加载多个文件#include( $file0,&quot;two.txt&quot;,&quot;three.txt&quot; ) 加载模板文件 #parse命令和#include命令很相似，但是#parse命令只能带一个参数，不像#include命令能带多个参数，这点需要大家多多注意。 1234567891011121314151617181920212223## ########################################## 模板文件 &quot;alibaba.vm&quot;## ########################################Hello, Alibaba!#set( $name = &quot;Alibaba&quot; )#parse(&quot;taobao.vm&quot;)#parse(&quot;tmall.vm&quot;)## ########################################## ########################################## 模板文件 &quot;taobao.vm&quot;## #########################################set( $name0 = &quot;Taobao&quot; )Hello, $!&#123;name&#125; from $!&#123;name0&#125;!## ########################################## ########################################## 模板文件 &quot;tmall.vm&quot;## #########################################set( $name0 = &quot;Tmall&quot; )Hello, $!&#123;name&#125; from $!&#123;name0&#125;!## ######################################## 结果就是： 123This is a Alibaba day.Hello, Alibaba from Taobao!Hello, Alibaba from Tmall! #stop命令在调试的时候，如果我们只想让模板被解析一部分呢？因为可能某个模板特别长，而我们需要被解析的部分可能就是开头的那么一小段，如果整个模板被解析的话可能非常耗时，这个时候我们就需要手动地告诉模板引擎不要再解析了，到此为止，后面的内容就会全部丢弃掉，不再解析。Velocity中#stop命令可以实现这个功能。直接来例子说话。 1234#set( $name = &quot;alibaba&quot; )My name is $name.#stopThis line won&apos;t be displayed! 结果就是： 1My name is alibaba. 可以看到，下面那句This line won&#39;t be displayed!真的没有显示出来。但是不代表你的模板文件存在语法错误的时候它会忽略掉哈，如果说你的模板中在#stop命令后面的代码存在语法错误的时候，引擎依然会报错的。两个英文单词可以区分，#stop命令是stop rendering，而不是stop parsing。 操作符operators操作符比较简单，大家注意一下就是文本的写法比如and表示与和简略的写法&amp;&amp;表示与是一样的。 12345678910#set ($a = true)#set ($b = false)#if ($a || $b) 换做or也是对的#end#if ($a and $b) 换做&amp;&amp;也是对的#end 来一张对照表格： Type of operator short version text version equal == eq not equal != ne greater than &gt; gt greater or equal than &gt;= ge less than &lt; lt less or equal than &lt;= le logical and &amp;&amp; and logical or &#124;&#124; or logical not ! not 前方高能预警：非常需要大家注意的是不像其它的语言那样，数字0和字符串空串&quot;&quot;可以表示为false，Velocity中是不可以的，它只允许布尔型的值false和空值null转为false，其它一切的对象都会被当做是true。务必注意啦！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Velocity","slug":"Velocity","permalink":"http://qinjiangbo.com/tags/Velocity/"},{"name":"模板引擎","slug":"模板引擎","permalink":"http://qinjiangbo.com/tags/模板引擎/"}]},{"title":"Hexo添加畅言打赏插件","slug":"add-changyan-donation-plugin-to-hexo-blog","date":"2017-06-26T16:05:28.000Z","updated":"2017-06-28T15:01:26.000Z","comments":true,"path":"add-changyan-donation-plugin-to-hexo-blog.html","link":"","permalink":"http://qinjiangbo.com/add-changyan-donation-plugin-to-hexo-blog.html","excerpt":"","text":"今天给博客添加了一个打赏功能，是由畅言提供的，感觉还不错的。现在直接说说，如何在Hexo博客中添加打赏功能的插件。 获取打赏代码进入畅言的后台，点击左边的菜单，选择实验室，然后再点击打赏就可以看到打赏的代码了。如下： 配置Hexo博客和前一篇文章一样，修改changyan.ejs和index.ejs两个文件就可以了。 配置changyan.ejs文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;% if (typeof(script) !== &apos;undefined&apos; &amp;&amp; script) &#123; %&gt; &lt;script type=&quot;text/javascript&quot;&gt; (function() &#123; var appid = &apos;&lt;%= theme.comment.changyan.appId %&gt;&apos;; var conf = &apos;&lt;%= theme.comment.changyan.appKey %&gt;&apos;; var width = window.innerWidth || document.documentElement.clientWidth; if (width &lt; 960) &#123; window.document.write(&apos;&lt;script id=&quot;changyan_mobile_js&quot; charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=&apos; + appid + &apos;&amp;conf=&apos; + conf + &apos;&quot;&gt;&lt;\\/script&gt;&apos;); &#125; else &#123; var loadJs = function(d, a) &#123; var c = document.getElementsByTagName(&quot;head&quot;)[0] || document.head || document.documentElement; var b = document.createElement(&quot;script&quot;); b.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;); b.setAttribute(&quot;charset&quot;, &quot;UTF-8&quot;); b.setAttribute(&quot;src&quot;, d); if (typeof a === &quot;function&quot;) &#123; if (window.attachEvent) &#123; b.onreadystatechange = function() &#123; var e = b.readyState; if (e === &quot;loaded&quot; || e === &quot;complete&quot;) &#123; b.onreadystatechange = null; a() &#125; &#125; &#125; else &#123; b.onload = a &#125; &#125; c.appendChild(b) &#125;; loadJs(&quot;https://changyan.sohu.com/upload/changyan.js&quot;, function() &#123; window.changyan.api.config(&#123; appid: appid, conf: conf &#125;) &#125;); &#125; &#125;)(); &lt;/script&gt; &lt;!-- 代码2：用来读取评论框配置，此代码需放置在代码1之后。 --&gt; &lt;!-- 如果当前页面有评论框，代码2请勿放置在评论框代码之前。 --&gt; &lt;!-- 如果页面同时使用多个实验室项目，以下代码只需要引入一次，只配置上面的div标签即可 --&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;https://changyan.itc.cn/js/lib/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;https://changyan.sohu.com/js/changyan.labs.https.js?appid=&lt;%= theme.comment.changyan.appId %&gt;&quot;&gt;&lt;/script&gt;&lt;% &#125; else &#123; %&gt; &lt;div id=&quot;SOHUCS&quot; sid=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt;&lt;% &#125; %&gt; 修改index.ejs文件1234567891011121314151617&lt;% if (post.comments) &#123; %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;% if (theme.comment.disqus) &#123; %&gt; &lt;%- partial(&apos;comment/disqus&apos;) %&gt; &lt;% &#125; else if (theme.comment.duoshuo) &#123; %&gt; &lt;%- partial(&apos;comment/duoshuo&apos;) %&gt; &lt;% &#125; else if (theme.comment.youyan) &#123; %&gt; &lt;%- partial(&apos;comment/youyan&apos;) %&gt; &lt;% &#125; else if (theme.comment.changyan.on) &#123; %&gt; &lt;!-- 打赏 --&gt; &lt;div style=&quot;text-align:center&quot;&gt; &lt;div id=&quot;cyReward&quot; role=&quot;cylabs&quot; data-use=&quot;reward&quot; sid=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;%- partial(&apos;comment/changyan&apos;) %&gt; &lt;% &#125; %&gt; &lt;/section&gt;&lt;% &#125; %&gt; 总结预览一下结果，直接看下面的“打赏”按钮就行啦，当然，按钮的颜色等信息你可以在畅言的配置中自定义，这个完全看个人喜好。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"畅言打赏","slug":"畅言打赏","permalink":"http://qinjiangbo.com/tags/畅言打赏/"},{"name":"Hexo主题","slug":"Hexo主题","permalink":"http://qinjiangbo.com/tags/Hexo主题/"}]},{"title":"Hexo博客添加畅言评论框","slug":"add-changyan-comments-to-hexo-blog","date":"2017-06-25T13:49:30.000Z","updated":"2017-06-27T16:42:33.000Z","comments":true,"path":"add-changyan-comments-to-hexo-blog.html","link":"","permalink":"http://qinjiangbo.com/add-changyan-comments-to-hexo-blog.html","excerpt":"","text":"和以前一样，捣鼓捣鼓一件事情成功以后写一篇博客总结一下经验！免得大家和我一样再次踩坑。这一次需要记录的是6月1号（2017-06-01）多说平台关闭事件。以前一直使用多说，后来发了一封邮件，说“由于公司业务调整，多说社会化评论插件将会与6月1号关闭，请知悉！”因此消息一出，我就把多说关闭了，换成了友言，但是后来某一天友言也打不开了，莫名其妙。于是一狠心，就直接将博客的评论关闭了。但是细细想想，写博客是为了什么，其实是记录自己的感悟和总结自己的经验，与大家交流的，关闭评论不等于直接切断了这个通道么？所以决定还是得重新打开评论，但是选择哪一个呢？网易跟帖和搜狐畅言摆在了面前，博主一直都在逛网易，神评论太多，不想把自己的博客搞得像新闻客户端一样，所以选择了畅言。推荐大家也是用这个，功能非常强大！ 博主使用的是PPOffice提供的hueman主题。因此本博客的所有操作针对这个博客有效，大家对照着主题结构修改对应的文件即可。 畅言工作台进入畅言的官网http://changyan.kuaizhan.com/，注册一个账号，然后登录进入畅言的工作台，如下： 看到上面红框标注的内容，是我们待会需要使用到的数据，一个是App ID，一个是App Key。 修改主题config.yml文件在主题文件config.yml中添加如下代码： 123456789# Commentcomment: disqus: # enter disqus shortname here duoshuo: # enter duoshuo shortname here qinjiangbo youyan: # 2127917 # enter youyan uid here 2127917 changyan: appId: [APP ID] appKey: [APP KEY] on: #表示是否开启畅言评论，随便写什么，不为空就行 在上面的代码中，我们添加了APP ID和APP KEY两个字段，这两个字段非常重要！ 创建changyan.ejs文件在hueman主题的/hueman/layout/comment/目录下新建一个changyan.ejs文件，照着disqus.ejs写一份自己的评论框插件。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;% if (typeof(script) !== &apos;undefined&apos; &amp;&amp; script) &#123; %&gt; &lt;script type=&quot;text/javascript&quot;&gt; (function() &#123; var appid = &apos;&lt;%= theme.comment.changyan.appId %&gt;&apos;; var conf = &apos;&lt;%= theme.comment.changyan.appKey %&gt;&apos;; var width = window.innerWidth || document.documentElement.clientWidth; if (width &lt; 960) &#123; window.document.write(&apos;&lt;script id=&quot;changyan_mobile_js&quot; charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=&apos; + appid + &apos;&amp;conf=&apos; + conf + &apos;&quot;&gt;&lt;\\/script&gt;&apos;); &#125; else &#123; var loadJs = function(d, a) &#123; var c = document.getElementsByTagName(&quot;head&quot;)[0] || document.head || document.documentElement; var b = document.createElement(&quot;script&quot;); b.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;); b.setAttribute(&quot;charset&quot;, &quot;UTF-8&quot;); b.setAttribute(&quot;src&quot;, d); if (typeof a === &quot;function&quot;) &#123; if (window.attachEvent) &#123; b.onreadystatechange = function() &#123; var e = b.readyState; if (e === &quot;loaded&quot; || e === &quot;complete&quot;) &#123; b.onreadystatechange = null; a() &#125; &#125; &#125; else &#123; b.onload = a &#125; &#125; c.appendChild(b) &#125;; loadJs(&quot;https://changyan.sohu.com/upload/changyan.js&quot;, function() &#123; window.changyan.api.config(&#123; appid: appid, conf: conf &#125;) &#125;); &#125; &#125;)(); &lt;/script&gt;&lt;% &#125; else &#123; %&gt; &lt;div id=&quot;SOHUCS&quot; sid=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt;&lt;% &#125; %&gt; 注意：上面第一行代码中is_home()这个方法一定要在这个文件里面加上，否则你的博客首页最底下会出现畅言的评论框，这是我们所不希望看到的。 修改scripts.ejs文件scripts.ejs文件在changyan.ejs文件的相同目录下，编辑scripts.ejs文件并作如下修改： 123456789&lt;% if (theme.comment.disqus) &#123; %&gt; &lt;%- partial(&apos;comment/disqus&apos;, &#123; script: true &#125;) %&gt;&lt;% &#125; else if (theme.comment.duoshuo) &#123; %&gt; &lt;%- partial(&apos;comment/duoshuo&apos;, &#123; script: true &#125;) %&gt;&lt;% &#125; else if (theme.comment.youyan) &#123; %&gt; &lt;%- partial(&apos;comment/youyan&apos;, &#123; script: true &#125;) %&gt;&lt;% &#125; else if (theme.comment.changyan.on) &#123; %&gt; &lt;%- partial(&apos;comment/changyan&apos;, &#123; script: true &#125;) %&gt;&lt;% &#125; %&gt; 修改index.ejs文件index.ejs文件也在changyan.ejs文件的相同目录下，同样编辑它， 12345678910111213&lt;% if (post.comments) &#123; %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;% if (theme.comment.disqus) &#123; %&gt; &lt;%- partial(&apos;comment/disqus&apos;) %&gt; &lt;% &#125; else if (theme.comment.duoshuo) &#123; %&gt; &lt;%- partial(&apos;comment/duoshuo&apos;) %&gt; &lt;% &#125; else if (theme.comment.youyan) &#123; %&gt; &lt;%- partial(&apos;comment/youyan&apos;) %&gt; &lt;% &#125; else if (theme.comment.changyan.on) &#123; %&gt; &lt;%- partial(&apos;comment/changyan&apos;) %&gt; &lt;% &#125; %&gt; &lt;/section&gt;&lt;% &#125; %&gt; 注意：其实一开始是想在这个文件第一行添加is_post()方法，但是不奏效，首页依然会显示畅言评论框，所以，没有在这儿添加，如果你知道原因欢迎在下面评论！ 总结畅言是一个非常不错的社会化评论插件平台，提供了非常丰富的功能，支持非常多的平台，唯独没有hexo，是不是很囧。不过大家自己动手搭博客平台的也一定都是动手能力特别强的同学，所以，自己琢磨琢磨就出来啦！ Bingo目前将这个插件已经发Pull Request到官方的Github啦，很高兴已经被采纳了！大家后面可以直接使用这个主题而不需要自己再额外地去找啦！ 更新：这里的is_post()方法的问题已经解决！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"Hexo主题","slug":"Hexo主题","permalink":"http://qinjiangbo.com/tags/Hexo主题/"},{"name":"畅言评论框","slug":"畅言评论框","permalink":"http://qinjiangbo.com/tags/畅言评论框/"}]},{"title":"Velocity编程指南（二）","slug":"velocity-programming-guide-2","date":"2017-06-21T15:46:19.000Z","updated":"2018-04-02T09:03:43.000Z","comments":true,"path":"velocity-programming-guide-2.html","link":"","permalink":"http://qinjiangbo.com/velocity-programming-guide-2.html","excerpt":"","text":"Velocity模板引擎如何使用，语法是怎样的？本博客将会在变量的赋值，引用以及注释等三个方面来谈一谈Velocity的语法。但是在开始语法之前，我们快速地搞一个Hello World出来试下水。 123456&lt;html&gt;&lt;body&gt;#set( $name = \"Velocity\" )Hello $name World!&lt;/body&gt;&lt;/html&gt; 可以看到这段代码经过模板引擎渲染以后会输出以下文字： 12345&lt;html&gt;&lt;body&gt;Hello Velocity World!&lt;/body&gt;&lt;/html&gt; 展示出来就是一个HTML页面，上面写着Hello Velocity World!。观察上面这个例子不难发现，Hello $name World!被替换为了Hello Velocity World!，原因是$name变量被#set($name = &quot;Velocity&quot;)语句赋值为了Velocity，因此就直接等值替换了。 小建议：为了使你的VTL代码可读性更高，我们建议你的赋值语句最好独占一行，剩下的语句就另起一行。 语法元素Elements和其他的语言一样，Velocity一样也有一些语法元素，比如语句和命令，引用以及注释。本节主要介绍这三个方面。 语句和命令先说一下语句和命令的区别，Linux命令我们都知道一些，比如rm，ls以及ps等等，这一些都是命令，shell编程中它们只是语句中的一步分，后面还会带很多参数。Velocity中的命令一样，也是语句的一部分，下面我们就分析一下一个VTL是怎么组成的？ 123456789101112131415161718192021#set($a = 10) ## Velocity单行语句^\\_/\\_______/| | || | +---------- 圆括号中的表达式| || +---------------- Velocity命令|+------------------ Velocity语句的开始标志+------------------ Velocity语句的开始标志|| +-------------- Velocity命令| || | +--- 圆括号中的表达式| __|__ ______|______v/ \\/ \\#foreach($i in [0..10]) ## Velocity多行语句 Counter is $i ## 语句体#end ## Velocity语句的结束标志 单行语句例子 1234#set($name = &quot;Banana&quot;)#include(&quot;Apple.vm&quot;)#parse(&quot;Apple.vm&quot;)#stop 多行语句例子 12345678910111213#foreach($i in [1..20]) The num is $i#end#literal This is a literal block of sample text#end#if($fruit == &quot;banana&quot;) This is a banana.#else This is not a banana.#end 注意：这里#end命令其实也可以和前面的语句放在同一行，但是呢，我们依然称这些语句为多行语句。 引用references这个很有趣，因为我们都知道，在Java中我们使用标识标识符去操作很多事情，然后最后给其指定一个值，根据这个值，这些操作最后会有一个结果。我们将这个标识符称为一个引用（引用都是通过一个$符号引导的）。尤其是在Velocity做模板开发Java Web程序的时候，Web页面的设计者只需要关心页面是如何组织的，并不关心后台的数据如何执行，并且是如何传过来的，他们只需要假想这个模块已经有值了，然后根据这个假想去设计相关的功能，这样就将工作和后端的工程师隔离了，大大提高了工作效率。我们来看一看下面的例子有哪些引用？ 1234567891011## 简单引用The total amout is $total.## 属性引用You currently have $cart.items Items in your Shopping cart.## 方法引用We offer you a discount of $cart.calculateDiscount() for your purchase.## 在Velocity中直接创建一个全新的引用#set($linesPerPage = 20) 注意：有一种情况需要小心，那就是标识符的区分度问题，比如下面这样的： 12#set($we = &quot;Alibaba&quot;)This is a $weday. 大家可能会觉得结果是This is a Alibabaday.实际情况呢？This is a $weday.，怎么回事？不应该是This is a Alibabaday.吗？原因是$we和$weday都被当成一个独立的标识符了，所以，这个时候需要区分开，加上花括号即可解决这个问题。 12#set($we = &quot;Alibaba&quot;)This is a $&#123;we&#125;day. 结果就是：This is a Alibabaday. 注释comments Velocity的注释和Java的注释差不多，也分为单行注释和多行注释。单行注释一般是以两个#号开始的，为什么不是一个#号？因为一个#号表示一个Velocity命令啊！多行注释就是采用#号和*号结合的方式来使用的，用法和Java里面的非常相似！下面就简单地说说单行注释和多行注释。 单行注释的例子 12## 这是单行注释哟.This is visible in the output ## 这也是单行注释哟. 多行注释的例子 1234567这是多行注释块外面的文本，是可见的。#* 我们在多行注释，放我出去！！！为什么我不可见！！！*#上面👆多行注释里面的文本一点都不蛋定，看我，在注释快外面，是可见的，哈哈😆！ 还有一种方式使用多行注释，就是像Java代码一样标准化的代码块，如下： 12345678#**This is a VTL comment block andmay be used to store such informationas the document author and versioninginformation:@author qinjiangbo@github.io@version 1.0.0*# 转义符escape在Velocity里面，转义符的规则和Java里面其实是差不多的，下面结合几个具体的例子来说说。 1234567\\ 表示一个反斜杠\\\\ 表示一个反斜杠\\# （没有命令跟着时）表示一个\\#\\$ （没有引用跟着时）表示一个\\$\\#end 表示#end\\#set ($name = &quot;Alibaba&quot;) 表示#set ($name = &quot;Alibaba&quot;)\\$alibaba 表示$alibaba 引用References开始讲一个大的方向就是引用，我们知道，正是有了引用，编程才开始变得灵活多变。在VTL里面，有三种类型的引用，分别是变量，属性和方法。它们是连接你的Java应用和模板的胶水，只有通过它们，我们的后台逻辑才和模板联系起来，才能构成一个完整的业务。 标识符identifiersVelocity的标识符很有意思，就是只能使用字母开头的短语作为标识符的表示形式，另外命名还有以下几点要求（主要是三种类型的字符构成）： 字母（a-z, A-Z） 数字（0-9） 横线（-）或者下划线（_） Velocity的标识符命名和Java一样，也是大小写敏感的，这一点非常重要！！！ 变量variables变量是最简单的引用类型，因为每一个引用同样也是一个变量。每一个变量代表了一个Java对象。下面来看一下有效的变量命名： 12345$foo$bar$foo-bar$foo_bar$fooBar1 说一下一个叫上下文的东西，在Velocity里面，上下文通常用于存放变量和引用的映射关系。这就是为什么我们能从Java代码中直接将值传递到Velocity模板引擎中。当然啦，我们也可以直接通过Velocity命令将变量放入上下文中。比如下面这样： 12#set ($love = &quot;Alibaba&quot;)My love is $love. ## My love is Alibaba. 整个上下文中就包含了$love这个变量，因此我们可以在模板的任何地方使用它，直接等只替换就OK了。 属性propertiesVelocity允许你通过很简单的方式去访问一个对象的属性，一般来说，我们是通过.号来访问一个Velocity对象的属性的。如下： 123$customer.address$purchase.total$cart.customerDiscount 一个属性（property）名字并不仅仅是代表这个对象的一个域（field），它还可以表示这个对象的方法。我们以第2个对象为例：$purchase.total有以下一些含义： 当这个对象有gettotal()这个方法的时候，就会调用这个方法； 如果这个对象是一个Java Bean对象，那么就会调用这个对象的getter方法getTotal()； 如果这个对象包含get方法，就会调用这个get()方法，只不过total作为参数传递进去； 如果这个对象包含isTotal()方法，调用这个方法； 好，知道了上述的规则以后，我们总结一下Velocity对象查找属性的规则： 小写开头的属性 1234gettotal()getTotal()get(&quot;total&quot;)isTotal() 大写开头的属性 1234getTotal()gettotal()get(&quot;total&quot;)isTotal() 可以看到，大写和小写前两个顺序是完全不一样的，因此，在编写代码的时候命名格式且其要规范统一，否则会碰到这种特别头疼的问题。 方法methodsVelocity对象的方法的调用其实非常简单，如果你知道Java方法调用的话（你一定知道，因为这是Java模板引擎），Velocity对象的方法调用和Java的方式一样。直接上例子： 123456789$cart.calculateTotal()$customer.updatePurchases($cart)$shop.checkInventory()$cart.addTaxes(8, 16)# Property access$page.setTitle( &quot;My Home Page&quot; )$customer.getAddress()$purchase.getTotal() 属性和方法的主要不同点在于你可以给方法指定一组参数列表。因为方法是可以传递参数的，而属性没法传递。 引用references在使用模板引擎的时候，需要将模板的文本和引擎的引用区分开，前面讲过，一不小心很容易变量就混合在一起了，不是特别好区分。通常我们建议使用花括号{和}跟在$符号后面来包含这个引用，用于区分一个引用和普通模板文本。 123$&#123;fruit&#125;$&#123;customer.address&#125;$&#123;purchase.getTotal()&#125; 以第一行为例，如果你要点一杯果汁，你可能这么声明： 1I want a cup of $fruitJuice. 结果你啥也没得到，更别说果汁了，如果你改变一下会更好： 1I want a cup of $&#123;fruit&#125;Juice. 因为引用是${fruit}而不是${fruitjuice}，这个很重要。另外需要注意的一个地方是引用的表达上面，尤其是在Web页面模板上的时候。往往空指针的情况容易导致这个变量直接就输出在了屏幕上，我们可以换一种写法： 之前的写法 1&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$email&quot;/&gt; 如果$email为空怎么办？这个文本域就会显示“$email”这个字符串。是不是非常不友好，我们期望的是如果$email为空，直接不要显示任何东西。可以在$符号和变量之间加上一个!号，就像这样： 现在的写法 1&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$!email&quot;/&gt; 更规范的写法如下： 1&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;$!&#123;email&#125;&quot;/&gt; 总结本博客主要是讲述了Velocity模板引擎中的引用部分以及它相应的使用注意事项。Velocity中的对象引用很大程度上和Java中的是一样的，大家注意其中的几点不同就行啦。下一章主要是介绍VTL中的命令这一块。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Velocity","slug":"Velocity","permalink":"http://qinjiangbo.com/tags/Velocity/"},{"name":"模板引擎","slug":"模板引擎","permalink":"http://qinjiangbo.com/tags/模板引擎/"}]},{"title":"Velocity编程指南（一）","slug":"velocity-programming-guide-1","date":"2017-06-18T14:49:28.000Z","updated":"2018-04-02T09:03:39.000Z","comments":true,"path":"velocity-programming-guide-1.html","link":"","permalink":"http://qinjiangbo.com/velocity-programming-guide-1.html","excerpt":"","text":"最近在看一个模板引擎工具Velocity，是Apache项目下面的一个子项目，已经非常出名了！不过我之前倒没有接触过这个模板引擎，我用的是另一个模板引擎freemarker，这也是Apache下面的一个项目。两者都非常优秀，原理都差不多，大家可以根据项目的需要选择其中一个学习。 什么是Velocity?先回答第一个问题，什么是Velocity？嗯，Velocity就是一个基于Java的模板引擎。它允许网页设计者引用Java代码中定义的方法，模板的开发者和Java后台的开发者可以在MVC模式下并行地工作，这样能极大地提升效率。除了生成网页代码以外，Velocity能支持生成SQL，特定格式的文本以及其它任何你想生成的文本格式。 定义语言VTLVTL就是Velocity Template Language的简称，是Velocity的模板语言。本系列的博客主要就是要讨论Velocity的语法及其使用方式。本系列的博客中所使用的例子哈，基本上都是网页中的动态嵌入文件，但是呢，我们前面说到过，Velocity的用法和潜力远远不止如此！ 开始旅程好了，唠叨完这一些以后，我们正式地开始这段旅程哈！本系列共分为五章，本文是第一章，后面中间三章讲语法，最后一章实战！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Velocity","slug":"Velocity","permalink":"http://qinjiangbo.com/tags/Velocity/"},{"name":"模板引擎","slug":"模板引擎","permalink":"http://qinjiangbo.com/tags/模板引擎/"}]},{"title":"使用Maven生成Fat Jar","slug":"build-fat-jar-with-maven","date":"2017-06-11T15:43:05.000Z","updated":"2017-06-11T16:16:48.000Z","comments":true,"path":"build-fat-jar-with-maven.html","link":"","permalink":"http://qinjiangbo.com/build-fat-jar-with-maven.html","excerpt":"","text":"在这篇博客里面我们将详细地讲解如何利用maven来创造一个fat jar。可能大家对于fat jar的概念还不是很熟悉，没关系，在开始进一步的讲解之前我会跟你说明fat jar是什么的。另外本文的环境是 123Maven 3.3.9JDK 1.8Joda-Time 2.5 大家根据相应的情况自己创建一个Maven项目。 什么是Fat Jar?什么是Fat Jar？简单地说就是胖Jar呗！哈哈！就是说这个Jar所装的东西比一般的Jar要多嘛！一般地，我们通过maven的插件maven-jar-plugin所打包生成的jar都是只包含我们项目的源码的，它不包含我们所依赖的第三方库，这样就会导致一个问题，如果我们的第三方库不在CLASSPATH下面会怎样？当然是会出现java.lang.NoClassDefFoundError的问题咯！因此，我们需要使用一种方式，能使得项目所依赖的第三方库能够随着我们的项目源码一起被打包，这样我们就完全不用担心类找不到的问题啦！这就是Fat Jar的来历！ 创建Maven项目两种方式：通过命令行或者通过IDE生成。 (1). 通过命令行： 12$ mvn archetype:generate -DgroupId=com.qinjiangbo -DartifactId=FatJar -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false (2). 通过IDE生成，这里我用的IDEA 项目视图和主类 生成普通Jar生成普通Jar我们可以使用maven-jar-plugin这个插件来打包。Maven配置代码如下： 12345678910111213141516&lt;build&gt; &lt;finalName&gt;fat-jar-example&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.qinjiangbo.App&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 其中&lt;mainClass&gt;com.qinjiangbo.App&lt;/mainClass&gt;就是指明了main函数的所在地。我们生成好的jar名为fat-jar-example.jar，在命令行打开项目的target目录： 123456789101112# Richard at Richards-MacBook-Pro.local in ~/IdeaProjects/FatJar/target [23:28:14]→ jar tf fat-jar-example.jar META-INF/META-INF/MANIFEST.MFcom/com/qinjiangbo/com/qinjiangbo/App.classMETA-INF/maven/META-INF/maven/com.qinjiangbo/META-INF/maven/com.qinjiangbo/FatJar/META-INF/maven/com.qinjiangbo/FatJar/pom.xmlMETA-INF/maven/com.qinjiangbo/FatJar/pom.properties 很明显，这个jar包里面没有第三方库。我们来看看执行结果是什么？ 1234567891011# Richard at Richards-MacBook-Pro.local in ~/IdeaProjects/FatJar/target [23:28:21]→ java -jar fat-jar-example.jar Hello Fat Jar!Exception in thread \"main\" java.lang.NoClassDefFoundError: org/joda/time/LocalDate at com.qinjiangbo.App.main(App.java:12)Caused by: java.lang.ClassNotFoundException: org.joda.time.LocalDate at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ... 1 more 可以看到，这个Jar 正常地执行了一半，执行LocalDate.now()的时候报错了，因为找不到LocalDate这个类，很好理解了吧？好，我们再看看Fat Jar是什么样子的。 生成Fat Jar生成Fat Jar我们使用的是One-Jar这个Maven插件。具体配置代码如下： 1234567891011121314151617&lt;build&gt; &lt;finalName&gt;fat-jar-example&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.jolira&lt;/groupId&gt; &lt;artifactId&gt;onejar-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;one-jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 通过mvn package生成的Jar名称为fat-jar-example.one-jar.jar。同样的，找到项目target所在的目录：首先看看Fat Jar里面究竟是什么？ 123456789101112131415161718192021222324252627282930313233343536373839404142# Richard at Richards-MacBook-Pro.local in ~/IdeaProjects/FatJar/target [23:41:12]→ jar -tf fat-jar-example.one-jar.jar META-INF/MANIFEST.MFmain/fat-jar-example.jarlib/joda-time-2.5.jarcom/com/simontuffs/com/simontuffs/onejar/.versionOneJar.classcom/simontuffs/onejar/Boot$1.classcom/simontuffs/onejar/Boot$2.classcom/simontuffs/onejar/Boot$3.classcom/simontuffs/onejar/Boot.classcom/simontuffs/onejar/Handler$1.classcom/simontuffs/onejar/Handler.classcom/simontuffs/onejar/IProperties.classcom/simontuffs/onejar/JarClassLoader$1.classcom/simontuffs/onejar/JarClassLoader$2.classcom/simontuffs/onejar/JarClassLoader$ByteCode.classcom/simontuffs/onejar/JarClassLoader$FileURLFactory$1.classcom/simontuffs/onejar/JarClassLoader$FileURLFactory.classcom/simontuffs/onejar/JarClassLoader$IURLFactory.classcom/simontuffs/onejar/JarClassLoader$OneJarURLFactory.classcom/simontuffs/onejar/JarClassLoader.classcom/simontuffs/onejar/OneJarFile$1.classcom/simontuffs/onejar/OneJarFile$2.classcom/simontuffs/onejar/OneJarFile.classcom/simontuffs/onejar/OneJarURLConnection.classsrc/src/com/src/com/simontuffs/src/com/simontuffs/onejar/src/OneJar.javasrc/com/simontuffs/onejar/Boot.javasrc/com/simontuffs/onejar/Handler.javasrc/com/simontuffs/onejar/IProperties.javasrc/com/simontuffs/onejar/JarClassLoader.javasrc/com/simontuffs/onejar/OneJarFile.javasrc/com/simontuffs/onejar/OneJarURLConnection.javadoc/doc/one-jar-license.txt 仔细和前面一个比较我们就可以很明显地看出区别，那就是包含了第三方库，同时也包含了onejar本身的源码。执行这个fat jar看看会不会正常？ 1234# Richard at Richards-MacBook-Pro.local in ~/IdeaProjects/FatJar/target [23:41:23]→ java -jar fat-jar-example.one-jar.jar Hello Fat Jar!Current date: 2017-06-11 完全正常！！！说明是可行的！我推荐同学们如果需要使用Fat Jar的时候就是用这种方式打包。 Fat Jar的应用Fat Jar有哪些应用呢？一般来说，Fat Jar主要是有以下几个方向的应用： 做Java小工具应用程序，我们直接执行这个Jar就可以启动程序。 Spring-Boot生成的可执行Jar就是一种Fat Jar。 目前博主能够想到的方向就这两点哈，如果后面想到了继续补充！附上整个项目的Maven配置文件pom.xml，大家可以直接拷贝，自己参照着修改一下再build就可以了！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qinjiangbo&lt;/groupId&gt; &lt;artifactId&gt;FatJar&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;fat-jar-example&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.qinjiangbo.App&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.jolira&lt;/groupId&gt; &lt;artifactId&gt;onejar-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;one-jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://qinjiangbo.com/tags/maven/"},{"name":"fat jar","slug":"fat-jar","permalink":"http://qinjiangbo.com/tags/fat-jar/"}]},{"title":"RPC服务和HTTP服务对比","slug":"rpc-services-vs-http-services","date":"2017-06-10T08:15:40.000Z","updated":"2017-10-20T01:56:10.000Z","comments":true,"path":"rpc-services-vs-http-services.html","link":"","permalink":"http://qinjiangbo.com/rpc-services-vs-http-services.html","excerpt":"","text":"很长时间以来都没有怎么好好搞清楚RPC（即Remote Procedure Call，远程过程调用）和HTTP调用的区别，不都是写一个服务然后在客户端调用么？这里请允许我迷之一笑~Naive！本文简单地介绍一下两种形式的C/S架构，先说一下他们最本质的区别，就是RPC主要是基于TCP/IP协议的，而HTTP服务主要是基于HTTP协议的，我们都知道HTTP协议是在传输层协议TCP之上的，所以效率来看的话，RPC当然是要更胜一筹啦！下面来具体说一说RPC服务和HTTP服务。 OSI网络七层模型在说RPC和HTTP的区别之前，我觉的有必要了解一下OSI的七层网络结构模型（虽然实际应用中基本上都是五层），它可以分为以下几层： （从上到下） 第一层：应用层。定义了用于在网络中进行通信和传输数据的接口； 第二层：表示层。定义不同的系统中数据的传输格式，编码和解码规范等； 第三层：会话层。管理用户的会话，控制用户间逻辑连接的建立和中断； 第四层：传输层。管理着网络中的端到端的数据传输； 第五层：网络层。定义网络设备间如何传输数据； 第六层：链路层。将上面的网络层的数据包封装成数据帧，便于物理层传输； 第七层：物理层。这一层主要就是传输这些二进制数据。 实际应用过程中，五层协议结构里面是没有表示层和会话层的。应该说它们和应用层合并了。我们应该将重点放在应用层和传输层这两个层面。因为HTTP是应用层协议，而TCP是传输层协议。好，知道了网络的分层模型以后我们可以更好地理解为什么RPC服务相比HTTP服务要Nice一些！ RPC服务从三个角度来介绍RPC服务：分别是RPC架构，同步异步调用以及流行的RPC框架。 RPC架构先说说RPC服务的基本架构吧。允许我可耻地盗一幅图哈~我们可以很清楚地看到，一个完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server Stub，这个Stub大家可以理解为存根。分别说说这几个组件： 客户端（Client），服务的调用方。 服务端（Server），真正的服务提供者。 客户端存根，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。 服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。 RPC主要是用在大型企业里面，因为大型企业里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。实际的开发当中是这么做的，项目一般使用maven来管理。比如我们有一个处理订单的系统服务，先声明它的所有的接口（这里就是具体指Java中的interface），然后将整个项目打包为一个jar包，服务端这边引入这个二方库，然后实现相应的功能，客户端这边也只需要引入这个二方库即可调用了。为什么这么做？主要是为了减少客户端这边的jar包大小，因为每一次打包发布的时候，jar包太多总是会影响效率。另外也是将客户端和服务端解耦，提高代码的可移植性。 同步调用与异步调用什么是同步调用？什么是异步调用？同步调用就是客户端等待调用执行完成并返回结果。异步调用就是客户端不等待调用执行完成返回结果，不过依然可以通过回调函数等接收到返回结果的通知。如果客户端并不关心结果，则可以变成一个单向的调用。这个过程有点类似于Java中的callable和runnable接口，我们进行异步执行的时候，如果需要知道执行的结果，就可以使用callable接口，并且可以通过Future类获取到异步执行的结果信息。如果不关心执行的结果，直接使用runnable接口就可以了，因为它不返回结果，当然啦，callable也是可以的，我们不去获取Future就可以了。 流行的RPC框架目前流行的开源RPC框架还是比较多的。下面重点介绍三种： gRPC是Google最近公布的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言。 我们知道HTTP2.0是基于二进制的HTTP协议升级版本，目前各大浏览器都在快马加鞭的加以支持。 这个RPC框架是基于HTTP协议实现的，底层使用到了Netty框架的支持。 Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的IDL定义文件自动生成服务代码框架。用户只要在其之前进行二次开发就行，对于底层的RPC通讯等都是透明的。不过这个对于用户来说的话需要学习特定领域语言这个特性，还是有一定成本的。 Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。同样 的远程接口是基于Java Interface，并且依托于spring框架方便开发。可以方便的打包成单一文件，独立进程运行，和现在的微服务概念一致。 偷偷告诉你集团内部已经不怎么使用dubbo啦，现在用的比较多的叫HSF，又名“好舒服”。后面有可能会开源，大家拭目以待。 HTTP服务其实在很久以前，我对于企业开发的模式一直定性为HTTP接口开发，也就是我们常说的RESTful风格的服务接口。的确，对于在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议进行传输。我们记得之前本科实习在公司做后台开发的时候，主要就是进行接口的开发，还要写一大份接口文档，严格地标明输入输出是什么？说清楚每一个接口的请求方法，以及请求参数需要注意的事项等。比如下面这个例子：POST http://www.httpexample.com/restful/buyer/info/share接口可能返回一个JSON字符串或者是XML文档。然后客户端再去处理这个返回的信息，从而可以比较快速地进行开发。但是对于大型企业来说，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。 总结RPC服务和HTTP服务还是存在很多的不同点的，一般来说，RPC服务主要是针对大型企业的，而HTTP服务主要是针对小企业的，因为RPC效率更高，而HTTP服务开发迭代会更快。总之，选用什么样的框架不是按照市场上流行什么而决定的，而是要对整个项目进行完整地评估，从而在仔细比较两种开发框架对于整个项目的影响，最后再决定什么才是最适合这个项目的。一定不要为了使用RPC而每个项目都用RPC，而是要因地制宜，具体情况具体分析。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"微服务","slug":"架构师/微服务","permalink":"http://qinjiangbo.com/categories/架构师/微服务/"}],"tags":[{"name":"RPC","slug":"RPC","permalink":"http://qinjiangbo.com/tags/RPC/"},{"name":"HTTP","slug":"HTTP","permalink":"http://qinjiangbo.com/tags/HTTP/"}]},{"title":"遇见阿里","slug":"meet-alibaba","date":"2017-06-03T08:53:44.000Z","updated":"2018-09-02T10:12:08.000Z","comments":true,"path":"meet-alibaba.html","link":"","permalink":"http://qinjiangbo.com/meet-alibaba.html","excerpt":"","text":"一晃半个月过去了，发现自己又好几天没写博客了，今天聊一聊博主入职阿里的初印象和感受。阿里巴巴的魅力不仅仅在于它的体量，更在于它的掌舵者和在后面努力奉献的一群可爱的人！阿里巴巴的logo是一个露出自信笑脸的人，我相信每一个阿里人都是自信而快乐的！ 2017.5.27 武汉 -&gt; 杭州2017年5月27号，坐上G584次动车从武汉站出发前往杭州，同行的还有实验室的另一位同学彭小磊。说实话，出发的时候心里面既兴奋又紧张。兴奋的是终于要见到自己向往已久的地方，紧张的是自己怕自己达不到一个合格阿里人的要求—-包括技术和处事。虽说如此，沿途的风景还是非常不错的！ 下午两点左右我们到达了杭州东站，想想上一次来杭州还是和女朋友去乌镇旅游经过呢。忘不了挚友徐游荧带我们去河坊街吃叫花鸡，再次来到这个地方发现变化真的很大。杭州变得更美了，城市的设施也越来越健全。最直观的感受就是公交车大多数都是电动的了（但是我坐的B支5路还是不能刷支付宝QAQ）。对了，主管之前跟我说杭州也挺热的，来了以后我想说，没错，是的！武汉是一个大火炉，杭州也算是个小火炉吧，当天温度还是比较高的。 到酒店安顿好了以后，主管费天让我去公司和大家先见见面。从来没有去过阿里的我只能边查地图边找，嗯，从酒店到滨江园区，步行2.6km，好像不远哈。于是打算步行过去，事实证明，这个决定是错误的！步行太远了，于是我们各自找了辆小黄车骑行到公司。 不知道大家有没有这样的感觉，就是当你要去一个你特别想去的地方时，你会提前查看她所有的资料介绍，你会知道她长什么样，你会知道她的很多详细信息。但是当你真正走近她时，你还是觉得很激动。上一次有这种感觉还是2012年高考被武汉大学录取的时候，当时也是查遍了武大的所有资料，知道她的珞珈山，知道她的奥场，知道她的梅操，但一旦真正靠近她的时候还是会很激动。我总结这个感觉叫“朝圣情怀”。 我们在阿里的入口处领了一张临时通行证，然后站在南门等待主管费天和博善师兄出来接待我们。一见面主管就亲切地叫出了我和小磊的名字，因为之前从来没有见过面，只是之前面试的时候在微信上聊了很多次，所以觉得很熟悉很亲切。主管和师兄都给人一种非常和善亲近的感觉，心中的紧张感减轻了许多。然后进入了阿里的园区里面，园区比我想象的还要大，重点是建筑的设计给人一种很高大上的感觉。 到了我们组，见到了各位师兄，对！我们组都是师兄哈！然后分别打了招呼，每一个师兄都非常热情。然后大家就分别介绍自己的花名和真实名字，然后问了我学校是哪儿的等等。总之，小组的师兄们和主管都非常的和善，这是我对阿里的第一印象。其中有一件事不得不提哈，有点小尴尬，就是今天和各位师兄相互自我介绍了，发现自己在6月1号正式报到入职后给忘了QAQ，教训！看来还是要多和师兄们交流交流！ 2017.5.30 滨江 -&gt; 西湖上午终于找到了一家肯短租房子的房东了，前面两天大家一听说是短租的，就不租给我们了。当然了，也因为我们是整租。后来想了一个策略，为什么我一定要坚持整租呢。那就合租吧，于是就找到了现在租房的地方。就在公司附近的滨兴家园，非常近哦！步行到公司10分钟左右。忙完了租房的事情我们就回酒店休息了。 下午挚友徐游荧来访，他是杭州本地人，自从上次本科毕业以后就没有见过他了。可是一见面就有说不完的话题，我想，这就是我之前说的“最好的友谊，不用刻意地维系”吧？快五点了，我们说，现在外面太阳应该也不大了，出去走一走吧，于是去了西湖。下了公交以后，我们步行去苏堤，道路两旁的树木非常茂密，仿佛置身于森林当中，特别舒服！到了苏堤，我们原本打算是绕着西湖骑行一圈的，但是由于找不到三辆小黄车或者是摩拜单车，遂改为沿着苏堤步行，好好感受西湖的美。 坐在西湖旁的石凳上，傍晚的微风习习，看着垂入水中的翠柳，感觉无比的美好。于是在这美好的情景之中我们就聊起来了，聊了同学们的近况，聊了各自对未来的打算。我们拿出手机拍了几张不错的照片，留下了西湖的魅力时刻！ 不知不觉中，夜幕就降临了，游荧回家还要一段时间，所以我们就先行告别了他。我和小磊就找了两辆小黄车去了一趟河坊街，人还是一如既往的爆满。好吃的东西特别多，推荐大家来杭州旅游一定要去这个地方，尤其是女孩子，一定能大饱口福！ 2017.6.1 阿里巴巴入职6月1号儿童节，选在这一天入职的人还是比较多的，当天应该是有三批安排入职的同学，有的是实习生，有的是应届生，有的是社招生。年龄嘛，最小的估计大三21岁左右，最大的估计40岁左右。都是一些非常优秀的同学，有的从事研发，有的从事无线开发，有的从事测试等等。突然觉得自己有点矫情了，只是能和这么多优秀的人在一起共事，特别有感触罢了。 上午主要是HR和行政MM在给我们讲解阿里巴巴的文化以及需要注意的安全事项。在阿里，没有什么比数据的安全更重要的了！所以，这一点，每一个阿里人都应该牢记！帅气行政GG带着我们逛了一下园区，解答了一直以来困惑我的雕像问题，就是滨江园区里面的蒙古大汉—-站！ 下午主要是IT部门的同事给我们讲解如何配置电脑上的软件，以便于我们能顺利地使用公司内网办公。接着就被安排到了自己的工位上，感谢费斯师兄帮我去搬了一下电脑。入职这几天博善师兄不在的时候（Outing了），费斯师兄很耐心地给我介绍了我们小组目前做的工作，非常直观！我也要加快学习，争取早点能加入到他们的开发当中，并且高质量地完成交给我的任务！ 如果有人问我，在阿里上班是一种什么样的感受，我想借用主管的一句话说：“在这儿工作，就当在网吧一样”。工作的环境很自由轻松，但是每一个人同时又在紧张地完成好自己的任务！ 关于以后在阿里工作生活的点点滴滴，有机会再给大家介绍。😊 遇见阿里遇见阿里，遇见不一样的自己。给自己的寄语就是，希望不断地挑战自己，昨天的最好成绩只是今天的最低标准！还是需要踏踏实实地研习技术，不断地汲取优秀的知识，并且时刻总结自己的技术心得，以便鞭策自己和参考他人。 借用马总的一句话来勉励自己：快乐工作，认真生活！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"阿里巴巴","slug":"阿里巴巴","permalink":"http://qinjiangbo.com/tags/阿里巴巴/"}]},{"title":"Java编程思想之初始化顺序（七）","slug":"think-in-java-order-of-initialization","date":"2017-05-15T11:36:50.000Z","updated":"2017-05-15T12:55:26.000Z","comments":true,"path":"think-in-java-order-of-initialization.html","link":"","permalink":"http://qinjiangbo.com/think-in-java-order-of-initialization.html","excerpt":"","text":"Java面试中经常考查同学们的一个问题就是对象的初始化顺序。本文就重点说一说Java中的类和对象的初始化顺序。 初始化顺序我们都知道，在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。看看下面这个例子👇： 1234567891011121314151617181920212223242526class Window &#123; Window(int marker) &#123; System.out.println(\"Window(\" + marker + \")\"); &#125;&#125;class House &#123; Window w1 = new Window(1); House() &#123; System.out.println(\"House()\"); w3 = new Window(33); &#125; Window w2 = new Window(2); void f() &#123; System.out.println(\"f()\"); &#125; Window w3 = new Window(3);&#125;public class OrderOfInitialization &#123; public static void main(String[] args) &#123; House h = new House(); h.f(); &#125;&#125; 输出结果如下： 123456Window(1)Window(2)Window(3)House()Window(33)f() 从输出的结果大家可以注意到这样一个事实，就是对象w3被初始化了两次。在House类中，故意将几个Window对象的定义散布到各处，以证明它们全部都会在调用构造器或者其他方法之前得到初始化。另外，我们也知道对象w3后来又在构造器内被初始化了。 静态数据的初始化无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型，并且没有对它进行初始化，那么它就会获得基本类型的标准初值；如果它是一个对象引用，那么它的默认初始化值就是null。看看下面这个例子： 123456789101112131415161718192021222324public class LoadingOrder &#123; public static void main(String[] args) &#123; new Parent(13); System.out.println(Parent.age); &#125;&#125;class Parent &#123; static int age; static Child child1 = new Child(1); Child child3 = new Child(3); Parent(int id)&#123; System.out.println(\"Parent(\" + id + \")\"); &#125; static Child child2 = new Child(2);&#125;class Child &#123; Child(int id) &#123; System.out.println(\"Child(\" + id + \")\"); &#125;&#125; 输出结果如下： 12345Child(1)Child(2)Child(3)Parent(13)0 为什么会是这个结果呢？我们可以看到，在Parent类中，我们按照先后顺序定义了age，child1，child3，child2等域。其中child3是非静态域。输出的结果是先输出了Child(1)，然后是Child(2)，接着是Child(3)。注意这儿，这里说明了一个事实，就是静态域的初始化早于非静态域。然后输出Parent(13)，说明非静态域的初始化又早于构造函数。最后一个输出0印证了我们前面说的基本数据类型会取相关的初值。 总结一下对象创建的过程，假设有一个类叫People类： 即使没有显示地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为People的对象时（构造器可以看成是静态方法），或者People类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位People.class文件。 然后载入People.class，这将会在堆中创建一个Class对象，有关静态初始化的所有动作都会被执行。因此，静态初始化只有在Class对象首次加载的时候才会执行一次。 当使用new People()创建对象的时候，首先在堆上为People对象分配足够的存储空间，关于存储空间到底多大，这是根据People类中的数据结构决定的。 这块存储空间会被清零，这就自动地将People对象中的所有基本类型的数据都设置成了默认值（对于数值型的就是0，布尔型为false（底层是0），字符型为0），而引用则被设置为了null。 执行所有出现于字段定义出的初始化动作。 执行构造器。后面与继承结合起来的时候情况更加复杂。 子类父类静态块初始化顺序关于这部分内容，我建议大家移步到我的另一篇博文。static静态代码块，静态变量等加载顺序研究","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qinjiangbo.com/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"http://qinjiangbo.com/tags/编程思想/"}]},{"title":"Linux下使用Nexus搭建Maven私服","slug":"private-maven-repo-with-nexus","date":"2017-05-10T16:27:31.000Z","updated":"2017-05-11T01:12:16.000Z","comments":true,"path":"private-maven-repo-with-nexus.html","link":"","permalink":"http://qinjiangbo.com/private-maven-repo-with-nexus.html","excerpt":"","text":"说明：这是我去年写的一篇文章，一直在印象笔记里存着，这几天整理的时候发现了，觉得还是有不少参考价值的，故重新整理一下发表出来。由于当时直接截的图，所以本文中图片比较多，使用手机流量者慎入，土豪随意。 正文使用Maven也有一段时间了，现在总结几个比较需要注意的地方，以便以后可以更快搭建一个私服。我的当前版本是nexus-2.13.0-01,所以以这个来说明。 （1）设置私服的端口和根路径名称进入目录nexus-2.13.0-01的conf目录，通过vim打开nexus.properties文件如下： 可以看到application-port字段和nexus-webapp-context-path字段，修改它们为所需字段，保存退出。 （2）修改Central的Remote Indexes策略登录主页，默认用户名和密码是admin/admin123看到如下信息，将Download remote indexes设置为True （3）添加自定义的用户名和密码进入左侧菜单Security下的Users子菜单，添加一个用户，这个用户是你自己使用的，拥有超级权限。 然后使用这个账号登录系统，并将默认的admin账号删除。同时将central移到ordered repositories。 （4）Maven配置—-settings文件设置首先配置两个服务器server 其中用户名和密码就是前面说的自定义的用户名和密码，id可以随便填，但是后面在pom中会用到。 （5）Maven配置—-mirrors镜像配置mirrors必须要配置，因为如果不配置的话maven很有可能会直接绕过私服去中心库下载，并且不会将jar包丢到私服，这样我们的私服就没起到作用。所以必须添加一个镜像管理，值得所有的下载都得通过镜像也就是我们的私服。 （6）Maven配置—-profiles配置定义jar库和plugin库的位置，同时还需要确定jdk版本，我的定义的是1.8 别忘了最后有一个激活的操作。 （7）Maven配置—-pom配置这个其实是Maven项目中用来向私服提交jar的一个配置，主要是在项目的deploy操作中起作用。 （8）Gradle配置—-build.gradle配置a）引入以下插件 b）定义任务和jar包版本属性c）发布jar到私服上去 d）确定repository库位置 e）执行gradle tasks查看可用的任务，并且执行gradle install uploadArchives任务将jar上传到私服，否则会报找不到mavenmeta.xml错误。 （9）分别对两个项目工具进行测试，如果下载地址是默认的下载地址则说明配置成功。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://qinjiangbo.com/tags/maven/"},{"name":"私服","slug":"私服","permalink":"http://qinjiangbo.com/tags/私服/"},{"name":"nexus","slug":"nexus","permalink":"http://qinjiangbo.com/tags/nexus/"}]},{"title":"常回家看看","slug":"talk-of-family-and-home","date":"2017-05-02T06:31:55.000Z","updated":"2017-05-09T14:19:30.000Z","comments":true,"path":"talk-of-family-and-home.html","link":"","permalink":"http://qinjiangbo.com/talk-of-family-and-home.html","excerpt":"","text":"五一放假回到家的最大感悟就是：什么都没变，什么都变了！不变的是爷爷奶奶还是一贯的期待我们归来，变化的是他们脸上岁月的痕迹越来越明显。 三月份到四月份一直在忙阿里和腾讯的面试，还有驾驶证科目三和科目四的考试，以至于一不小心都快一个多月没有给家里面回电话了。爷爷是农历四月初三生日，也就是这个月29号生日，我在27号给家里面回了一个电话，提前祝爷爷生日快乐。我想着尽快能在爷爷生日那天赶到家里，而不是第二天回到家里，因为这样意义就减轻了许多。 回到家里，见到了大哥（我们是五堂兄弟），从深圳抽空回来看望爷爷奶奶。见到我们俩都回家了，爷爷奶奶一直都高兴得合不拢嘴。见到爷爷奶奶这么开心，我的心里也很欣慰和开心。回想起自己从小学到大学的这段经历，不免能体会他们心里的感动。从小学到中学15年我都是在他们的身边度过，尤其是我很听话；到了高中去了荆州中学，回家就变成了一件难得的事情，很多时候就靠电话联系着，但是高中也还是有一两个月的暑假可以回家，因此，倒也没那么难得。而上了大学，尤其是现在研究生生涯，一年回家待的时间基本上就可以用天计算了，一整年不超过30天。这也是很多和我经历相似的人的经历吧。 我们忙着在外打拼，在外面追求自己的梦想和自己想要的生活。在外面的我们从不轻易向家里诉说我们的不易和辛苦。一年到头我从来都是报喜不报忧，辛苦和不易自己承担。 老人总是在家等待我们在外面回给家里的电话，他们希望知道我们在外面是否穿暖了，吃饱了，工作是否顺心，而他们关心的内容也永远都是这么的单纯。很多时候，自己感到压力很大的时候，大的连自己都喘不过气了，这个时候，爷爷奶奶的一声问候能让自己极大地化解这些压力。不知道为什么，可能因为这就是家吧。 我有一个不成熟的想法就是，为什么人会想家恋家？那是因为一年到头一直在外拼搏没有机会回家啊，见得少了当然会思念。如果一年四季都在家里待着，我保证99%以上的人都应该没有想家的念头了。为什么？原因各不相同，不同有一个比较通用的解释就是，因为见到家人变得很容易，每天都能见到的人你会用想念来表述吗？我想不会。但现在的现实情况就是，我们很难再回一趟家。从小学一年到头都在爷爷奶奶身边，到现在研究生回家基本看天数算。总之陪在他们身边的日子越来越少，这种感觉很复杂，用现在网络上的一句话说就是很扎心。唯一能做的就是能够在假日的时候多想一想他们，能回家的就尽量回家吧。毕竟，对于我们来说，三天时间，我们也许就是打打游戏过了，逛逛街过了，亦或是邀三俩好友骑行户外。但是，对于家里面的老人，三天，足够他们把这半年的话说给你听，足够他们把这么多天攒的好吃的全拿出来给你吃，足够好好握着你的手听听你讲述自己在外面的种种自豪！ 每次出门，爷爷奶奶都会望着我出发的班车远去，一直到路的尽头。以前觉得只有电视剧里面才会有这种镜头，突然发现，自己一不小心成了电视剧里的主角，顿时泪目。所以，一直跟自己说，一定要在外面好好干，定不负他们的期待！ 最后，时常提醒自己，常回家看看！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"家","slug":"家","permalink":"http://qinjiangbo.com/tags/家/"}]},{"title":"高性能MySQL之锁粒度（二）","slug":"high-performace-mysql-lock","date":"2017-04-18T13:36:37.000Z","updated":"2017-04-19T02:12:39.000Z","comments":true,"path":"high-performace-mysql-lock.html","link":"","permalink":"http://qinjiangbo.com/high-performace-mysql-lock.html","excerpt":"","text":"无论什么时候，只要有多个查询需要同一时刻修改数据，都会产生并发控制问题。关于并发控制的问题，我们将会介绍一个新的概念-锁。我们在多线程编程中会经常使用锁来进行并发控制。那么，MySQL针对并发控制做了哪些努力呢？或者说，MySQL的锁粒度主要是哪几种呢？ 锁粒度一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。为什么这样呢？我们都知道，一旦锁定了，这部分资源相对其他的请求就不可用了，他们必须等待这部分资源被释放以后才能申请使用这部分资源。而在多线程的环境下，假设有上百个线程同时在访问某一张表，如果某一个线程需要修改某一条数据，而它将整张表都锁定了，那么其他的上百个线程都必须等待，这样我们的程序并发性就大大被降低了。如果我们只锁定其中被修改的那行数据，那么我们修改这条数据时将不会影响其它的线程访问它们需要的数据，并发性将会大大提高。也就是说，在任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相应之间不发生冲突即可。 问题是加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁是否已经被释放、释放锁等，都会大大增加系统的开销。如果系统花费了大量的时间来管理锁，而不是存取数据，那么系统的性能将会受到大大地影响。 所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。大多数商业数据库没有提供更多的选择，一般都是在表上施加行级锁，并以各种复杂的方式来实现。 表锁（table lock）表锁是MySQL中最基本的锁策略，并且是开销最小的策略。表锁就是我们前面在锁粒度这里提到的资源访问控制机制：它会锁定整张数据表。一个用户对某一张表进行写操作（更新，插入，删除等）前，一定要先获取这张表的写锁，这个写锁会阻塞其他所有的用户对于这张表的读操作和写操作。只有当没有写锁的时候，其他的用户才能获得这张表的读锁，读锁之间是不会互相阻塞的。 在特定的场景中，表锁也能拥有良好的性能。例如，READ LOCAL表锁支持某些类型的并发写操作。另外，我们也需要知道的一点是，写锁比读锁具有更高的优先级，因此当一个用户向数据表中写入数据的时候，其他所有用户的读操作都必须中断等待。也就是说写锁的请求会被插入到读锁队列的前面，优先执行。 尽管存储引擎可以管理自己的锁，但是MySQL本身还是会使用各种不同的表锁来实现不同的目的。例如，服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。 行级锁（row lock）行级锁可以最大化程度地支持并发处理（同时也带来了最大的锁开销）。众所周知，在InnoDB和XtraDB，以及一些其他的存储引擎汇总实现了行级锁，MyISAM存储引擎中可没有啊，这个很重要！行级锁只在存储引擎层实现，而MySQL服务层没有实现。服务器层完全不了解存储引擎中的锁实现。所有的存储引擎都以自己的方式显式实现了锁机制。 参考文献：《高性能MySQL》","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"MySQL","slug":"数据科学/MySQL","permalink":"http://qinjiangbo.com/categories/数据科学/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://qinjiangbo.com/tags/MySQL/"},{"name":"锁粒度","slug":"锁粒度","permalink":"http://qinjiangbo.com/tags/锁粒度/"}]},{"title":"高性能MySQL之逻辑架构（一）","slug":"high-performance-mysql-architecture","date":"2017-04-18T12:29:13.000Z","updated":"2017-05-14T12:44:59.000Z","comments":true,"path":"high-performance-mysql-architecture.html","link":"","permalink":"http://qinjiangbo.com/high-performance-mysql-architecture.html","excerpt":"","text":"众所周知，MySQL是一款非常优秀的开源数据库，根据最新的DB-Engines(https://db-engines.com/en/ranking)排名来看，MySQL使用量已经跃居第二了。和Oracle以及Microsoft SQL Server一起稳稳地占据着前三名的绝对地位。不过我们也应该关注另一个发展迅猛的数据库就是PostgreSQL，不过在这个系列里面我们就不聊PostgreSQL啦。 如果你能在大脑中勾画出一个MySQL各个组件之间相互协调工作的架构图，那么说明你已经比较了解MySQL的相关机制了，也更加有利于我们去理解MySQL服务器的工作原理。下面是一个MySQL的逻辑架构图。 需要解释一下上面各个组件的作用，可以看到，最上层的服务并不是MySQL所独有的，大多数基于网络的C/S（客户端/服务端）的工具或者服务都有类似的架构。比如连接处理，授权认证，安全等。 第二层架构是MySQL最核心的部分。大多数MySQL的核心功能都在这里实现，比如查询解析、分析、优化、缓存以及所有的内置函数（built-in functions）（比如，日期，时间，数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。 第三层是存储引擎。MySQL的存储引擎有很多，其中最出名的存储引擎有两种：Innodb和MyISAM。存储引擎负责MySQL中数据的存储与提取。和GNU/Linux下面的文件系统一样，每个存储引擎都有它自己的优势和劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎的具体实现上的差异。使得这些差异对于上层的查询是透明的。存储过程API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行数据”等操作。但是存储引擎不回去解析SQL（但是Innodb是一个例外，它会解析外键定义，因为MySQL本身并没有实现这个功能），不同的存储引擎之间也不会相互通信，而只是简单地响应上层的请求。 参考文献：《高性能MySQL》","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"MySQL","slug":"数据科学/MySQL","permalink":"http://qinjiangbo.com/categories/数据科学/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://qinjiangbo.com/tags/MySQL/"},{"name":"逻辑架构","slug":"逻辑架构","permalink":"http://qinjiangbo.com/tags/逻辑架构/"}]},{"title":"Java编程思想之GC与finalize()（六）","slug":"think-in-java-gc-and-finalize","date":"2017-04-15T13:13:47.000Z","updated":"2017-04-15T14:12:26.000Z","comments":true,"path":"think-in-java-gc-and-finalize.html","link":"","permalink":"http://qinjiangbo.com/think-in-java-gc-and-finalize.html","excerpt":"","text":"垃圾回收与终结处理程序员都了解初始化的重要性，但是常常会忘记同样也重要的清理工作。毕竟。谁需要清理一个int呢？但是我们知道把一个对象用完了以后“不管不顾”总是不安全的。因为很容易导致内存泄漏。当然了，你可能会说，我们有Java内存回收器啊。需要说明白的是，Java内存回收器只知道释放哪些由new创建的对象。假如你的代码没有通过new创建对象而是通过别的途径（比如说，调用了JNI本地方法，C++里面通过malloc方法开辟的一片空间）获得一块内存空间，你如何释放？针对这种情况，Java允许在对象中添加一个finalize()方法。 finalize()工作原理一旦垃圾回收器准备好回收某一个对象的时候，它将首先调用这个对象的finalize()方法，并且在下一次执行垃圾回收的动作时才会真正回收对象占用的内存，这里实际上就是说finalize()会做一些垃圾回收前的重要的垃圾清理工作。 析构函数 == finalize()？学过C++的同学都知道C++里面有一个析构函数（C++中销毁对象必须使用这个函数），很多人常常会将finalize()方法类比为Java中的析构函数。这样想对么？这里需要明确地区分一下啊，C++里面，对象一定会被回收；但是在Java中，对象不一定会被回收。或者可以这么说：对象是有可能不被垃圾回收器回收的，垃圾回收并不等于“析构”。 Java中并没有提供“析构函数”或者相似的概念，如果必须执行某些清理前的动作，你必须自己手动地去编写一个执行清理动作的方法。比如（这个例子摘自ThinkingInJava），假设某个对象在创建的时候会将自己绘制在屏幕上，如果不是明确地从屏幕上将其擦除，它可能永远也得不到清理，如果在finalize()里加入某种擦除的功能，当“垃圾回收”发生时（不一定保证会发生），finalize()得到了调用，图像就会被擦除。要是“垃圾回收”没有发生，图像就会一直保存下去。什么时候会发生“垃圾回收”，这个又是另一个话题了，我们在另一篇博客里面会仔细讲解JVM垃圾回收的相关细节，在本文中仅仅介绍一下相关的理论。一般来说，有一个大的原则就是，内存不够用的时候就会发生GC（包括Minor GC 或 Full GC）。 finalize()有何用途我们可能已经有所体会就是，我们不能太相信或者说太依赖finalize()方法了，因为它不一定会发生。这里说一说垃圾回收的目标是什么，那就是内存，垃圾回收只与内存相关。也就是说，使用垃圾回收器的唯一原因就是为了回收程序不再使用的内存。所以对于垃圾回收有关的任何行为来说（尤其是finalize()方法），它们也必须同内存及其回收有关。但这是否意味着要是对象中含有其它对象，finalize()方法就应该明确释放那些呢？不是的，无论这个对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。这个就将finalize()方法的使用先知道了一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。不过，大家也都知道，Java中一切皆为对象，那这种特殊的情况是什么情况呢？ 看来之所以要使用finalize()方法，是因为我们在分配内存的时候可能会使用到类似C语言中的做法，而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下。什么是“本地方法”？“本地方法”是一种在Java程序中使用非Java代码的方式。本地方法目前只支持C和C++，也就是说，我们通过调用C的malloc()方法分配了一块空间，这个空间保存在哪儿呢？在线程栈中。关于线程栈的内容，我们在后面的JMM博客中会给大家仔细介绍。如果我们的Java代码没有及时地释放掉这部分“特殊”的内存空间，很容易会出现内存泄漏的情况。当然啦，free()方法是C和C++中的函数，所以，我们要在finalize()中调用本地方法free()来释放掉这些特殊的内存。 一定要记得清理Java中不允许创建局部对象，必须使用new创建对象。在Java中，也没有用于释放对象的delete，因为垃圾回收器会帮助你释放存储空间。甚至可以很肤浅地认为，正是由于垃圾回收机制的存在，是的Java没有析构函数。然而随着时间的深入，我们就会明白垃圾回收器的存在并不能完全替代析构函数。而且绝对不能直接调用finalize()方法，所以这也不是一种解决的方法。不管是“垃圾回收”还是“终结”，都不一定保证会发生。如果Java虚拟机（JVM）并没有面临内存耗尽的情况，它是不会浪费时间去执行垃圾回收以恢复内存的。要知道，一次stop-the-world会给应用程序带来多大的损失！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qinjiangbo.com/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"http://qinjiangbo.com/tags/编程思想/"}]},{"title":"聊一聊“空杯精神”","slug":"talk-of-empty-cup-spirit","date":"2017-04-11T15:47:29.000Z","updated":"2017-04-26T12:59:48.000Z","comments":true,"path":"talk-of-empty-cup-spirit.html","link":"","permalink":"http://qinjiangbo.com/talk-of-empty-cup-spirit.html","excerpt":"","text":"不久以前看到一个说法，叫“空杯精神”。咋一看没弄明白到底是什么意思，后来一想，其实只不过是换了一种说法而已。在没有看到这个说法之前，我一直都坚持要保持一颗持续学习的心。其实我们都会有一种感觉，那就是，知道的越多，懂得越多，那么我们不知道的也就越多，不懂的也就越多。如何让自己能保持持续学习的态度，就需要我们将自己的角色摆正，客观地评价自己的能力，设定一个更加明确的目标，这样才能知道自己到底需要朝哪方面使力！ 说白了，“空杯精神”要求我们清空自己过去的种种“优势”，以一种全新的心态去接收新鲜的事物。 有时候仔细想想这个说法也倒是挺有道理的，你想啊，一个杯子如果装满了水，它还能再装的了其它的溶液吗？是不可以的，如果我们需要装其它的溶液，势必会先倒了这杯水，然后再装其它的溶液。有人会说了，这个比方不恰当，的确，在实际的生活当中我们并不需要将过去的能力或者知识全部忘掉或者说全部否定掉，这是不合理的，也是不太现实的。我在想，其实这个道理运用到实际的生活中时，我们只需要将心灵空出一部分来，以一个新人的心态去待人，去接物，我觉得就很不错了！ 之前听别人说过一句话，说“一瓶子不满，半瓶子晃荡”，的确是挺有警醒意味的。所谓“一瓶子不满，半瓶子晃荡”就是说稍有一点知识而知识并不丰富，略有一点本领而本领并不高强的人，总是卖弄自己的知识。随着现在知识获取的难度越来越低，很多人享受着快餐式的知识途径，平时没有下足功夫，到了考试临近时抢着搞几天，其实也能过，甚至还能取得一个不错的成绩，那么说明这个人很厉害么？其实不一定！我觉得“半瓶子晃荡”最要命，很多时候觉得自己知道的特别多，然后就开始卖弄所谓的知识，其实更多的是知其然而不知其所以然罢了。 说到这个，其实大伙儿也有过类似的感悟，就是好像跟别人聊起任何话题的时候，好像觉得自己什么都知道，也能讲出一二，但是，也仅仅限于讲出一二。这就是“知识快餐”带来的问题。短期内我们可能都还能记得住这些“快餐”，但是，毕竟是“快餐”，不是“正餐”，所以用不了多久就会被遗忘掉。 聊聊我的情况，本科的时候，我自己就存在这样的毛病，不太喜欢看书，喜欢从网上找各种各样的技术博客去看，去学习，但是并没有巩固下来，而是将其作为一种快餐，导致后面很多时候别人说什么自己好像都知道，可是心里却觉得比较虚。尤其是有一次和同事们讨论一个“http是有状态还是无状态，以及jsessionid是什么”的问题时，就暴露出了自己的问题。的确，之前是看到过关于http有状态无状态的文章，但是印象不深，不牢固，久而久之就忘了。于是，后来就开始思考是否其他方面也存在这样那样的问题。的确，是应该换一种思路了。所以，前年（15年）12月就开始以小白的心态重新认识这个世界，“Hello World”。从系统地听慕课上的教程到系统地学习一本又一本的书籍，发现很多知识活了，原本零碎的知识被串起来了。当然了，现在距离我自己的目标还是有一段距离，毕竟还有很多地方需要继续深入研究，不过，心态调整好之后这就 只是时间的问题了。 我不知道大家有没有经常想过这个问题，就是自己到底处于一个什么样的阶段？能不能客观真实地评价自己？这是一个问题，而且是一个大问题。感觉我们好像很容易被生活中的各种杂碎的事情给搅乱了，一会儿这个事情，一会儿那个事情。所以我说啊，珍惜在学校的学习的时间，虽然可能也会比较忙，但是相比工作后的时间，好多了！当然其实工作了也是可以持续学习的，我在公司实习的一年多，回家一样坚持学习，写代码（可能那时还是一个学生的心态吧！）。同事觉得我有点奇葩，其实这也不奇怪，因为我一个人住，晚上8，9点回家也没事干，所以就写写代码咯。他们家里有老婆孩子，要陪陪家人，所以很多时候没时间学习也很正常。但从长远看，还是得抽出一部分时间学习新的知识。 好啦，我最后再说说我对空杯精神的理解吧，除了上面说的问题以外，我觉得，“空杯精神”也是一种品质上的修养，因为它会让人保持一种谦逊的态度，而这种谦逊的态度会让我们受益终身。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"空杯精神","slug":"空杯精神","permalink":"http://qinjiangbo.com/tags/空杯精神/"}]},{"title":"设计模式学习之状态模式","slug":"design-pattern-state","date":"2017-04-09T07:39:53.000Z","updated":"2017-04-09T09:19:23.000Z","comments":true,"path":"design-pattern-state.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-state.html","excerpt":"","text":"什么是状态模式状态模式(State Design Pattern)允许对象在内部状态改变的时候改变它的行为，对象看起来好像修改了它的类。 说明在状态模式中，我们会创建表示各种状态的对象和一个行为随着状态对象变化而改变的Context对象。 状态模式类图 下面具体介绍介绍各个类的作用： Context是我们前面说的一个上下文类，它拥有一些内部状态（state）。在类图中，只要有人调用Context类的request()方法，它就会被委托到state的handle()方法中来处理。 State接口定义了一个所有具体状态的共同接口，任何状态都会实现这个相同的接口，这样一来，各个状态之间就可以相互替换。 ConcreteState具体状态类处理来自Context类的请求。每一个ConcreteState都提供了自己对于这个请求的具体实现。所以，当Context状态改变的时候，它的行为也一定会跟着改变。 实例分析-ATM取钱我们假设有一台ATM机摆在我们面前，这个ATM的功能非常简单，就是取钱！不过呢，为了使代码更加简化，便于我们的模式的学习，我将这个ATM机的功能简化了，每次只能取1000整数。而且不能存款。先说明需要使用到的几个类： ATM类，这个类就是我们上面分析的Context上下文类，它里面保存了一个State状态类实例，这个实例会根据数据库（DB）余额的大小动态地发生变化。 DB类，这里主要是模拟数据库请求。在状态类中执行相关的操作的时候就会直接和数据库类DB发生关联。 State接口是所有状态类的接口，它有两个具体实现类SufficientState和DefficientState类。分别表示数据库余额充足和余额不足的情况。 Client客户类是我们的一个测试类。 代码实现ATM.java（Context） 1234567891011121314151617181920/** * @date: 09/04/2017 4:28 PM * @author: qinjiangbo@github.io */public class ATM &#123; private State state; public ATM() &#123; state = new SufficientState(this); &#125; public void withdraw() &#123; state.handle(); &#125; public void setState(State state) &#123; this.state = state; &#125;&#125; DB.java 1234567891011121314151617/** * @date: 09/04/2017 4:52 PM * @author: qinjiangbo@github.io */public class DB &#123; private static int total = 10000; public static int take(int num) &#123; total = total - num; return total; &#125; public static int query() &#123; return total; &#125;&#125; State.java 1234567/** * @date: 09/04/2017 4:32 PM * @author: qinjiangbo@github.io */public interface State &#123; void handle();&#125; SufficientState.java 1234567891011121314151617181920/** * @date: 09/04/2017 4:36 PM * @author: qinjiangbo@github.io */public class SufficientState implements State &#123; private ATM atm; public SufficientState(ATM atm) &#123; this.atm = atm; &#125; @Override public void handle() &#123; int count = DB.take(1000); if (count == 0) &#123; atm.setState(new DefficientState(atm)); &#125; System.out.println(\"$1000 HAVE BEEN TAKEN!\"); &#125;&#125; DefficientState.java 12345678910111213141516171819202122/** * @date: 09/04/2017 4:37 PM * @author: qinjiangbo@github.io */public class DefficientState implements State &#123; private ATM atm; public DefficientState(ATM atm) &#123; this.atm = atm; &#125; @Override public void handle() &#123; if (DB.query() &gt; 0) &#123; DB.take(1000); atm.setState(new SufficientState(atm)); System.out.println(\"$1000 HAVE BEEN TAKEN!\"); &#125; else &#123; System.out.println(\"NOT SUFFICIENT IS AVAILABLE!\"); &#125; &#125;&#125; 测试12345678910111213/** * @date: 09/04/2017 4:57 PM * @author: qinjiangbo@github.io */public class Client &#123; public static void main(String[] args) &#123; ATM atm = new ATM(); // 模拟11次取款行为，每次1000 for (int i = 0; i &lt; 11; i++) &#123; atm.withdraw(); &#125; &#125;&#125; 结果1234567891011$1000 HAVE BEEN TAKEN!$1000 HAVE BEEN TAKEN!$1000 HAVE BEEN TAKEN!$1000 HAVE BEEN TAKEN!$1000 HAVE BEEN TAKEN!$1000 HAVE BEEN TAKEN!$1000 HAVE BEEN TAKEN!$1000 HAVE BEEN TAKEN!$1000 HAVE BEEN TAKEN!$1000 HAVE BEEN TAKEN!NOT SUFFICIENT IS AVAILABLE! 可以看到，在取了atm.withdraw()10次钱之后，银行数据库的钱已经别取光了。因此，在第11次去取的时候提示没有钱可以取了。 总结这里说说使用状态模式的优点和缺点： 优点 封装了状态转换规则 枚举可能的状态，在枚举所有的状态之前需要确定有多少种状态 外面的客户端不会感受到内部发生的变化 缺点 状态对象会导致系统的对象数量增多 不利于拓展，因为添加一个新的状态类可能会修改大量的相关类。 总的来说，我们要分特定的场合使用特定的设计模式，具体情况具体分析才是最重要的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"状态模式","slug":"状态模式","permalink":"http://qinjiangbo.com/tags/状态模式/"}]},{"title":"Java编程思想之this关键字（五）","slug":"think-in-java-this-keyword","date":"2017-04-06T13:41:27.000Z","updated":"2017-04-06T14:45:10.000Z","comments":true,"path":"think-in-java-this-keyword.html","link":"","permalink":"http://qinjiangbo.com/think-in-java-this-keyword.html","excerpt":"","text":"大家可能都知道this关键字，而且平时在工作中也用的非常多，那么你是真正知道this关键字的作用吗？如果一个类有两个实例a和b，那么你可能想知道如何让这两个实例都能调用work()方法呢？ 12345678910class Person &#123; void work()&#123; /** something **/ &#125; &#125;public class PersonWorker &#123; public static void main(String[] args) &#123; Person a = new Person(), b = new Person(); a.work(); b.work(); &#125;&#125; 我想问的是Person类的work()方法是如何知道是哪个对象调用的呢？ this其实是这样的，在Person类编译好了以后，我们在Person.class的字节码文件中其实可以发现这个问题的答案，执行javap -v Person我们可以得到如下输出： 1234567891011121314151617181920212223242526272829303132333435363738394041424344Classfile /Users/Richard/Downloads/Person.class Last modified Apr 6, 2017; size 232 bytes MD5 checksum 16d028d92ca1e1c36e9bf640a35c6f1a Compiled from \"Person.java\"public class Person minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #3.#11 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Class #12 // Person #3 = Class #13 // java/lang/Object #4 = Utf8 &lt;init&gt; #5 = Utf8 ()V #6 = Utf8 Code #7 = Utf8 LineNumberTable #8 = Utf8 work #9 = Utf8 SourceFile #10 = Utf8 Person.java #11 = NameAndType #4:#5 // \"&lt;init&gt;\":()V #12 = Utf8 Person #13 = Utf8 java/lang/Object&#123; public Person(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 1: 0 void work(); descriptor: ()V flags: Code: stack=0, locals=1, args_size=1 // 直接看到这一行 0: return LineNumberTable: line 4: 0&#125;SourceFile: \"Person.java\" 我们可以看到，在wok()方法里面多了一个局部变量locals=1，那么这个局部变量到底是啥呢？好吧，不卖关子了，就是我们当前实例对象的一个引用，不过我们在Java源码中并不能直接看到这个引用，那么我们如何获取它呢？this关键字！ this关键字还有很多很好玩的使用场景，比如说我们可以很优雅地实现类似于StringBuffer中的append(s)方法： 123456789101112public class StringBaba &#123; String s = \"\"; public StringBaba append(String ss) &#123; s = s + ss; // 这种实现有点不靠谱，这里仅供参考 return this; &#125; public static void main(String[] args) &#123; StringBaba baba = new StringBaba(); baba.append(\"hello\").append(\"world\").append(\"java\"); &#125;&#125; 构造器中使用this我们很多时候都不会再构造器中使用this关键字，但是万一要用到了呢？我们必须知道如何去处理这种情况。通常情况，我们使用this关键字都是表示当前对象或者这个对象，但是如果我们为this关键字添加了一些参数列表，那么这个时候就会有很明显的区别了。 1234567891011121314151617public class Tower&#123; int height; String name; Tower(int height) &#123; this.height = height; &#125; Tower(String name) &#123; this.name = name; &#125; Tower(String name, int height) &#123; this(name); this.height = height; &#125;&#125; 看到了我上面的用法了吗？这个时候this(name)一定指的是带字符串参数的那个构造函数，而且需要注意的是this调用的构造函数必须置于最起始处，否则会报错，编译不通过。 注意平时我们在构造函数里面赋值的时候我建议大家多使用this.name=name这种形式，因为this.name能将name区分开，而且语义也很清晰。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qinjiangbo.com/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"http://qinjiangbo.com/tags/编程思想/"}]},{"title":"设计模式学习之组合模式","slug":"design-pattern-composition","date":"2017-04-06T08:07:09.000Z","updated":"2017-04-06T09:20:10.000Z","comments":true,"path":"design-pattern-composition.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-composition.html","excerpt":"","text":"什么是组合模式组合模式(Composite Design Pattern)允许你将对象组合成树形的结构来表示整体-部分的层级结构。组合模式允许客户类统一对待每一个独立的对象。 组合模式类图我们先看看组合模式的类图。 先说说Client客户类，Client客户类利用Component接口来操作这个组合结构里面的对象。 Component接口定义了这个组合结构里面的所有对象的一个接口，包括组合对象和叶子结点。它定义了四个方法：operation()，add(Component)，remove(Component)以及getChild(int)。这四个方法分别对应了相应的操作方法，添加组合对象，移除组合对象以及获取第几个孩子节点。 Composite类实现了Component接口，组合对象实现了Component接口定义的四个方法，但是需要注意的一点就是，组合对象里面可能也实现了叶子结点的相关操作，但是这些操作对于组合对象来说是毫无意义的，所以我们在这些方法里面直接抛出了异常或者做了简单的处理。 Leaf类是叶子结点类，它也实现了Component接口相关的方法，但是我们从这个类图里面可以看到，它只实现了operation()方法，这个方法是为了能和组合对象的操作相兼容而实现的。注意，Leaf类并没有相应的孩子节点，它本身就是一个孩子结点。其它的几个方法add()，remove()以及getChild()都不需要实现，因为它根本不支持这些操作。一般的做法就是实现一些钩子（Hook）类来模拟这些操作。但实际上这些钩子中的操作是不会产生实际的作用的。 实例分析-员工管理我们现在需要打印一个企业所有部门的所有员工信息，这个时候我们可以使用组合模式方式来实现相关的操作。首先需要明确一个问题就是员工接口如何设计： Employee员工类接口，则例说明一下，我们使用抽象类来表示这个员工里面的方法有： add(Employee e) remove(Employee e) getEmployees() work() 客户类这里也就使我们的测试类啦，见下面的源码实现。 代码实现Employee.java 123456789101112131415161718192021222324public abstract class Employee &#123; String name; String title; int deptId; List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(); Employee(String name, String title, int deptId) &#123; this.name = name; this.title = title; this.deptId = deptId; &#125; abstract void add(Employee e); abstract void remove(Employee e); void work()&#123; System.out.println(this.name + \"-\" + this.title + \"-\" + this.deptId); &#125; abstract List&lt;Employee&gt; getEmployees();&#125; Manager.java 1234567891011121314151617181920212223242526public class Manager extends Employee &#123; public Manager(String name, String title, int deptId) &#123; super(name, title, deptId); &#125; @Override void add(Employee e) &#123; employees.add(e); &#125; @Override void remove(Employee e) &#123; employees.remove(e); &#125; @Override void work() &#123; System.out.println(\"I am working as manager...\"); &#125; @Override List&lt;Employee&gt; getEmployees() &#123; return employees; &#125;&#125; Staff.java 1234567891011121314151617181920212223242526public class Staff extends Employee&#123; public Staff(String name, String title, int deptId) &#123; super(name, title, deptId); &#125; @Override void add(Employee e) &#123; throw new UnsupportedOperationException(); &#125; @Override void remove(Employee e) &#123; throw new UnsupportedOperationException(); &#125; @Override void work() &#123; System.out.println(\"I am working as staff...\"); &#125; @Override List&lt;Employee&gt; getEmployees() &#123; return new ArrayList&lt;&gt;(); &#125;&#125; Client.java 12345678910111213141516171819202122232425262728public class Client &#123; public static void main(String[] args) &#123; Employee CEO = new Manager(\"Richard\", \"CEO\", 1); Employee dev1 = new Staff(\"Lilei\", \"Java\", 1); Employee dev2 = new Staff(\"Leon\", \"Php\", 1); Employee COO = new Manager(\"Amy\", \"COO\", 2); Employee ops1 = new Staff(\"XiXi\", \"Linux\", 2); Employee ops2 = new Staff(\"TiTi\", \"UNIX\", 2); CEO.add(dev1); CEO.add(dev2); CEO.add(COO); COO.add(ops1); COO.add(ops2); for (Employee e: CEO.getEmployees()) &#123; e.work(); for (Employee ee: e.getEmployees()) &#123; ee.work(); &#125; &#125; &#125;&#125; 测试结果CEO管辖下面的员工信息： 12345Lilei-Java-1Leon-Php-1Amy-COO-2XiXi-Linux-2TiTi-UNIX-2 总结它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。常见的应用场景比如我们的文件管理系统，目录和文件其实是作为一个统一的对象处理的。还有，大型软件里面的复杂的树形菜单，也是采用这种设计模式进行构架的。大家应该自己多看看相关的资料，熟悉熟悉组合模式的使用场景，以便日后在自己的项目当中可以用上派场。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"组合模式","slug":"组合模式","permalink":"http://qinjiangbo.com/tags/组合模式/"}]},{"title":"设计模式学习之迭代子模式","slug":"design-pattern-iteration","date":"2017-04-06T04:53:19.000Z","updated":"2017-04-06T08:04:57.000Z","comments":true,"path":"design-pattern-iteration.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-iteration.html","excerpt":"","text":"什么是迭代子模式迭代子模式(Iterator Design Pattern)提供了一种顺序访问聚合对象中的元素但是又不暴露它的底层实现的方式。 简单补充迭代子模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。大家肯定都使用过迭代器去遍历一个集合中的元素吧？比如像下面这样遍历链表： 12345List&lt;Integer&gt; list = new ArrayList&lt;&gt;();Iterator iterator = list.iterator();while(iterator.hasNext()) &#123; // do something&#125; 我们并不知道这个迭代器是如何遍历这个链表的，但是它就做到了，那么本文就来聊聊如何实现这个迭代器。 迭代子模式类图我们先看看迭代子模式的类图： 我们先看Client客户类，客户类没啥存在感，算了不说它了，换一个。 看看Aggregate接口，这是一个聚合对象接口。它提供了一个通用的聚合对象接口，将你的客户类和聚合对象底层的实现分离开了。 ConcreteAggregate类是Aggregate接口的具体实现类。我们可以看到，里面具有一个createIterator()方法，这个方法会创造一个Iterator对象。然后通过这个对象遍历聚合对象的各个元素。 Iterator接口是一个迭代器接口，它定义了三个方法：hasNext()，next()以及remove()。这三个方法非常的重要，第一个方法hasNext()会判断还有没有下一个元素，避免迭代器遍历越界。第二个方法next()会返回下一个将要遍历的元素。第三个方法remove()会移除当前遍历的元素。通过这三个方法，我们能够对集合做一些基本的操作。这里本文使用的是java.util.Iterator，也就是JDK中的Iterator接口，如果你不想用，也可以自己实现。 ConcreteIterator类是Iterator接口的具体实现类，它在ConcreteAggregate类里面被引用。作为createIterator()方法的返回值。 实例分析-厨师菜单假设我们现在有一个需求就是有两个厨师使用了不同的方式来实现了一个菜单，这个菜单包含很多不同的菜名，一个用的是数组元素（ArrayList），一个用的是哈希表元素（HashTable）。我们分别将这两个命名为DinerMenu和PancakeMenu。根据我们的迭代子设计模式类图，我们知道，他们都必须实现一个聚合类，那我们就定义这个接口为Menu吧。接下来为这两种不同的实现分别定义他们各自的遍历迭代器。 代码实现Menu.java 123public interface Menu &#123; Iterator createMenuIterator();&#125; MenuItem.java 1234567891011121314151617public class MenuItem &#123; private String name; private String description; private boolean vegetarian; private double price; public MenuItem(String name, String description, boolean vegetarian, double price) &#123; this.name = name; this.description = description; this.vegetarian = vegetarian; this.price = price; &#125; // set methods&#125; PancakeMenu.java 12345678910111213141516171819202122232425262728293031323334353637383940public class PancakeMenu implements Menu &#123; ArrayList menuItems; public PancakeMenu() &#123; menuItems = new ArrayList(); addItem(\"K&amp;B's Pancake Breakfast\", \"Pancakes with scrambled eggs, and toast\", true, 2.99); addItem(\"Regular Pancake Breakfast\", \"Pancakes with fried eggs, sausage\", false, 2.99); addItem(\"Blueberry Pancake\", \"Pancakes made with fresh blueberries\", true, 3.49); addItem(\"Waffles\", \"Waffles, with your choices of blueberries or strawberries\", true, 3.59); &#125; public void addItem(String name, String description, boolean vegetarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegetarian, price); menuItems.add(menuItem); &#125; @Override public Iterator createMenuIterator() &#123; return new PancakeMenuIterator(menuItems); &#125;&#125; DinerMenu.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class DinerMenu implements Menu &#123; private static final int MAX_SIZE = 6; private int numberOfItems = 0; private MenuItem[] menuItems; public DinerMenu() &#123; menuItems = new MenuItem[MAX_SIZE]; addItem(\"Vegetarian BLT\", \"(Fakin) Bacon with lettuce &amp; tomato on the whole wheat\", true, 2.99); addItem(\"BLT\", \"Bacon with lettuce &amp; tomato on the whole wheat\", false, 2.99); addItem(\"Soup of the day\", \"Soup of the day, with a side of potato salad\", false, 3.29); addItem(\"Hotdog\", \"A hot dog\", false, 3.05); &#125; public void addItem(String name, String description, boolean vegetarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegetarian, price); if (numberOfItems &gt;= MAX_SIZE) &#123; System.err.println(\"Sorry, menu is full! Can't add items!\"); &#125; else &#123; menuItems[numberOfItems++] = menuItem; &#125; &#125; @Override public Iterator createMenuIterator() &#123; return new DinerMenuIterator(menuItems); &#125;&#125; 接下来定义相关的迭代器类： PancakeMenuIterator.java 123456789101112131415161718192021public class PancakeMenuIterator implements Iterator &#123; ArrayList menuItems; int position = 0; public PancakeMenuIterator(ArrayList menuItems) &#123; this.menuItems = menuItems; &#125; @Override public boolean hasNext() &#123; return position &lt; menuItems.size() &amp;&amp; menuItems.get(position) != null; &#125; @Override public Object next() &#123; MenuItem menuItem = (MenuItem) menuItems.get(position++); return menuItem; &#125;&#125; DinerMenuIterator.java 1234567891011121314151617181920212223242526272829303132333435public class DinerMenuIterator implements Iterator &#123; MenuItem[] menuItems; int position = 0; public DinerMenuIterator(MenuItem[] menuItems) &#123; this.menuItems = menuItems; &#125; @Override public boolean hasNext() &#123; return position &lt; menuItems.length &amp;&amp; menuItems[position] != null; &#125; @Override public Object next() &#123; MenuItem menuItem = menuItems[position++]; return menuItem; &#125; @Override public void remove() &#123; if (position &lt;= 0) &#123; throw new IllegalStateException (\"you can' remove an item until you've done at least one next()!\"); &#125; if (menuItems[position - 1] != null) &#123; for (int i = position - 1; i &lt; (menuItems.length - 1); i++) &#123; menuItems[i] = menuItems[i + 1]; &#125; menuItems[menuItems.length - 1] = null; &#125; &#125;&#125; 测试代码Waitress.java 1234567891011121314151617181920212223242526272829303132public class Waitress &#123; DinerMenu dinerMenu; PancakeMenu pancakeMenu; CafeMenu cafeMenu; public Waitress(DinerMenu dinerMenu, PancakeMenu pancakeMenu) &#123; this.dinerMenu = dinerMenu; this.pancakeMenu = pancakeMenu; &#125; public void printMenu() &#123; DinerMenuIterator dinerMenuIterator = (DinerMenuIterator) dinerMenu.createMenuIterator(); Iterator pancakeMenuIterator = pancakeMenu.createMenuIterator(); System.out.println(\"MENU\\n----\\nBREAKFAST\"); printMenu(dinerMenuIterator); System.out.println(\"\\nDINER\"); printMenu(pancakeMenuIterator); &#125; private void printMenu(Iterator iterator) &#123; while (iterator.hasNext()) &#123; MenuItem menuItem = (MenuItem) iterator.next(); System.out.print(menuItem.getName() + \", \"); System.out.print(menuItem.getDescription() + \" -- \"); System.out.println(menuItem.getPrice()); &#125; &#125;&#125; MenuTest.java 12345678public class MenuTest &#123; public static void main(String[] args) &#123; DinerMenu dinerMenu = new DinerMenu(); PancakeMenu pancakeMenu = new PancakeMenu(); Waitress waitress = new Waitress(dinerMenu, pancakeMenu); waitress.printMenu(); &#125;&#125; 总结说说JAVA中的iterator应用。JAVA中的java.util.Iterator接口为我们提供了很多默认方法的实现，为我们实现迭代子模式带来了巨大的便利。我们来看看迭代子模式有哪些优点和缺点： 优点 它支持以不同的方式遍历一个聚合对象。 迭代器简化了聚合类。 在同一个聚合上可以有多个遍历。 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 缺点由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"迭代子模式","slug":"迭代子模式","permalink":"http://qinjiangbo.com/tags/迭代子模式/"}]},{"title":"设计模式学习之外观模式","slug":"design-pattern-facade","date":"2017-04-01T05:47:24.000Z","updated":"2017-04-01T07:12:14.000Z","comments":true,"path":"design-pattern-facade.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-facade.html","excerpt":"","text":"什么是外观模式外观模式(Facade Design Pattern)提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。 外观模式类图 可以看到，这个设计模式非常的简单，简单到我们可以一眼就知道它的功能。不过我们还是来分析一下这个图中各个类的具体含义。 先说说Client类，这个是客户类，因为有了外观，客户的工作更加容易了，它不需要挨个挨个去调用系统中的各个元件的功能，只需要调用外观中封装好的功能即可。 再说说我们的核心类Facade，这个是外观类，它负责将子系统中的各个功能通过一个统一的方法封装起来，提供给客户类调用，简化客户类的工作。子系统当然是非常复杂的，我们这里就不讨论子系统的具体实现了。 实例分析-家庭影院假设你想搭建一个家庭影院，希望在家里也能感受到电影院般的氛围。那么你需要准备好多东西： 爆米花🍿 灯光 投影仪 DVD 功放 假设就这五个吧。那你需要如何才能开始准备好呢，我想应该是这样的： 打开爆米花机 开始爆米花 调暗灯光有氛围 打开投影仪 打开功放 打开DVD播放器 开始播放DVD 累不累啊！这么多手续，其实我们只是想放个电影而已，而这些都是一些流程化手续，能不能不要我们手动去做啊，直接一键完成不就OK了吗？那么我们来看看如何一键完成。 代码实现这里说明一下，这里只列出Facade这个主要的类，子系统的类太多，它们的具体实现就不一一列出来了。 OneKeyButton 12345678910111213141516171819202122232425262728293031323334public class OneKeyButton &#123; private Popper popper; private Light light; private Projector projector; // 投影仪 private DvdPlayer dvdPlayer; private Tunner tunner; public OneKeyButton(Popper popper, Light light, Projector projector, DvdPlayer dvdPlayer, Tunner tunner) &#123; this.popper = popper; this.light = light; this.projector = projector; this.dvdPlayer = dvdPlayer; this.tunner = tunner; &#125; public void watchMovie(String movieName) &#123; popper.on(); popper.pop(); light.dim(10); projector.scrollDown(); tunner.on(); dvdPlayer.play(movieName); tunner.volumeUp(40); &#125; public void endMovie() &#123; popper.off(); light.light(10); projector.scrollUp(); tunner.off(); dvdPlayer.off(); &#125;&#125; 大家看看是不是简洁多了！我们Client客户类调用的时候只需要调用watchMovie()和endMovie()这两个方法即可，无需关心里面具体是如何实现的。是不是很Nice？这里需要给大家介绍一种设计模式中的原则之一最少知识原则，也叫迪米特法则。 最少知识原则（迪米特法则）什么是最少知识原则？最少知识原则告诉我们要减少对象之间的交互，只留下几个“密友”，也就是说只和他自己的“密友”交谈。 究竟我们才能如何不要赢得太多的朋友和影响太多的对象？这个原则提供了一些方针： 该对象本身 被当做方法的参数而传递进来的对象 此方法所创建或者实例化的任何对象 对象的任何组件（HAS-A关系） 到底是啥嘛！我们来举个栗子🌰！ 不采用这个原则：1234public float getTemp() &#123; Thermometer thermometer = station.getThermometer(); return thermometer.getTemperature();&#125; 采用这个原则：123public float getTemp() &#123; return station.getTemperature();&#125; 大家明白区别了吗？前面一个通过station获取了Thermometer对象，然后通过Thermometer对象来间接获取温度信息。但问题是，我们需要知道Thermometer对象吗？？？不需要！！！所以，我们直接在station里面封装这个方法就行了。这样更简洁，更利于代码的维护和拓展。 总结虽然外观模式比较简单，但是从这个模式里体现出来的最少知识原则却是我们应该注意的，这个原则提醒我们要时刻保证各个对象之间的耦合性，不要让一个对象过多地知道与它无关的对象的信息。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"外观模式","slug":"外观模式","permalink":"http://qinjiangbo.com/tags/外观模式/"}]},{"title":"设计模式学习之适配器模式","slug":"design-pattern-adapter","date":"2017-04-01T03:01:46.000Z","updated":"2017-04-01T05:45:31.000Z","comments":true,"path":"design-pattern-adapter.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-adapter.html","excerpt":"","text":"什么是适配器模式适配器模式(Adapter Design Pattern)将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。 将圆假装成正方形我们知道适配器模式的作用就是将一个类的接口进行转换，以适应客户的要求。那我们现在有一个圆，如何将一个圆假装成正方形呢？咋一看没什么头绪，但是学习完本文以后你就知道如何操作了。 适配器模式类图 先说说Client类，这个类比较简单，就是一个客户类，这个客户类只能看到目标接口，他并不知道这个接口背后到底是什么东西。但是只要客户类认为是他想要的东西就可以了。 再说说Target接口，这个接口是所有适配器实现的目标接口。它定义了一个适配器的一些基本功能。 关于Adapter类，它主要是实现了Target类，里面的request()方法则是它包含的具体的操作了。这个方法里面具体如何实现取决于它是否包含被适配类Adaptee。 Adaptee很明显是一个被适配类，这类我们采用组合的方式将适配类和被适配类组合起来完成相应的适配工作。Adaptee里面的specificRequest()方法其实是在Adapter里面的request()中完成调用的。 实例分析-伪装成鸭子之前看廖雪峰老师的官方博客的时候就看到了一句话如果一件事看起来像某个东西，那么系统就可以认为它就是这个东西。当时没看太明白，但是现在相信大家伙都能明白说的是什么了。这句话其实是在他的Python教程里面说的，说的是如果一个对象具有read和write等方法，那么我们完全可以把它当做是文件来看待。那我们这里的这个实例其实就可以说成如果一个小动物走起路来并且叫起来像鸭子，那我们认为它就是一只鸭子。 目标接口-Duck我们这里使用Duck接口作为我们的目标接口。这个接口中我们先定义两个行为： quack()这个方法就是呱呱叫啦！ fly()鸭子会飞吗？应该会吧！哈哈！ 适配类-TurkeyAdapter这个没什么要说的，这个类实现了前面的目标接口，所以上面提到的两个方法它都必须实现，但是至于具体怎么实现，还不太清楚。我们也知道适配类和被适配类是通过组合的方式来进行功能的包装的，那么是如何组装的呢？看这个方法：Duck duck = new TurkeyAdapter(new Adaptee);，通过在构造函数里面传递这个被适配类的实例来实现功能的包装。 被适配类-Turkey火鸡🦃！火鸡和鸭子有一点相似的地方就是它们都是禽类。那我们来看一看火鸡有哪些行为呢？ gobble()这个方法就是咯咯叫啦！ fly()火鸡也会飞，但是飞不远。 具体实现类Duck接口的具体实现类我们选一个，那就MallardDuck绿头鸭呗！Turkey接口的具体实现类我们也得有一个，选啥呢，那就WildTurkey野火鸡呗！ 实例代码实现Duck 1234public interface Duck &#123; public void quack(); public void fly();&#125; MallardDuck 123456789101112public class MallardDuck implements Duck &#123; @Override public void quack() &#123; System.out.println(\"Quack\"); &#125; @Override public void fly() &#123; System.out.println(\"I'm flying\"); &#125;&#125; Turkey 1234public interface Turkey &#123; public void gobble(); public void fly();&#125; WildTurkey 123456789101112public class WildTurkey implements Turkey &#123; @Override public void gobble() &#123; System.out.println(\"Goggle goggle\"); &#125; @Override public void fly() &#123; System.out.println(\"I'm flying a short distance\"); &#125;&#125; TurkeyAdapter 1234567891011121314151617181920public class TurkeyAdapter implements Duck &#123; Turkey turkey; public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; @Override public void quack() &#123; turkey.gobble(); &#125; @Override public void fly() &#123; for (int i = 0; i &lt; 5; i++) &#123; turkey.fly(); &#125; &#125;&#125; 好，开工测试一下，写一个客户端类： 12345678910111213141516171819202122232425public class Client &#123; public static void main(String[] args) &#123; Duck mallardDuck = new MallardDuck(); Turkey wildTurkey = new WildTurkey(); Duck turkeyAdapter = new TurkeyAdapter(wildTurkey); System.out.println(\"The turkey says...\"); wildTurkey.gobble(); wildTurkey.fly(); System.out.println(); System.out.println(\"The duck says...\"); mallardDuck.quack(); mallardDuck.fly(); System.out.println(); System.out.println(\"The turkey adapter says...\"); turkeyAdapter.quack(); turkeyAdapter.fly(); &#125;&#125; 测试结果123456789101112131415The turkey says...Goggle goggleI'm flying a short distanceThe duck says...QuackI'm flyingThe turkey adapter says...Goggle goggleI'm flying a short distanceI'm flying a short distanceI'm flying a short distanceI'm flying a short distanceI'm flying a short distance 总结关于适配器模式的例子在我们的生活中还有很多，比如说我们的充电器适配器。苹果的充电器适配器不仅能连接iPhone 7还能连iPad Pro等等。说明他们的接口首先是一致，另外这个适配器也做了相应的适配处理。适配器模式让我们将两个不同的对象通过巧妙地组合密切地联系在了一起。组合的方式更灵活，更利于系统的拓展。不建议大家使用继承去拓展功能！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"适配器模式","slug":"适配器模式","permalink":"http://qinjiangbo.com/tags/适配器模式/"},{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"}]},{"title":"细说Java8之新增API下","slug":"java8-new-interfaces-2","date":"2017-03-30T16:19:19.000Z","updated":"2017-09-02T15:07:55.000Z","comments":true,"path":"java8-new-interfaces-2.html","link":"","permalink":"http://qinjiangbo.com/java8-new-interfaces-2.html","excerpt":"","text":"Streams流这里不得不说一下Java8中新出来的一个神器java.util.Stream。那么java.util.Stream是什么呢？我们说java.util.Stream表示一个可以对其中的元素进行一项或多项操作的序列。具体是什么呢？我们先说说这些操作可以是什么？这些操作可以是直接取得结果的，也可以只作为某一个中间过程。比如说针对list或者是set，这些Stream操作可以每次只对其中一个或者两个元素进行操作，作为中间过程保存；也可以针对全部的元素进行相关的操作。Stream操作可以串行执行也可以并行执行。 串行执行流我们先看看串行执行的流操作是什么？首先创建一个数据源： 1234567891011// 类似Guava中快速构造一个集合public &lt;T&gt; List&lt;T&gt; addElements(T... elements) &#123; List&lt;T&gt; collections = new ArrayList&lt;T&gt;(); for (T t: elements) &#123; collections.add(t); &#125; return collections;&#125;// 构造数据源集合List&lt;String&gt; strings = addElements(\"hello\", \"wuhan\", \"university\"); 因为Java8中集合类型都被扩展了，所以我们可以直接通过strings.stream()来获取这个顺序执行的流。 Filter我们想只打印srtrings中包括字符h的字符串，所以，我们可以这样做： 123456strings.stream() .filter((o) -&gt; o.contains(\"h\")) .forEach(System.out::println);// hello// wuhan Sorted如果需要对它排序再输出，可以这么做： 1234567strings.stream() .sorted() .forEach(System.out::println);// hello// university// wuhan 不要以为strings这个列表本身的顺序发生了变化？其实并没有，streams.sorted()方法仅仅是针对这个列表新建了一个视图（View）从而来表示这个排序后的列表。 Match这个实际上就是来自于Guava中的Matcher类，主要是起一个判断作用，就是判断这个集合整体或者部分有什么性质。举下面这个例子： 1234567891011boolean flag = strings.stream() .anyMatch((s) -&gt; s.contains(\"v\")); // trueSystem.out.println(flag);flag = strings.stream() .allMatch((s) -&gt; s.length() &gt; 4); // trueSystem.out.println(flag);flag = strings.stream() .noneMatch((s) -&gt; s.contentEquals(\"world\")); // trueSystem.out.println(flag); 这里需要给大家简单解释一下，anyMatch方法表示集合中的任意元素只要有一个满足该条件就行；而allMatch表示集合中的全部的元素全都得满足这个条件；noneMatch表示集合中的全部元素必须都不满足这个条件才行。目前Java8提供了这三种判断，想了解更多的判断类型，请大家去看看我的Guava系列博客。 Count我们需要统计一个集合中满足条件的元素个数的时候可以使用这个方法来完成对应的操作： 1234long count = strings.stream() .filter((s) -&gt; s.contains(\"v\")) .count(); // 1System.out.println(count); 可以看到我们非常方便地统计出了集合中包含字符v的元素的个数。 Map映射使我们前面谈到的针对中间过程的操作，我们来看看它到底能做啥吧？ 1234567strings.stream() .map((s) -&gt; s.toUpperCase()) .forEach(System.out::println);// HELLO// WUHAN// UNIVERSITY 我们可以看到map是针对每一个元素进行相关的操作，上面我们以字符串的大写操作将列表中的元素全部变成了大写状态。大家也可以根据自己的情况编写对应的方法。 Reduce看完Map我们来聊聊Reduce操作，在Java8中，Reduce操作表示对集合中的连续两个元素进行操作，然后迭代，直到完成对所有元素的操作。最典型的例子就是进行集合中元素的求和： 12345List&lt;Integer&gt; ints = addElements(1, 4, 54, 34, 23, 12, 3);int sum = ints.stream() .reduce((a, b) -&gt; a + b) .get();System.out.println(sum); // 131 并行执行流说完了串行执行流，我们来说一说并行执行流是一种什么样的情况？我们知道，现在的电脑配置越来越高，CPU核心数也越来越多，那么如何有效地利用CPU的资源呢？这是一个很重要的方面，那就是采用并行的方式来进行编程。当然了，并行执行是否一定比串行执行快呢？这个不一定，大伙儿一定要根据自己的实际问题采取实际的措施解决，这里只是给大家介绍并行执行流如何使用，以及有哪些特点。 为了方便和串行执行流比较，我们先创建一个大没有重复元素的集合。 1234List&lt;String&gt; uuids = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 1000000; i++) &#123; uuids.add(UUID.randomUUID().toString());&#125; 首先使用串行执行的方式对它们进行排序： 1234long start = System.currentTimeMillis();uuids.stream().sorted().count(); // 这里不加count()算不出消耗时间，很奇怪long end = System.currentTimeMillis();System.out.println((end - start) + \"ms\"); // 841ms 再使用并行执行的方式对它们进行排序： 1234start = System.currentTimeMillis();uuids.parallelStream().sorted().count();end = System.currentTimeMillis();System.out.println((end - start) + \"ms\"); // 502ms 我们可以看到，并行的方式大概比串行的方式快了40%左右，这个性能的提升还是比较明显的。关于其它的比如说allMatch，anyMatch等等这些方法和那个串行执行流很像，这里就不多说了。 Map我们之前说过Map是不支持流操作的，但是不代表它不支持函数式编程操作，我们这里举几个例子说明一下： 12345678Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; 5; i++) &#123; map.putIfAbsent(i, i);&#125;map.forEach((i, s) -&gt; System.out.println(s));map.compute(2, (i, s) -&gt; s + 1);System.out.println(map.get(2)); // 3 我们在Map中最常见的一个操作就是修改某个元素的value值，上面的例子中我们使用map.compute()方法就可以实现相关的功能。并且和这个方法相似的还有两个方法：map.computeIfPresent()以及map.computeIfAbsent()方法。方法的名字已经说明它的作用了，相信也不用我说了。 还有一个方法是合并的功能，这里也说一下，不过我平时不怎么用到这个方法，但是直觉上感觉这个很重要： 1234567// map.get(2) ==&gt; 3map.merge(2, 3, (value, newValue) -&gt; value + newValue);System.out.println(map.get(2)); // 6// map.get(6) ==&gt; nullmap.merge(6, 6, (value, newValue) -&gt; value + newValue);System.out.println(map.get(6)); // 6 上面的例子表明，如果map中如果没有某一项entry的话，调用merge方法就只会向其中添加一个新的元素，如果存在entry的话，merge方法就会在原有的基础上添加这个新的值。 Date APIDate API也是Java8中的一个新的亮点，为什么我们需要使用一个新的Date API？不知道大家有没有和我一样的感受，在IDE敲击Date的时候很容易选错为java.sql.Date而不是java.util.Date对吧？这两个不同的包下面为什么要搞出一样的名字？还有格式化时间的时候需要使用到java.text.DateFormat类。这都不算啥，我们如果想要简单的对日期进行加减，我的天，还需要转化来转化去才能成为我们需要的日期时间。后来我们不得不借助于Joda Time这第三方包的帮助，为啥会这样呢？因为这个API设计的时候我估计是给机器看的，而不是给人看的！所以，这次Java8中带来的改变我觉得很欣慰。下面我们来看一下这个时间日期API是怎么玩的？ LocaleDate1234567891011121314151617181920212223LocalDate localDate = LocalDate.now();System.out.println(localDate.toString()); // 2017-03-31localDate = LocalDate.of(2018, Month.JULY, 11);System.out.println(localDate.toString()); // 2018-07-11localDate = LocalDate.now(ZoneId.of(\"Asia/Shanghai\"));System.out.println(localDate.toString()); // 2017-03-31localDate = LocalDate.ofEpochDay(365);System.out.println(localDate.toString()); // 1971-01-01localDate = LocalDate.of(2013, Month.JANUARY, 2).plusDays(1000);System.out.println(localDate.toString()); // 2015-09-29// how many days we've been together?LocalDate from = LocalDate.of(2013, Month.JANUARY, 2);LocalDate to = LocalDate.now();Period days = Period.between(from, to);System.out.println(days); // 29???// another waySystem.out.println(to.toEpochDay() - from.toEpochDay()); // 1549 我们可以利用Java8的LocalDate做很多日期相关的操作，比如计算任意两个日期之间的天数差值，查看某个时区的日期以及查看多少天以后是一个不错的纪念日等等这样的功能。 Instant这个咋一看不知道它是干嘛的，其实嘛！就是时间戳！用于产生机器可读的时间。将日期时间以Unix格式保存。 123456Instant timestamp = Instant.now();System.out.println(timestamp); // 2017-03-31T06:45:13.459ZSystem.out.println(timestamp.getEpochSecond()); // 1490942821// 用作Timestamp类构造参数Timestamp.from(timestamp).getTime(); // 1490942821289 格式化说到时间日期，一定要提一提格式化，前一会吐槽了Java8以前的格式化，现在来看一看Java8是如何改进的。 1234567LocalDateTime dateTime = LocalDateTime.parse(\"2017-01-09 22:23:30\", DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));System.out.println(dateTime); // 2017-01-09T22:23:30dateTime = LocalDateTime.parse(\"Nov 24, 2017 22:10\", DateTimeFormatter.ofPattern(\"MMM d, uuuu HH:mm\"));System.out.println(dateTime); // 2017-11-24T22:10 不得不说它这个DateTimeFormatter非常强大，什么格式都可以转，而且可以随意自定义格式，这个为我们程序开发提供了巨大的便利。 下面是一张表，大家可以对照这张表编写对应的格式Pattern： Symbol Meaning Presentation Examples G era text AD; Anno Domini; A u year year 2004; 04 y year-of-era year 2004; 04 D day-of-year number 189 M/L month-of-year number/text 7; 07; Jul; July; J d day-of-month number 10 Q/q quarter-of-year number/text 3; 03; Q3; 3rd quarter Y week-based-year year 1996; 96 w week-of-week-based-year number 27 W week-of-month number 4 E day-of-week text Tue; Tuesday; T e/c localized day-of-week number/text 2; 02; Tue; Tuesday; T F week-of-month number 3 a am-pm-of-day text PM h clock-hour-of-am-pm (1-12) number 12 K hour-of-am-pm (0-11) number 0 k clock-hour-of-am-pm (1-24) number 0 H hour-of-day (0-23) number 0 m minute-of-hour number 30 s second-of-minute number 55 S fraction-of-second fraction 978 A milli-of-day number 1234 n nano-of-second number 987654321 N nano-of-day number 1234000000 总结这就是Java8中的Stream流，Map以及新增的Date API相关的内容啦。暂时先介绍这么多，后面我们再针对具体的内容慢慢聊。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"http://qinjiangbo.com/tags/Java8/"}]},{"title":"细说Java8之新增API上","slug":"java8-new-interfaces-1","date":"2017-03-24T11:55:51.000Z","updated":"2017-09-02T15:07:45.000Z","comments":true,"path":"java8-new-interfaces-1.html","link":"","permalink":"http://qinjiangbo.com/java8-new-interfaces-1.html","excerpt":"","text":"JDK8发布已经有三年的时间了，虽然每次都在用JDK8去开发应用程序，但是在工作中对JDK8的新特性真的是使用不多。不过，我相信JDK8的开发者们这么辛辛苦苦编写出来的新特性一定是有它非常好的一面的，只是我们目前还没有习惯这种编程方式，不熟悉它并不代表它不优秀！ 接口中新增的default方法以前我们会说接口只能声明抽象方法，而抽象类才能既声明抽象方法又能实现具体方法。但是从JDK8开始，我们再也没有这种说法啦！因为，JDK8中为我们带来了接口的default默认方法。也就是说我们可以给接口中声明的方法加上默认的实现啦~ 1234567interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; 我们可以看到Formula类有两个方法，一个是未实现的calculate方法，另一个是具有默认实现的sqrt方法。实现Formula接口的具体类不必实现sqrt就可以直接使用这个方法。 123456789Formula formula = new Formula() &#123; @Override public double calculate(int a) &#123; return sqrt(a * 100); &#125;&#125;;formula.calculate(100); // 100.0formula.sqrt(16); // 4.0 是不是很Nice?但是我估计大家一时半会儿也很难使用这个特性，凡事得有一个过程。 Lambda表达式Lambda表达式可能是JDK8与之前版本最大的一个区别了！Lambda表达式在Python3中也开始支持了，二者的使用方式几乎相同，说明Lambda表达式已经被越来越多的平台支持啦，也说明Lambda表达式被越来越多的人所知晓。好啦，我们先来看看没有Lambda表达式的时候我们怎么写代码？ 12345678List&lt;String&gt; names = Arrays.asList(\"Richard\", \"Jack\", \"Pony\");Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125;&#125;); 这种方式够啦！！！代码好多都是可以省略的，其实真正起作用的就是b.compareTo(a)不是吗？那我们直接用它！ 12345List&lt;String&gt; names = Arrays.asList(\"Richard\", \"Jack\", \"Pony\");Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a)&#125;); 还可以更简洁~ 1Collections.sort(names, (String a, String b) -&gt; (b.compareTo(a))); 为什么还要加上类型？也可以去掉嘛！ 1Collections.sort(names, (a, b) -&gt; b.compareTo(a)); Java编译器自己会推断出a和b的类型，所以我们只需要写出它们需要做什么就行~现在继续看看Lambda表达式会发挥出什么样的威力？ 函数式接口Java8中引入了函数式编程，但是这里需要给大家说明的是Lambda表达式适用的场景，Lambda表达式的实质是什么？Lambda表达式就是一个匿名方法， 每一个Lambda表达式必须匹配一个只包含一个方法的接口。这样的方法就是函数式接口，这种接口在以前也叫SAM（Single Abstract Method）单抽象方法类型。 我们可以使用任意的接口来作为Lambda表达式，只要这个接口只有一个抽象方法就行。为了保证在生产中不出现一些没有声明但是却满足条件的接口，这种很有可能是误报，所以我们需要使用@FunctionalInterface注解。这样编译器就会知道这个注解了，并且在你尝试向其中添加额外的抽象方法时就会报错。来看一个例子： 12345678@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125;Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert(\"123\");System.out.println(converted); // 123 可以看到，converter对象的创建是基于一个抽象方法的实现。(from) -&gt; Integer.valueOf(from)这个方法是T convert(F from)的具体实现。如果这个时候你再添加一个抽象方法，这个Lambda表达式就没法写了，所以，函数式接口只能允许有一个抽象方法。注意一个事实就是如果你省略了这个@FunctionalInterface注解这个代码依然是正确的。原因我们前面讲过。 方法和构造函数引用利用静态方法引用上面的代码还可以写成这个样子： 123Converter&lt;String, Integer&gt; converter = Integer::valueOf;Integer converted = converter.convert(\"123\");System.out.println(converted); // 123 你可能会问这个::是什么？没错，我们在C++里面看到过，它是作用域限定符。那么在Java8里面它的作用是什么呢？我们可以看到的是它可以被用来引用类的静态方法。其实在C++里面也有这样的作用，我估计Java8学习了这一点的。那除了引用静态方法，普通的实例方法能不能引用呢？答案当然是可以的！ 12345678910class Something &#123; String startsWith(String s) &#123; return String.valueOf(s.charAt(0)); // convert first char to string &#125;&#125;Something something = new Something();Converter&lt;String, String&gt; converter = something::startsWith;String converted = converter.convert(\"Java\");System.out.println(converted); // \"J\" 我们注意到类Something的实例对象something可以通过::来调用它的startsWith方法。以上是对方法的引用，我们来看看::对构造函数是如何引用的？ 先定义一个对象： 1234567891011public class Student &#123; String name; int age; public Student()&#123;&#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 然后定义一个创建学生对象的地方： 123public interface School &#123; Student create(String name, int age);&#125; 现在就可以这么创建学生对象啦： 12School school = Student::new;Student stuent = school.create(\"Richard\", 23); 其实如果你使用IDE的话，上面的Student::new会自动提示出来。我们通过使用Student::new来引用了Student类的构造函数，而且Java的编译器会自己去匹配对应的构造函数。 Lambda访问限定域访问局部变量你可以在匿名对象中访问外部的变量，但是需要注意的是，这个被访问的变量默认是final的，因此你不可以在匿名对象中修改这个变量。在Lambda表达式中也是这样，Lambda表达式外部的变量默认是final的，如果你修改这个变量的值编译就没法通过。 1234567interface Calculator &#123; int add(int a);&#125;int b = 0;Calculator calculator = ((a) -&gt; &#123; return a+b; &#125;);b = 0; 这里就会报一个错误：Variables used in lambda expression should be final or effectively final。如何去修改呢？将b = 0;去掉即可。它就默认int b = 0;声明的这个变量b为final的了。为什么这些变量要设置为final不可变，那是因为考虑到多线程环境下更改这个变量的值是不安全的。 访问实例属性和静态变量使用Lambda表达式访问实例属性和静态变量的时候，和访问局部变量不同，你不需要将这些属性或者变量设置为final类型。下面这样写也是合法的。 12345678910111213141516171819202122class Scopes &#123; static int outerStaticNum; int outerNum; void testScopes() &#123; Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123; outerNum = 23; return String.valueOf(from + outerNum); &#125;; Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123; outerStaticNum = 72; return String.valueOf(from + outerStaticNum); &#125;; &#125; public static void main(String[] args) &#123; Scopes scopes = new Scopes(); scopes.testScopes(); System.out.println(outerStaticNum + \"-\" + outerNum); &#125;&#125; 这段代码执行完毕的时候，请问outerNum和outerStaticNum的值各是多少？23和72?当然不是，都是零。因为我们不能改变在Lambda表达式之外定义的值。（但是匿名函数可以哦！） 访问default方法在Java8中，虽然我们新增了默认方法即default方法，但是我们确不能使用Lambda表达式访问它。像下面这种方式就是编译不通过的： 123456789interface Calculator &#123; int add(int a); default int remove(int a) &#123; return a -= 1; &#125;&#125;Calculator calculator = (a) -&gt; remove(a); 它会提示Cannot resolve method remove(a)，说明Lambda表达式无法访问默认方法。 内置的函数式接口Java8中的函数式接口有很多，其中有相当多的一部分来自于Google的开源项目Guava，如果对Guava不熟悉的同学可以看一下我的《Guava优美代码》系列博客。下面让我们看看Java8为我们提供了哪些函数式接口？ Predicates Functions Suppliers Consumers Comparators Optionals Predicates中文翻译是什么，预言对吧。它的作用就是用来判断一些条件成不成立，而这些条件都会提前在Predicate对象中定义好。下面给出一个简单的例子： 123Predicate&lt;String&gt; predicate = s -&gt; s.startsWith(\"f\");System.out.println(predicate.test(\"funny\")); // trueSystem.out.println(predicate.negate().test(\"funny\")); // false 另外还有一些方法，比如and和or，这两个方法是用来创建复合预言的。 12345Predicate&lt;String&gt; predicate0 = s -&gt; s.contains(\"k\");Predicate&lt;String&gt; andPredicate = predicate.and(predicate0);Predicate&lt;String&gt; orPredicate = predicate.or(predicate0);System.out.println(andPredicate.test(\"funk\")); // trueSystem.out.println(orPredicate.test(\"joke\")); // true 也可以使用::来创建Predicate对象： 12Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;System.out.println(nonNull.test(null)); // false 可以看到Java8中的Predicate使用还是很多样的。但是Guava中的Predicate使用方式更多。留一个悬念，自己到本博客Guava系列博客中寻找答案吧！ Functions这个是啥意思大家都明白，函数嘛！函数的功能是干什么用的，执行一些动作！所以我们这里有必要给大家再区（啰）分（嗦）一下，函数Function是用来执行一些操作的所以它有可能有返回值，有可能没有返回值；而预言Predicate主要是用来判断一些条件成不成立的，所以它的返回值只能是Boolean类型。下面来看一下Function具体怎么用？ 1234Function&lt;String, Integer&gt; function = Integer::valueOf;Function&lt;Integer, Boolean&gt; function0 = (s) -&gt; s.intValue() &gt; 1000;Function &lt;String, Boolean&gt; composedFunc = function.andThen(function0);System.out.println(composedFunc.apply(\"123\")); // false 是不是很好玩？很灵活吧！可以非常自由地组合一些方法。 SuppliersSuppliers又是啥？提供者？一般我们更倾向于将其称之为生产者。和Function不同的是Supplier不支持任何参数。 12Supplier&lt;Student&gt; supplier = Student::new;System.out.println(supplier.get()); // Student@133314b 啥也不说了，它就这一个方法。。。类似于一种工厂。 ConsumersConsumers就是消费者，消费者的作用当然是消费从生产者那里产出的产品啦。我们来看看消费者到底如何开始消费？ 123Consumer&lt;Student&gt; consumer = p -&gt; System.out.println(p.name + \"+\" + p.age);consumer.accept(new Student(\"Richard\", 23)); 我们可以看到，现需要定义一个消费者，告诉它具体如何消费，然后通过accept方法给它传递一个产品供它消费。 Comparators比较器是JDK1.7就已经出现的函数式接口。JDK1.8中为这个函数式接口添加了需要默认方法。 12345Comparator&lt;Student&gt; comparator = (s1, s2) -&gt; s1.name.compareToIgnoreCase(s2.name);Student student1 = new Student(\"Amy\", 24);Student student2 = new Student(\"Richard\", 23);System.out.println(comparator.compare(student1, student2)); // -17 OptionalOptional就是可选的嘛！啥意思？也就是说返回的结构有可能是Null也有可能Non-Null。Null有合适和正确的使用场景，如在性能和速度方面Null是廉价的，而且在对象数组中，出现Null也是无法避免的。但相对于底层库来说，在应用级别的代码中，Null往往是导致混乱，疑难问题和模糊语义的元凶，就如同我们举过的Map.get(key)的例子。最关键的是，Null本身没有定义它表达的意思。 12345Optional&lt;String&gt; optional = Optional.of(\"hello\");System.out.println(optional.isPresent()); // trueSystem.out.println(optional.get()); // \"hello\"System.out.println(optional.orElse(\"world\")); // \"hello\"optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // \"h\" 上面的例子是直接创建了一个Optional对象的，但是我们也可以在函数中返回一个Optional对象。 123456789101112public Optional&lt;String&gt; getSomething(String thing)&#123; return Optional.ofNullable(thing);&#125;if (getSomething(\"some\").isPresent()) &#123; System.out.println(getSomething(\"some\").get());&#125;if (getSomething(null).isPresent()) &#123; System.out.println(getSomething(null).get());&#125; else &#123; System.out.println(\"The value is null!\");&#125; 一般我们都是先需要判断结果是否为空，然后在执行相应的操作。而且它比较好的一点是如果返回的值为空我们还可以指定相关的替代值。 总结以上就是JDK1.8中给我们带来的新特性的一部分。关于Stream流以及Map, Reduce等部分的内容我们在下一篇博文里再探讨。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"http://qinjiangbo.com/tags/Java8/"}]},{"title":"Java编程思想之方法重载（四）","slug":"think-in-java-method-reload","date":"2017-03-22T06:51:23.000Z","updated":"2017-03-22T10:15:05.000Z","comments":true,"path":"think-in-java-method-reload.html","link":"","permalink":"http://qinjiangbo.com/think-in-java-method-reload.html","excerpt":"","text":"如果你能在十五秒内答出如何区分两个函数如何区别的问题，那么本文你就可以直接略过了。如果不能的话，或者不是很确切的话，还是听我唠叨唠叨一下吧。 方法重载什么是方法？我们都知道当在堆上创建一个对象的时候，我们也就给堆上的这片内存空间取了一个名称。那么方法是什么呢？所谓方法就是给某一个动作取的名字。我们通常都是通过某一个方法执行某一段具体的动作。通过使用名字，你可以访问所有的对象和方法（匿名的除外哈）。 我们说一个好的名字不仅能够愉悦身心，而且还能提升代码的可读性和可维护性！所以，取一个好名字很重要，但是如果某个名字太火了，大家执行某个相似的业务逻辑时都想用怎么办？这个好办啊。使用方法重载。 如何区分不同的方法一句话，每一个方法都必须有一个独一无二的参数类型列表。稍加思考就会觉得这句话说得有道理，因为如果几个重载函数的参数类型都不能区分这些方法了，还有什么能区分这些方法呢？返回值么？？？有人肯定会这么问。好我现在给一个例子： 1234567public void count(int a) &#123; a++;&#125;public int count(int a) &#123; return a++;&#125; 是啊，这么一看还真是两个不一样的方法！但是需要注意，这么写在Java中是编译不通过的。原因很简单，如果我这么调用这个函数： 1count(1); 你跟我说说，我调用的是哪个方法？没法知道了吧。所以，返回值的区分方式是不可行的。还是得通过参数类型列表来区分。甚至连参数的顺序都能有效区分各个重载方法。但是我们通常不这么推荐，因为会造成代码的可读性大大降低，从而影响代码的可维护性。下面给一个正例： 1234567891011public int count(int a) &#123; return a++;&#125;public double count(double a) &#123; return a++;&#125;public float count(float a) &#123; return a++;&#125; 这样我们就能知道相关的重载方法了。 数据的窄化转化对于基本数据类型作为参数的方法重载，我们需要注意一个问题就是如果传入的数据类型（实参）小于方法的形式参数类型（形参），那么，实参的类型就会被自动的提升。与此同时，如果实参的类型比形参的类型大，则实参必须通过类型转换（cast）来实现窄化，否则编译不通过。 实参类型小于形参类型1234567void f1(int a)&#123; System.out.println(\"f1 int\"); &#125;void f1(char a)&#123; System.out.println(\"f1 char\"); &#125;void f1(double a)&#123; System.out.println(\"f1 double\"); &#125;void f1(float a)&#123; System.out.println(\"f1 float\"); &#125;void f2(long a)&#123; System.out.println(\"f2 long\"); &#125;void f2(double a)&#123; System.out.println(\"f2 double\"); &#125; 测试： 12int x = 10;f1(x); f2(x); 结果会是什么？ 12f1 intf2 long 因为f2里面没有int类型的形参，所以只能讲x提升为long型。 实参类型大于形参类型另一个方面，看看窄化转化的情况： 1234void f3(long a)&#123; System.out.println(\"f3 long\"); &#125;void f3(double a)&#123; System.out.println(\"f3 double\"); &#125;void f4(int a)&#123; System.out.println(\"f4 int\"); &#125; 这个时候使用long型来测试： 12long x = 17l;f3(x); f4(x); 会发生什么问题？我们可以看到f4(x)编译不通过，这是为什么？因为f4只有int型的参数，必须降低x的类型才能调用，所以就应该这么改进： 1f4((int) x); 这样就OK了，但是也需要注意会发生一些数据丢失的情况，因为是从高数据类型转化为低数据类型的。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qinjiangbo.com/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"http://qinjiangbo.com/tags/编程思想/"}]},{"title":"Java编程思想之操作符（三）","slug":"think-in-java-operators","date":"2017-03-22T05:06:19.000Z","updated":"2017-03-22T06:30:52.000Z","comments":true,"path":"think-in-java-operators.html","link":"","permalink":"http://qinjiangbo.com/think-in-java-operators.html","excerpt":"","text":"本文将的操作符就不像书中那样描述啦，博主总结一些比较重要而且比较容易出错的点。这些点弄明白了操作符这一块才能真正地搞清楚。 “+”操作符有人说“+”这个操作符也需要讲？Naive！如果只是简单地描述1+1=2，那这个篇文章就没有啥存在的意义了。这里主要描述的是与字符串相关的操作。 str1 + str2Java为我们做了一件很重要的事情就是让String支持+操作符。这样做有利也有弊。首先说说好处吧，就是我们的代码会变得很简洁，而且更加利于理解。比如要描述一件商品信息，我们会重写toString()方法。 123public String toStrinig() &#123; return this.name + \" - $\" + this.price + \" - \" + this.addr;&#125; 这里会返回商品的格式化信息，看起来代码很简洁。但是这么做有什么问题呢？我们必须得注意到String是final修饰的，意味着String类型是不可变的，那么两个字符串相加+的结果就是重新创建一个新的字符串，这个字符串由这两个字符串拼接而成。那么返回了新的字符串以后原来的字符串对象哪儿去了？等死呗，等待着GC来回收。显而易见，这样会很浪费空间，而且效率很低，因为会不断地创建对象以及销毁对象。比较Nice的做法就是使用StringBuilder或者StringBuffer对象，他们不需要多次创建对象，效率会高一些！ 123456public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(this.name).append(\" - $\") .append(this.price).append(\" - \").append(this.addr); return stringBuilder.toString();&#125; 当然了，这种方式看起来可读性就不如前面的+操作符了。这二者的权衡靠开发者衡量了，如果性能要求没有那么高就使用+吧，更可读。如果性能有要求，最后用后面的方式。 num + str之前看到了很简单的一道题，就是询问下面的代码输出： 12String s = 1 + 2 + 5 + \"$\" + 1;System.out.println(s); 那么s到底会变成啥呢？8$1。为什么不是大家想的125$1呢？那是因为在Java中，字符串和数字相加的时候会发生一个类型转换的问题，会自动地将数字转化为字符串。但是！由于+是一个从左到右的操作符，所以，根据上下文环境来看，如果相加的两个都是数字，则执行普通的相加操作，如果是一个数字和字符串，则执行字符串的连接操作。 别名问题Java通过引用的方式访问对象，那么如果两个引用同时指向同一个对象呢？这个就是我们说的别名现象。如下： 123int[] a = new int[5];int[] b = new int[5];int[] c = a; 可以看到，其实只创建了两个数组而不是三个数组，其中a和c表示的是同一个数组，b单独表示一个数组。对于a和c，不管哪一个改变了数组的元素，通过另个引用去访问数组元素都会和之前不同。这是一个很容易犯的错误。 12345678// People(name, age, hobby)// toString() &#123; return name + \"-\" + age + \"-\" + hobby; &#125;People p = new People(\"Richard\", 24, \"Girl\"); // methodpublic void chgName(People p) &#123; p = new People(\"Jimmy\", 24, \"Girl\");&#125;System.out.println(p); 那么这个时候p到底变成了什么呢？不少同学说p的名字已经变成了Jimmy，所以会打印Jimmy-24-Girl。恭喜你！成功避开正确选项。正确答案还是Richard-24-Girl。为什么会这样呢？我们注意到在chgName方法里面，局部变量p在调用的时候被初始化为Richard-24-Girl的这个对象，但是在方法体里面，这个局部变量p又被重新赋了一个新的对象Jimmy-24-Girl。这个时候我们知道这个局部变量和原来的那个对象便没有的什么关系，所以原来的对象并不会发生改变。可以见下图： 自增和自减自增++和自减--这个其实不难理解，无非就是将自身的值加一或者减一呗。但是这里一旦和变量的赋值操作结合起来就比较有意思了。 123int a = 7;int b = a++;int c = ++a; a, b, c的结果应该会是什么呢？有人可能会回答9, 8, 9。恭喜你，又答错了！正确的答案是9, 7, 9。为啥呢？我们注意到int b = a++;这一句是针对变量b赋值，但是需要注意这个赋值的顺序，是先将a赋值给b，然后a++， 因此b为7。变量c又是什么情况呢？注意到int c = ++a;在赋值语句右边紧跟着的是++自增语句，因此a会先自增为9，然后将a的值赋给c，所以c的取值是9。 自减的情况是一样一样的，这个地方很容易出现问题，如果你还不知道的话就赶紧好好敲一遍代码，理解并巩固一下。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qinjiangbo.com/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"http://qinjiangbo.com/tags/编程思想/"}]},{"title":"Java编程思想之注释文档（二）","slug":"think-in-java-comments","date":"2017-03-21T14:05:05.000Z","updated":"2017-03-22T04:52:34.000Z","comments":true,"path":"think-in-java-comments.html","link":"","permalink":"http://qinjiangbo.com/think-in-java-comments.html","excerpt":"","text":"大家平时聊天的时候总会调侃到，程序员最讨厌的事情就是别的程序员代码不写注释，让自己更讨厌的是自己的代码居然要写注释！今天就聊一聊Java的代码注释以及文档。 Java中的代码注释Java中的代码注释主要有两种风格，一种是源自于C语言的传统注释风格，即我们平时见到的多行注释，以/**开头，以**/结尾。另一种源自于C++语言的单行注释风格，就是在每一行代码的后面都可以使用//来标识说明内容。 多行注释12345/** * I want some coffee, * so I came here, pay you money * get a cup of coffee. */ 补充说明上面这个多行注释如何在IDE中快速使用呢？直接输入/**注意是两个*，然后回车，啪！就出来了。 单行注释1// The weather is so nice in Wuhan! 注释文档代码注释文档是保证Java源码可读性以及可维护性非常重要的一点，不然的话，别人写的代码你还能读？因此，很多时候一个新的员工到一个公司就会吵着要重构老员工的代码。为什么？原因很简单，第一，老员工的代码没加注释，代码风格比较烂，因此可读性很差；第二，这个新员工为了想展示自己的水平；这个时候，公司其他的老将通常会会心一笑，发出了too young~的叹息。 这里介绍一个工具—-JAVADOC，即Java Document的简写。作为一款Java文档工具，它的作用是负责将Java的代码同注释文档链接起来，不然的话我们写代码的同时还要负责修改文档，太痛苦了。这个工具能帮助我们自动化地生成Java的注释文档，我们平时看到的HTML形式的JDK8文档指的就是这个。 需要说明的是，所有的javadoc命令都只能在/**注释块中出现，在单行注释或者/*这种形式的多行注释都不会生效！ 有两种方式可以使用javadoc，一种是直接嵌入HTML页面，另一种是使用独立文档标签。这是个啥东西？就是一些以“@”字符开头的命令，且需要置于注释行的最前面。行内文档标签则可以出现在任何一个地方，也是以“@”字符开头的命令，不过他们需要使用花括号“{}”括起来。 嵌入式的HTML嵌入式HTML的作用主要是为了对代码实现格式化。 例1 12345/** * &lt;pre&gt; * System.out.println(\"1+1=?\") * &lt;/pre&gt; */ 例2 123456789/** * These are the function names: * &lt;ul&gt; * &lt;li&gt;getUserNameById&lt;/li&gt; * &lt;li&gt;login&lt;/li&gt; * &lt;li&gt;register&lt;/li&gt; * &lt;li&gt;logout&lt;/li&gt; * &lt;/ul&gt; */ 文档标签给大家介绍一些常用的文档标签。我们经常在Java源码，Spring框架，Struts框架中看到别的程序员写的代码注释，无不感叹多么详尽准确。现在就来看一看这些文档标签的真面目。 @see@see标签允许用户引用其它类的文档。JAVADOC会在这个类生成的文档当中添加一个链接指向被引用的文档。具体格式如：@see classname和@see classname#methodname。 {@link package.class#member label}@link标签必须写在花括号内，它和@see的作用差不多，只是它用在行内而@see用在行首而已。并且@link使用label作为链接文本而不是使用“See Also”，这个区别很关键。 {@docRoot}@docRoot标签用于产生到文档根目录的相对路径，用于文档树页面的显示超链接。 {@inheritDoc}@inheritDoc标签表示从当前这个类的最直接的基类中继承相关的文档作为当前的注释文档。 @version@version标签表示代码版本号，一般使用这个以后我们就可以在javadoc中使用javadoc -version提取出相应版本的文档了。具体格式如：@version version-info。 @author@author标签表示了这个代码的作者，这个很关键啊！一般多人协作时，需要在代码上加上作者信息以区分每个人的工作。具体格式如：@author author-info。 @date@date标签表示创建这个文件的日期。具体格式@date YYYY-MM-dd HH:mm:ss或者@date other-date-string。 @since@since标签表示这个代码适用的最早的JDK版本号，比如从JDK5起开始适用就可以表示为@since 1.5。 @param@param标签其实是作用于方法体上面的标签，表示这个方法的参数信息。常见的用法@param paramname description。 @return@return标签也是作用于方法体上面的标签，表示这个方法的返回信息，常见的用法@return description。 @throws@throws标签也是作用于某个方法体上面的标签，表示这个方法可能抛出的异常类型，常见的用法@throws full-qualified-class-name description。中间的full-qualified-class-name表示这个异常类的全类名。 举个栗子看了这么多标签，我们下面来实战一下： 123456789101112131415161718/** * The class is to show the information in the specified file * @author qinjiangbo@github.io * @version 1.0.1 * @since 1.7 * @date 2017-03-22 12:41:20 */public class Tags &#123; /** * The method is going to print the file information * @param fileName the name of the file * @return the state of the operation * @throws java.io.FileNotFoundException exception */ public int echo(String fileName) throws FileNotFoundException &#123; return 0; &#125;&#125;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qinjiangbo.com/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"http://qinjiangbo.com/tags/编程思想/"}]},{"title":"使用You-Get下载YouTube视频","slug":"you-get-video-downloader","date":"2017-03-15T11:13:09.000Z","updated":"2017-03-15T12:25:22.000Z","comments":true,"path":"you-get-video-downloader.html","link":"","permalink":"http://qinjiangbo.com/you-get-video-downloader.html","excerpt":"","text":"在线网站有很多，但是提供下载链接的很少。一般都是会采取下载客户端，要求你在客户端缓存的策略，但是有没有什么方法可以让你不在客户端就可以直接在PC端（包括Linux端 &amp; Mac端）下载呢？答案是肯定的，You-Get便是其中的一种选择。 什么是You-Get？You-Get是一个非常轻量级的命令行实用工具，可以用来从网上下载媒体内容（比如视频，音频，图片）。当没有其它什么方便的途径下载的时候它是一个不错的选择。 看看它能做什么？给定一条视频的播放地址，它就能自动读取视频流并解析然后下载。 12345678$ you-get http://www.fsf.org/blogs/rms/20140407-geneva-tedx-talk-free-software-free-societySite: fsf.orgTitle: TEDxGE2014_Stallman05_LQType: WebM video (video/webm)Size: 27.12 MiB (28435804 Bytes)Downloading TEDxGE2014_Stallman05_LQ.webm ...100.0% ( 27.1/27.1 MB) ├████████████████████████████████████████┤[1/1] 12 MB/s 据说you-get常规的下载速度比迅雷要好很多！当然，如果迅雷会员开挂了就不好说啦。 You-Get如何安装？先说说You-Get的依赖条件。它需要你提前安装好Python3和FFmpeg的运行时环境。切记。 安装方式1使用python的pip工具安装 1$ pip3 install you-get 安装方式2源码安装 1$ [sudo] python3 setup.py install 安装方式3 （仅支持Mac平台）使用Homebrew安装 1$ brew install you-get 安装方式4 （仅支持Win平台）使用Chocolatey安装 1&gt; choco install you-get 下载YouTube视频我们需要准备视频的地址，比如：https://www.youtube.com/watch?v=571IIGJKeoA&amp;index=2&amp;list=PL0Smm0jPm9WcCsYvbhPCdizqNKps69W4Z，然后在命令行直接输入命令： 1$ you-get https://www.youtube.com/watch?v=571IIGJKeoA*** 这样就能下载啦。如果你需要查看所下载的视频有哪几种清晰度？方便！使用you-get命令的-i选项即可。 123456789101112131415161718192021222324252627282930$ you-get -i 'https://www.youtube.com/watch?v=jNQXAC9IVRw'site: YouTubetitle: Me at the zoostreams: # Available quality and codecs [ DEFAULT ] _________________________________ - itag: 43 container: webm quality: medium size: 0.5 MiB (564215 bytes) # download-with: you-get --itag=43 [URL] - itag: 18 container: mp4 quality: medium # download-with: you-get --itag=18 [URL] - itag: 5 container: flv quality: small # download-with: you-get --itag=5 [URL] - itag: 36 container: 3gp quality: small # download-with: you-get --itag=36 [URL] - itag: 17 container: 3gp quality: small # download-with: you-get --itag=17 [URL] 我们可以看到上面[DEFAULT]默认选项。一般来说，视频总是会下载清晰度最高的那个，如果你需要修改下载的清晰度，可以使用you-get --itag={NUMBER} [URL]命令。 批量下载视频将需要下载的视频链接地址写入一个文件，像这样： videoList.txt 123456789https://www.youtube.com/watch?v=gNkE3tFUFuw&amp;index=1https://www.youtube.com/watch?v=571IIGJKeoA&amp;index=2https://www.youtube.com/watch?v=hfO6iRj-GZo&amp;index=3https://www.youtube.com/watch?v=iDsywHN-u08&amp;index=4https://www.youtube.com/watch?v=n1qyTXRdWQg&amp;index=5https://www.youtube.com/watch?v=5lGPkRDWTA8&amp;index=6https://www.youtube.com/watch?v=2i9LdgTbcg8&amp;index=7...https://www.youtube.com/watch?v=ya5fm3-d_SU&amp;index=112 批量下载downloader.sh 1234567#!/bin/bash# -*- encoding: utf-8 -*-for line in `cat videoList.txt`do you-get $linedone 赋予downloader.sh可执行权限，再执行如下命令就可以下载啦。 12$ sudo chmod 755 downloader.sh$ sh downloader.sh You-Get支持哪些视频网站？ Site URL Videos? Images? Audios? YouTube https://www.youtube.com/ ✓ Twitter https://twitter.com/ ✓ ✓ VK http://vk.com/ ✓ ✓ Vine https://vine.co/ ✓ Vimeo https://vimeo.com/ ✓ Vidto http://vidto.me/ ✓ Videomega http://videomega.tv/ ✓ Veoh http://www.veoh.com/ ✓ Tumblr https://www.tumblr.com/ ✓ ✓ ✓ TED http://www.ted.com/ ✓ SoundCloud https://soundcloud.com/ ✓ SHOWROOM https://www.showroom-live.com/ ✓ Pinterest https://www.pinterest.com/ ✓ MusicPlayOn http://en.musicplayon.com/ ✓ MTV81 http://www.mtv81.com/ ✓ Mixcloud https://www.mixcloud.com/ ✓ Metacafe http://www.metacafe.com/ ✓ Magisto http://www.magisto.com/ ✓ Khan Academy https://www.khanacademy.org/ ✓ Internet Archive https://archive.org/ ✓ Instagram https://instagram.com/ ✓ ✓ InfoQ http://www.infoq.com/presentations/ ✓ Imgur http://imgur.com/ ✓ Heavy Music Archive http://www.heavy-music.ru/ ✓ Google+ https://plus.google.com/ ✓ ✓ Freesound http://www.freesound.org/ ✓ Flickr https://www.flickr.com/ ✓ ✓ FC2 Video http://video.fc2.com/ ✓ Facebook https://www.facebook.com/ ✓ eHow http://www.ehow.com/ ✓ Dailymotion http://www.dailymotion.com/ ✓ CBS http://www.cbs.com/ ✓ Bandcamp http://bandcamp.com/ ✓ AliveThai http://alive.in.th/ ✓ interest.me http://ch.interest.me/tvn ✓ 755 ナナゴーゴー http://7gogo.jp/ ✓ ✓ niconico ニコニコ動画 http://www.nicovideo.jp/ ✓ 163 网易视频 网易云音乐 http://v.163.com/ http://music.163.com/ ✓ ✓ 56网 http://www.56.com/ ✓ AcFun http://www.acfun.tv/ ✓ Baidu 百度贴吧 http://tieba.baidu.com/ ✓ ✓ 爆米花网 http://www.baomihua.com/ ✓ bilibili 哔哩哔哩 http://www.bilibili.com/ ✓ Dilidili http://www.dilidili.com/ ✓ 豆瓣 http://www.douban.com/ ✓ ✓ 斗鱼 http://www.douyutv.com/ ✓ Panda 熊猫 http://www.panda.tv/ ✓ 凤凰视频 http://v.ifeng.com/ ✓ 风行网 http://www.fun.tv/ ✓ iQIYI 爱奇艺 http://www.iqiyi.com/ ✓ 激动网 http://www.joy.cn/ ✓ 酷6网 http://www.ku6.com/ ✓ 酷狗音乐 http://www.kugou.com/ ✓ 酷我音乐 http://www.kuwo.cn/ ✓ 乐视网 http://www.le.com/ ✓ 荔枝FM http://www.lizhi.fm/ ✓ 秒拍 http://www.miaopai.com/ ✓ MioMio弹幕网 http://www.miomio.tv/ ✓ 痞客邦 https://www.pixnet.net/ ✓ PPTV聚力 http://www.pptv.com/ ✓ 齐鲁网 http://v.iqilu.com/ ✓ QQ 腾讯视频 http://v.qq.com/ ✓ 企鹅直播 http://live.qq.com/ ✓ Sina 新浪视频 微博秒拍视频 http://video.sina.com.cn/ http://video.weibo.com/ ✓ Sohu 搜狐视频 http://tv.sohu.com/ ✓ Tudou 土豆 http://www.tudou.com/ ✓ 虾米 http://www.xiami.com/ ✓ 阳光卫视 http://www.isuntv.com/ ✓ 音悦Tai http://www.yinyuetai.com/ ✓ Youku 优酷 http://www.youku.com/ ✓ 战旗TV http://www.zhanqi.tv/lives ✓ 央视网 http://www.cntv.cn/ ✓ 花瓣 http://huaban.com/ ✓ Naver 네이버 http://tvcast.naver.com/ ✓ 芒果TV http://www.mgtv.com/ ✓ 火猫TV http://www.huomao.com/ ✓ 全民Tv http://www.quanmin.tv/ ✓ 另记本文知识做了一个简单的介绍，关于具体的介绍大家不妨访问you-get的官方网站。地址为https://you-get.org/。有什么使用上的问题可以直接在Github的ISSUE里面直接提BUG。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"You-Get","slug":"You-Get","permalink":"http://qinjiangbo.com/tags/You-Get/"},{"name":"YouTube","slug":"YouTube","permalink":"http://qinjiangbo.com/tags/YouTube/"}]},{"title":"Java编程思想之数据存储（一）","slug":"think-in-java-data-storage","date":"2017-03-14T14:09:44.000Z","updated":"2017-03-21T14:39:29.000Z","comments":true,"path":"think-in-java-data-storage.html","link":"","permalink":"http://qinjiangbo.com/think-in-java-data-storage.html","excerpt":"","text":"数据到底存储在什么地方？程序运行的时候，对象是怎么进行有效地放置的呢？尤其是我们关心的内存是如何分配的？一般来说，数据会存放在以下五个地点。 1. 寄存器这是最快的存储区，没有之一。因为寄存器位于CPU内部。CPU是直接执行指令的地方，寄存器距离它最近，因此速度最快。但是寄存器的大小就比较可怜了，所以一般寄存器的大小都是根据需要进行分配。我们不能直接控制寄存器的内存分配，甚至根本感觉不到它的存在。 2. 堆栈堆栈的概念不同于后面的“堆”。堆栈位于通用RAM（随机访问存储器）中，但是通过堆栈指针可以从处理器那里获得直接支持。若堆栈指针向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的存储方法，仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈中的所有项的确切生命周期，以便于上下移动堆栈指针。但是这个却限制了程序的灵活性。所以Java里面我们可以看到，虽然像对象引用这种数据存放在堆栈中，但是对象却存放在堆中。 3. 堆也是一种通用的内存池，也位于RAM中。使用堆比堆栈的灵活性要高不少。编译器不需要知道堆中的对象需要存活多长的时间。需要一个对象的时候只需要使用一条简单的new语句就行了，当程序执行这段代码的时候，便会自动进行内存的分配。但是使用堆也会有一些弊端，就是灵活性是以牺牲了对应的对象创建和销毁的速度为代价的。 4. 常量存储常量值直接放在程序代码内部。这样做是安全的，因为它们永远不会被改变。 5. 非RAM存储这里说的非RAM存储其实指的就是数据的持久化问题。通过将数据持久化为文件的形式保存在磁盘上。它们不收任何程序的限制，只要你能够读取并识别出这些数据，无论是在哪台服务器，在哪个操作系统，Fine！Java的序列化就是一个典型的对象持久化的例子。它可以直接将对象以文件的形式保存下来，并且在需要的时候恢复。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qinjiangbo.com/tags/Java/"},{"name":"编程思想","slug":"编程思想","permalink":"http://qinjiangbo.com/tags/编程思想/"}]},{"title":"设计模式素材制作","slug":"design-pattern-pictures","date":"2017-03-09T17:56:30.000Z","updated":"2017-03-09T18:19:02.000Z","comments":true,"path":"design-pattern-pictures.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-pictures.html","excerpt":"","text":"在网上找了很久的设计模式相关的图片素材，一直没有找到，决定自己写一套出来，如果你有需要的可以自取使用，但是商业用途除外。图片不加水印，开源分享给大家！好啦，下面分别将它们列举出来。大家可以点击图片上面的下载链接下载图片的PSD格式文件。 设计模式原图 下载 创建型模式工厂方法模式 下载 抽象工厂模式 下载 单例模式 下载 建造者模式 下载 原型模式 下载 结构型模式适配器模式 下载 装饰器模式 下载 代理模式 下载 外观模式 下载 桥接模式 下载 组合模式 下载 享元模式 下载 行为型模式策略模式 下载 模板方法模式 下载 观察者模式 下载 迭代子模式 下载 责任链模式 下载 命令模式 下载 备忘录模式 下载 状态模式 下载 访问者模式 下载 中介者模式 下载 解释器模式 下载 再说一句以上所有的图片都是博主辛辛苦苦花时间用PS做出来的，希望大家能喜欢！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"设计图制作","slug":"设计图制作","permalink":"http://qinjiangbo.com/tags/设计图制作/"}]},{"title":"URL缩短原理与实现","slug":"short-url-implementations","date":"2017-03-07T17:23:19.000Z","updated":"2017-03-09T01:55:21.000Z","comments":true,"path":"short-url-implementations.html","link":"","permalink":"http://qinjiangbo.com/short-url-implementations.html","excerpt":"","text":"一直在使用URL缩短的技术，但是一直没有时间来琢磨这背后的技术原理是什么，今天给大伙儿聊聊URL缩短技术的原理和实现细节。 短网址是什么？还记得http://t.cn/RTwgi8这样的网址么？没错，我们每次打开新浪微博的时候只要是链接，基本上都是这样一种形式。简单点来说，短网址就是长度比较短的网址。从另一种角度上来讲，短网址的确产生了巨大的价值。以微博为例，微博一般限制字数为140字，如果你粘贴一个很长的链接要分享给大家，结果就占据了你微博的一半，这肯定是不能接受的。所以，微博就推出了短网址的服务，大家在发送微博时，不管链接是视频还是文章等等，统统转化为类似http://t.cn/这样的短网址。 短网址服务提供商 百度短网址 新浪短网址 缩我 谷歌短网址 YoURLs TinyURL 原理一般来说有两种实现原理，一种是基于MD5加密的，另一种是根据[a-zA-Z0-9]组成的62个字母作为字典表来转换的。 MD5加密先说说MD5加密算法实现的短网址服务，主要分为以下几步： 拿到长网址以后对长网址生成32位的md5签名串， 分为4个段，每一个段有8个字符。 然后将4个小段分别和0x3fffffff(7个f)作与操作，超过30位以上的部分直接截断。 将这30位分为六个段，每个5位，根据这5位的数字取得对应在字母表中的字符。总共是6个字符。 然后就可以获得4个6位的字符串，随便选择一个作为短网址即可。 将短网址和长网址一起对应地存入到数据库中，方便到时候直接从RDBMS或者是NoSQL数据库中直接读取。 这种方法比较简单，但是存在一个问题就是还是存在一定的可能性会重复。所以我不推荐大家使用这种方式去做，毕竟用户的数据安全是第一位的。 [a-zA-Z0-9]字母表法我时常在想，新浪哪能容纳得了那么多的链接啊？这么多短网址怎样才能够用呢？其实大家不用担心，你们自己可以算一下，根据这个字母表生成6位字符串总共有多少种可能性？ 62 ^ 6 = 56800235584没错，就是56800235584这么多种，约为568亿个链接。足够用啦！ 好了，我们来说说它的具体操作流程。这里我们要约定一个数据字典，而且应该是一个双向的字典。比如a-&gt;0，b-&gt;1，c-&gt;2,…,9-&gt;61等等。分两部分解释编码和解码的步骤。 编码步骤（数据库记录ID—&gt;短网址）我们获取到一个长网址以后，会先将它存入到数据库，不管是RDBMS关系型数据库还是NoSQL数据库，存好以后会返回它的一个记录编号（一般是表的行号）。首先需要明确的是这个编号是一个10进制的数字，现在我们需要做的工作就是将其转化为62进制。为什么要这么做？因为我们的字典是62个字符组成的，所以想要与其一一对应的话必须按照62进制来算。进制转换想必大家应该还记得吧。 注意如果遇到记录编号为12， 45， 29等等比较小的ID时，可能凑不齐6位字符串。这个时候我们就需要在它们的前面加上a，因为a-&gt;0。举个例子，记录ID为60的数据对应的短网址就应该是aaaaa8，因为8-&gt;60，前面不够的直接补上a即可。 解码步骤（短网址—&gt; 数据库记录ID）解码步骤相对简单一点，就是将短网址的各个字符转化为对应的数字然后相加即可。还是举个栗子：Rwis8d这个短网址的对应的62进制数据为[43, 22, 8, 18, 60, 3]。可以按照如下方式计算： 43 \\times 62^5 + 22 \\times 62^4 + 8 \\times 62 ^ 3 + 18 \\times 62 ^ 2 + 60 \\times 62 ^ 1 + 3 \\times 62 ^ 0 = 39720770707所以可以得到数据库中的编号为39720770707根据这个去查找数据库中对应的长网址就行啦！ 代码实现代码采用Java实现，有需要的大家可以根据这个Java版本写出自己擅长的语言的版本。欢迎大家尝试！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package URLShortener;import java.util.HashMap;import java.util.Map;/** * @date: 08/03/2017 9:25 PM * @author: qinjiangbo@github.io */public class URLShortener &#123; private static final String DICT = \"abcdefghijklmnopqrstuvwxyz\" + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; // 数字-&gt;字符映射 private static final char[] CHARS = DICT.toCharArray(); // 字符-&gt;数字映射 private static final Map&lt;Character, Integer&gt; NUMBERS = new HashMap&lt;&gt;(); static &#123; int len = CHARS.length; for (int i = 0; i&lt;len; i++) &#123; NUMBERS.put(CHARS[i], i); &#125; &#125; /** * 根据从数据库中返回的记录ID生成对应的短网址编码 * @param id (1-56.8billion) * @return */ public static String encode(long id) &#123; StringBuilder shortURL = new StringBuilder(); while (id &gt; 0) &#123; int r = (int) (id % 62); shortURL.insert(0, CHARS[r]); id = id / 62; &#125; int len = shortURL.length(); while (len &lt; 6) &#123; shortURL.insert(0, CHARS[0]); len++; &#125; return shortURL.toString(); &#125; /** * 根据获得的短网址编码解析出数据库中对应的记录ID * @param key 短网址 eg. RwTji8, GijT7Y等等 * @return */ public static long decode(String key) &#123; char[] shorts = key.toCharArray(); int len = shorts.length; long id = 0l; for (int i = 0; i &lt; len; i++) &#123; id = id + (long) (NUMBERS.get(shorts[i]) * Math.pow(62, len-i-1)); &#125; return id; &#125; public static void main(String[] args) &#123; System.out.println(encode(39729551080l)); System.out.println(decode(\"RwTji8\")); &#125;&#125; 控制台输出结果： 1234RwTji839729551080Process finished with exit code 0 总结短网址是一个比较实用的算法设计，它通过简单的算法就能够将无论多长的长网址转换为只有短短6位的短网址。这里有人会有疑问了，为什么是6位？我没有说一定是6位啊，哈哈，5位，4位，以及7位，8位都是可以的，具体取决于你的业务设计。位数越小，越容易记住，当然了，容纳的长网址数量越少。位数越大，越难记住，但是容量会指数倍的增加。根据这两个标准去判断是不错的啦！","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"算法","slug":"架构师/算法","permalink":"http://qinjiangbo.com/categories/架构师/算法/"}],"tags":[{"name":"URL缩短","slug":"URL缩短","permalink":"http://qinjiangbo.com/tags/URL缩短/"}]},{"title":"设计模式学习之命令模式","slug":"design-pattern-command","date":"2017-03-04T06:53:28.000Z","updated":"2017-03-09T17:54:19.000Z","comments":true,"path":"design-pattern-command.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-command.html","excerpt":"","text":"什么是命令模式命令模式(Command Design Pattern)将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。 将封装带入一个新的境界在本文中，我们将介绍命令模式。这个模式有多大的本事呢？通过使用该模式我们能将方法调用（Method Invocation）进行封装。没错，就是方法调用。我们可以将运算块包装成形。调用这个运算的对象根本就不需要关心这个运算块是如何执行的，它只需要知道如何使用封装运算块的方法即可。通过封装方法调用，我们可以做一些很Smart的事情，比如实现记录日志，操作的回滚等。 命令模式类图 Client客户端负责创建一个ConcreteCommand，并设置它的的接收者。 Invoker调用者持有一个命令对象，并且在某个时间点调用命令对象的execute()方法，请求付诸实行。 Command为所有的命令声明了一个接口。调用命令对象的execute()方法，就可以让接收者进行相关的动作。这个接口也同时具有一个undo()方法用于撤销操作。 ConcreteCommand定义了动作和接收者之间的关系。调用者只需要调用execute()方法就可以发出请求，然后由ConcreteCommand调用接收者的一个或者多个动作。 可以看到，上图中的execute()的具体实现已经给出，我们可以看到它这个方法调用了receiver接收者的动作方法action()，也就是说，正真执行具体动作的是接收者，而不是命令。使用一句通俗的表示就是一个人Client拿起手中的遥控器Invoker点了一个播放按钮ConcreteCommand，然后电视机Receiver就开始播放视频了。 实例分析-智能家居随着现在互联网技术的快速扩张，从苹果的HomeKit到小米的智能家居我们可以知道，现在互联网企业不仅仅满足虚拟网络的互联了，他们开始关注起物联网来（Internet of Things）。本例不会涉及互联网的任何具体内容，只谈其中的一个功能。就是实现一个对整个智能家居的所有智能设备控制的软件，这里也可以叫它万能遥控器。利用它我们可以开门，可以启动空调，可以关闭电磁炉，可以打开电风扇，可以开灯关灯等等。 系统的结构简单的介绍一下： 图有点老不要紧，我们的解释可以很时尚嘛！我们可以看到，图中的遥控器上面有7个插槽，分别已经对应到了不同的智能设备上面。另外在最底下还有一个UNDO的插槽。用于实现操作的撤销。 右下角大家注意到，遥控器点击了立体声（Stereo）系统的关闭功能，可以看到，命令具体执行还是由立体声（Stereo）系统本身来完成的。那有人就问了，为啥不直接让客户端直接操作立体声系统，客观上来讲，这种可行性是有的。不过呢，封装这个请求有利于统一的管理，便于遥控器功能的拓展。比如某个设备更换了，那么遥控器可以立即更换相应的命令。如果不使用遥控器，就好比凡事都要你自己动身去操作，多麻烦！ 命令接口Command接口只需要定义需要做什么事情就好了，Command接口的事情很简单，就两个： execute()执行某个请求 undo()撤销某个请求 具体命令ConcreteCommand到了具体命令这里情况稍微有点变化，我们都知道每一个具体的命令都对应着一个具体的智能设备，因此，除了具有上述的两个方法外，具体命令里面应该还需要包含一个智能设备。不然你没法执行execute()和undo()方法啊。 接收者Receiver 接收者就是我们前面多次提到过的智能设备，比如电视机，立体声系统，空调等。它本身包含很多具体的功能，有很多不同的动作可以被执行，其中最基本的无非就是开机和关机。 on()开机 off()关机 调用者Invoker这个就是遥控器啦，我们从前面的系统设计图上也可以看出，遥控器上设置了很多不同的命令，分别有不同的功能，那么，遥控器上我们需要拥有可以设置命令的地方。另外，设置了命令以后我们需要有撤销键，应该允许用户反悔啊！ setCommand() onButtonPressed() offButtonPressed() onButtonPressedUndo() offButtonPressedUndo() 代码实现Command 123456public interface Command &#123; public void execute(); public void undo();&#125; ConcreteCommand（这里太多了，只举一个例子） 123456789101112131415161718public class LightOffCommand implements Command &#123; Light light; public LightOffCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.off(); &#125; @Override public void undo() &#123; light.on(); &#125;&#125; Receiver(太多了，也只举一个例子) 12345678910111213141516public class Light &#123; private String type = \"\"; public Light(String type) &#123; this.type = type; &#125; public void on() &#123; System.out.println(type + \" Light is on\"); &#125; public void off() &#123; System.out.println(type + \" Light is off\"); &#125;&#125; Invoker 1234567891011121314151617181920212223242526272829303132333435363738public class RemoteControl &#123; Command[] onCommands; Command[] offCommands; public RemoteControl() &#123; onCommands = new Command[4]; offCommands = new Command[4]; Command noCommand = new NoCommand(); for (int i = 0; i &lt; 4; i++) &#123; onCommands[i] = noCommand; offCommands[i] = noCommand; &#125; &#125; public void setCommand(int slot, Command onCommand, Command offCommand) &#123; onCommands[slot] = onCommand; offCommands[slot] = offCommand; &#125; public void onButtonPressed(int slot) &#123; onCommands[slot].execute(); &#125; public void offButtonPressed(int slot) &#123; offCommands[slot].execute(); &#125; public void onButtonPressedUndo(int slot) &#123; onCommands[slot].undo(); &#125; public void offButtonPressedUndo(int slot) &#123; offCommands[slot].undo(); &#125;&#125; 测试一下 12345678910111213141516171819202122232425262728293031323334353637public class RemoteControlTest &#123; public static void main(String[] args) &#123; RemoteControl remoteControl = new RemoteControl(); Light livingRoomLight = new Light(\"Living Room\"); Light kitchenLight = new Light(\"Kitchen\"); Stereo stereo = new Stereo(); LightOnCommand livingRoomLightOn = new LightOnCommand(livingRoomLight); LightOffCommand livingRoomLightOff = new LightOffCommand(livingRoomLight); LightOnCommand kitchenLightOn = new LightOnCommand(kitchenLight); LightOffCommand kitchenLightOff = new LightOffCommand(kitchenLight); StereoOnWithCDCommand stereoOnWithCD = new StereoOnWithCDCommand(stereo); StereoOffCommand stereoOff = new StereoOffCommand(stereo); //plugin the commands remoteControl.setCommand(0, livingRoomLightOn, livingRoomLightOff); remoteControl.setCommand(1, kitchenLightOn, kitchenLightOff); remoteControl.setCommand(2, stereoOnWithCD, stereoOff); //start remoteControl.onButtonPressed(0); remoteControl.onButtonPressed(1); remoteControl.onButtonPressed(2); //stop remoteControl.offButtonPressed(0); remoteControl.offButtonPressed(1); remoteControl.offButtonPressed(2); remoteControl.offButtonPressedUndo(2); &#125;&#125; 测试结果： 1234567891011Living Room Light is onKitchen Light is onStereo is onCD is playing...Volume is 11Living Room Light is offKitchen Light is offStereo is offStereo is onCD is playing...Volume is 11 可以看出，系统工作良好，上面的代码我已经全部同步到Github上面去了，有需要的同学可以去我的Github仓库自行查看下载。 GitHub地址：https://github.com/QinJiangbo/DesignPatterns/tree/master/src/com/qinjiangbo/command 命令模式的更多用途命令模式除了可以实现上述的功能以外，其实大有作为，它还可以被应用在队列请求和日志请求上。 队列请求想像有一个工作队列：你在某一端添加命令，然后另一端是线程。线程进行以下操作：从队列中取出一个请求，这里我们不讨论具体是哪种队列啦，不管是FIFO还是LIFO都OK。取出这个请求以后调用它的execute()方法，执行完毕以后将这个请求销毁。然后继续取出下一个请求，在执行相同的execute()方法，再销毁… 需要注意的是，工作队列类和执行的请求之间是完全解耦的，前一个请求是数据库请求，下一个请求就有可能是Http网络请求。但是不管是什么请求，只要它有execute()就成！这也是一个很经典的说法，就是不管你是不是鸭子，只要你会咕咕叫，我就认为你是鸭子。 日志请求我们都知道日志系统不仅仅只是用来记录服务器到底发生了什么错误，它还有一个重大的作用就是实现系统的备份还原。具体怎么做呢，当我们执行命令的时候，我们将命令请求记录在磁盘上面，不管是以序列化的方式还是以文件存储的方式都可以。最好推荐以日志文件的方式。这些记录是什么呢，是我们每一次操作时的动作以及这个动作携带的数据参数。 这么做有一个好处，就是对于一些大型的数据系统，可能一条命令需要更新很多条记录，如果每一次都备份数据的话那简直不敢想象这个系统会卡成什么样子。但是记录动作的话情况会变得简单很多。一旦系统发生宕机，我们便可以立即启动备份机制。将备份点（CheckPoint）之后的动作从头到尾依次执行一遍，那样所有的数据就全部回来啦。 当然啦，定期备份数据也是非常重要的。这里我们只是讨论如何日志系统如何实现数据恢复的操作。 总结命令模式是一个非常有趣的设计模式，它将请求与请求的调用者解耦，使得我们无需关心到底请求是如何被执行的，我们只需要关注它的执行结果就行了。另外命令模式还将请求封装成了一个统一的形式（都有一个共同的接口），使得我们在面向命令编写代码的时候能够简化代码。提高代码的可读性和可维护性。和命令模式比较像的一个模式是模板方法模式，它是将好多方法封装到一个公共的方法里面，是的客户端无需知道具体方法里面细节是什么就可以方便地完成自己所需的功能。 设计模式GitHub仓库地址：https://github.com/QinJiangbo/DesignPatterns","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"命令模式","slug":"命令模式","permalink":"http://qinjiangbo.com/tags/命令模式/"}]},{"title":"谈时间的高效管理","slug":"talk-of-effective-time-management","date":"2017-02-28T14:07:42.000Z","updated":"2017-03-01T13:08:20.000Z","comments":true,"path":"talk-of-effective-time-management.html","link":"","permalink":"http://qinjiangbo.com/talk-of-effective-time-management.html","excerpt":"","text":"每天都在紧张地学习工作，却忘了“时间”这个东西一直都在身边。最近突然想到“时间”这个词，发现时间的分配对于学习工作的效率影响极大。和朋友也谈了关于时间的管理，故将所思所想记录成文。另外如果本文能对你有所启发，甚幸！ 我的时间管理观一个善于管理自己时间的人会将自己的生活过得有条不紊。一个不会管理自己时间的人可能一天到晚都在忙忙碌碌但是却没有任何收获。时间得用到对的地方，其实这个目标挺难的，不是每一个人都能将时间用到对的地方。举个简单的例子，对于上班族来说，即使在项目到了最为关键的攻坚阶段，也很有可能忍不住刷刷朋友圈；对于学生党来说，即使明天就是期末考试，也有可能在自习室复习的时候刷刷QQ空间和微博。相比大家都有共同的感受就是，刷朋友圈和微博以及QQ空间是一件非常浪费时间的事情（微商除外，因为他们在工作）。 其实说到这里，答案很明显了，社交网络。社交网络会在我们不经意间悄悄夺走我们大量的时间，然而这一切我们都不能及时察觉。以前听朋友说过一句话，“烟花过后，有谁知道天空的寂寞”。其实和我们在工作学习时不自觉使用社交网络的状态很像，刷了很久的微博和朋友圈，回过头来工作时，内心只剩下一片空虚。空虚是最直接的感受，而内不内疚完全取决个人是否珍惜这个时间。 其实截止到写这篇文章的时候，我都没有完全做到能在学习的时候不拿起手机偷瞄一眼。但是现在相比过去已经很少了，正常学习工作的时候几乎不怎么会拿起手机，Give me five！相信不仅仅是对我，工作学习时减少看手机对大家也是一个应该努力调整的习惯和追求的目标。 在对的时间做最正确的事情才能将时间的效益最大化。这里我和朋友聊天的时候谈到过一个“有效时间”的概念。不管你一天在实验室待多久，真正有效的时间是多少？算了一下，平均是8.5/12，也就是说中间有将近1/3的时间是一些杂碎的时间，比如中午出去吃饭，晚上出去吃饭，还有休息的时间，都算在里面将近3个半小时。也就是说有效时间只有不到8个半小时，在这8个半小时里面，你能产生的最大效益就是你今天在实验室里面学习的收获。刚性时间没法控制，弹性时间须要争取。 计划永远赶不上变化关于制定计划，我三年前还会相信这个说法，但是现在我觉得不靠谱。我并不是反对制定计划，有计划当然是好事，工作学习有目标，能有的放矢。但是制定计划需要到什么程度很重要。我的想法是不要定死计划，也就是刚性计划。我说说我本科大二时候的一个计划表： 项目名称 时间表 CNN Student News 07:45—-08:25 Breakfast 08:30—-09:00 线性代数 09:10—-10:30 C#程序设计 10:50—-11:30 Lunch 11:40—-12:00 …. …. 结果可想而知，详细到这个程度的计划表让我在制定计划表后面的一个月累的半死，实在是难以坚持下去，放弃了。这让我的自信心备受打击，因为好好计划的事情愣是没完成。可能你会觉得这样有点SB，没错，没踩过坑就不会知道坑有多深。 千万不要将计划详细到这个地步，没必要！因为说实话，你也难坚持下去。我现在的做法是，不做计划，让它留在心中，换句话说就是计划周期要稍微有一定时间跨度，一般我是以一个月为一个周期。发现这个周期反正是挺合适我的，每个人的情况不一样，你需要根据自己的实际情况来定一个自己的周期。但周期千万不要太短！我就是一个先例，我就是一个先例，我就是一个先例，重要的话已经说了三遍！ 碎片化时间很宝贵这里说的碎片化时间实际上并不是我们指我们在公司工作的时间，或者说我们在实验室，自习室科研学习的时间。而是一些“需要打发的”时间。啥意思？举个简单的例子，你从公司出来，要做地铁或者公交回家（开车的土豪除外），一般在路上也得有15分钟或者半个小时吧，这个时候就可以看一些自己以前一直想看但一直没时间看的视频或者书籍。别看十五分钟或者半个小时很短，如果每一天都坚持做到这样，效果是显然的。 需要注意的是，很多娱乐视频也只有5分钟左右，它们也是瞅准了用户的碎片化时间。我不主张大家一定要看技术文献啥的，这个鸡汤我不灌。说实话，如果工作很累或者学习科研很累，看一下这些娱乐视频放松放松不也是另一种提升自己的生产力的方式么？偷偷说一下，对于短视频这类，我比较喜欢看秒拍里面的“搞笑”模块~嗯~知道就行，请不要鄙视我~~~ 定好各项任务的优先级“First thing first！”这句话一点也没错。在忙得不可开交的状态下，必须要确立各个任务的优先级。如果你有大量的时间来完成所有的事情就当我这句话没说。但通常情况大家往往是想的多，做得少。这句话不是贬义，或者换句话说叫“心有余而力不足”，这反映一个实际情况，就是因为时间有限，我们往往想多事情太多，不能在这有限的时间里面完成，只能做其中很少的一部分。 时间是客观存在的，我们没法改变，想做的事情太多也没法改变。唯一能变的就是做什么？什么先做什么后做？答案就是本小节的第一句话“First thing first！”重要的事情先做！这样所获得的效益才是最大化的。这里就不讨论效益是局部最优还是整体最优了哈！感兴趣自己看看算法~ 如何认定哪些任务是比较重要而哪些任务相对来讲并没有那么重要呢？有一个方法你可以尝试一下，就是将这些想做的事情和自己接下来半年内或者一年内要做的事情进行一个拟合。将必须做的事情按照时间的先后顺序排序，那么可以看到，最重要的就是排在最靠近你当前时间的这个任务，其它的按照相同的方式可以得到。 总结此刻是3月1号凌晨1：51分，有点迷糊啊，如果文章中有哪些观点不对的，你就权当我在说梦话，别介意，同时也欢迎留言给我批评指正！祝好！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"时间管理","slug":"时间管理","permalink":"http://qinjiangbo.com/tags/时间管理/"}]},{"title":"（译）Java向文件中追加内容","slug":"append-contents-to-files-in-java","date":"2017-02-25T12:01:13.000Z","updated":"2017-02-25T12:14:24.000Z","comments":true,"path":"append-contents-to-files-in-java.html","link":"","permalink":"http://qinjiangbo.com/append-contents-to-files-in-java.html","excerpt":"","text":"Replace vs Append/Add如果你想要你的代码能够创建一个新的文件或者是清空之前已存在的一个文件内容，FileWriter能够简单地替代这些代码。为了替换一个文件中的所有内容，你可以这么做： 1FileWriter fstream = new FileWriter(loc); 如果已经存在的文件名字和正在写入的文件名字重复了的话，上面的代码会删除已经存在的这个文件。 为了向一个已经存在的文件追加或者添加内容，仅需要像下面一样指定第二个参数为true即可。 1FileWriter fstream = new FileWriter(loc, true); 这样的话，上述的代码就能够保证将数据追加至已经存在的文件当中而不是创建一个新的版本（的文件）。 完整的代码示例下面是一段完整的代码示例，这段代码其实没什么特别的，只是为了大家快速查阅。 1234567891011121314151617181920import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;import java.io.IOException; public class Main &#123; public static void main(String[] args) throws IOException &#123; File dir = new File(\".\"); String loc = dir.getCanonicalPath() + File.separator + \"Code.txt\"; FileWriter fstream = new FileWriter(loc, true); BufferedWriter out = new BufferedWriter(fstream); out.write(\"something\"); out.newLine(); //close buffer writer out.close(); &#125;&#125; 译者记在Guava中其实还有更多类似于这样的方法，极大地提升了我们的编程效率！欢迎访问本站的Guava教程。 译文原文地址：http://www.programcreek.com/2011/03/java-appendadd-something-to-an-existing-file/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qinjiangbo.com/tags/Java/"},{"name":"IO","slug":"IO","permalink":"http://qinjiangbo.com/tags/IO/"}]},{"title":"（译）Java一行一行写入文件","slug":"write-to-file-line-by-line","date":"2017-02-25T10:48:31.000Z","updated":"2017-02-25T12:14:29.000Z","comments":true,"path":"write-to-file-line-by-line.html","link":"","permalink":"http://qinjiangbo.com/write-to-file-line-by-line.html","excerpt":"","text":"这篇博客总结了能够用来将数据写入一个文件的一些类。 1. FileOutputStream12345678910111213public static void writeFile1() throws IOException &#123; File fout = new File(\"out.txt\"); FileOutputStream fos = new FileOutputStream(fout); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos)); for (int i = 0; i &lt; 10; i++) &#123; bw.write(\"something\"); bw.newLine(); &#125; bw.close();&#125; 这个例子使用了FileOutputStream类，相反你可以使用对文本文件操作更加友好的FileWriter类和PrintWriter类。 2. FileWriter123456789public static void writeFile2() throws IOException &#123; FileWriter fw = new FileWriter(\"out.txt\"); for (int i = 0; i &lt; 10; i++) &#123; fw.write(\"something\"); &#125; fw.close();&#125; 3. PrintWriter123456789public static void writeFile3() throws IOException &#123; PrintWriter pw = new PrintWriter(new FileWriter(\"out.txt\")); for (int i = 0; i &lt; 10; i++) &#123; pw.write(\"something\"); &#125; pw.close();&#125; 4. OutputStreamWriter123456789101112public static void writeFile4() throws IOException &#123; File fout = new File(\"out.txt\"); FileOutputStream fos = new FileOutputStream(fout); OutputStreamWriter osw = new OutputStreamWriter(fos); for (int i = 0; i &lt; 10; i++) &#123; osw.write(\"something\"); &#125; osw.close();&#125; 5. 它们的不同Java文档中说： FileWriter类是一个很适合写入字符文件的类。这个类的构造函数已经默认了文件的编码方式和字节缓冲数组的大小是可以接受的。如果想要手动指定这些值，你可以使用FileOutputStream来构造一个OutputStreamWriter类的对象。 PrintWriter类会将类按照既定的格式输出到文本文件当中。这个类实现了所有在PrintStream接口中的打印方法。它不包含写入原生字节的方法，因为一个程序需要使用未编码的字节流。 主要的区别就是PrintWriter类提供了一些额外的方法用来处理格式，比如println和printf。另外，FileWriter会在I/O失败时抛出IOException的异常。PrintWriter的方法不会抛IOException的异常，相反它会使用一个布尔型的信标（flag），而这个信标可以使用checkError()方法来标识错误。在每写入一字节的数据后PrintWriter都会自动地调用flush（清空）方法。在使用FileWriter类的时候，调用者需要小心调用flush方法。 译者记在Guava中其实还有更多类似于这样的方法，极大地提升了我们的编程效率！欢迎访问本站的Guava教程。 译文原文地址：http://www.programcreek.com/2011/03/java-write-to-a-file-code-example/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qinjiangbo.com/tags/Java/"},{"name":"IO","slug":"IO","permalink":"http://qinjiangbo.com/tags/IO/"}]},{"title":"（译）Java一行一行读取文件","slug":"read-content-line-by-line","date":"2017-02-25T10:47:57.000Z","updated":"2017-02-26T01:30:47.000Z","comments":true,"path":"read-content-line-by-line.html","link":"","permalink":"http://qinjiangbo.com/read-content-line-by-line.html","excerpt":"","text":"Java类里面关于输入输出（IO）这一块的类实在是太多了，以致于我们经常会感到迷惑到底使用哪一个类来完成我们的功能。下面的代码是介绍如何来使用Java IO类完成一行一行读取文件的需求。 方法一： 12345678910111213private static void readFile1(File fin) throws IOException &#123; FileInputStream fis = new FileInputStream(fin); // 通过InputStreamReader来构造BufferedReader对象 BufferedReader br = new BufferedReader(new InputStreamReader(fis)); String line = null; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; br.close();&#125; 方法二： 1234567891011private static void readFile2(File fin) throws IOException &#123; // 通过FileReader来构造BufferedReader对象 BufferedReader br = new BufferedReader(new FileReader(fin)); String line = null; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; br.close();&#125; 使用下面的代码来测试： 123456//use . to get current directoryFile dir = new File(\".\");File fin = new File(dir.getCanonicalPath() + File.separator + \"in.txt\"); readFile1(fin);readFile2(fin); 实践证明这两个代码都能很好地一行一行读取文本内容。 这两个方法的主要区别想必大家也能知道了，那就是构造一个BufferedReader对象时使用的参数不同。方法一使用的是InputStreamReader来构造的，而方法二使用的是FileReader来构造的。那么使用这两个不同的类具体有什么不同呢？ 由Java文档可知，”An InputStreamReader is a bridge from byte streams to character streams: It reads bytes and decodes them into characters using a specified charset.”意思就是InputStreamReader类是字节流到字符流的桥梁：它读取字节然后使用特定的字符集将它们转换为对应的字符。InputStreamReader类不仅仅只能够文件的输入流，它还可以处理其它的输入流，比如说网络连接，类路径资源，ZIP文件等等。 FileReader类是”Convenience class for reading character files. The constructors of this class assume that the default character encoding and the default byte-buffer size are appropriate.” 意思是FileReader类是一个很便于读取字符文件的类。这个类的构造函数已经假定默认的字符编码方式和默认的字节缓冲数组大小是合理的。FileReader类允许你自己指定一个编码方式，除了使用平台默认的编码方式。因此，如果你的代码要在不同编码平台的系统上进行运行使用这个方式可能就不是个好主意。 总的来说，InputStreamReader总是比FileReader更安全的一个选择。 有必要在这里提醒大家一下，不管什么时候，在文件路径中都推荐大家使用File.separator的方式，而不是使用具体的/或\\\\。因为前一种方式不管在哪个平台，哪个操作系统，它都能保证这个路径的格式永远是正确的。另外，使用的文件路径最好也要写成相对路径。 更新在Java1.7以后，你也可以使用下面的方式。重要的是，它和方法一其实是等效的。 123456789Charset charset = Charset.forName(\"US-ASCII\");try (BufferedReader reader = Files.newBufferedReader(file, charset)) &#123; String line = null; while ((line = reader.readLine()) != null) &#123; System.out.println(line); &#125;&#125; catch (IOException x) &#123; System.err.format(\"IOException: %s%n\", x);&#125; 我们来具体看看newBufferedReader(file, charset)方法干了什么： 12345public static BufferedReader newBufferedReader(Path path, Charset cs)&#123; CharsetDecoder decoder = cs.newDecoder(); Reader reader = new InputStreamReader(newInputStream(path), decoder); return new BufferedReader(reader);&#125; 译者记和第一种方法一样吧？在Guava中其实还有更多类似于这样的方法，极大地提升了我们的编程效率！欢迎访问本站的Guava教程。 译文原文地址：http://www.programcreek.com/2011/03/java-read-a-file-line-by-line-code-example/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qinjiangbo.com/tags/Java/"},{"name":"IO","slug":"IO","permalink":"http://qinjiangbo.com/tags/IO/"}]},{"title":"macOS下pip3安装scrapy错误","slug":"scrapy-error-in-pip3-at-macos","date":"2017-02-24T06:35:55.000Z","updated":"2017-02-24T06:55:11.000Z","comments":true,"path":"scrapy-error-in-pip3-at-macos.html","link":"","permalink":"http://qinjiangbo.com/scrapy-error-in-pip3-at-macos.html","excerpt":"","text":"一直比较依赖IDE，是一个工具控，因为好的工具能提升工作的效率。但是今天发现PyCharm有一个设置把我给坑了（咋不说你自己不小心呢？）。就是使用PyCharm安装Python的第三方依赖包的时候发生了一个神奇的事情。正如标题所说，安装scrapy的标准做法是： 1pip3 install scrapy 但是我使用PyCharm直接安装的，发现并不能像官网那样直接使用scrapy命令来创建项目。而是报了一个错： 1zsh: command not found: scrapy 怎么会呢？？？明明刚刚装了的啊？？？查看项目结构发现一个严重的问题：就是位置安装错误。先看项目结构： 居然存在两个site-packages目录！！！仔细一看，下面这个有一个library root提示。莫非是安装在了用户的目录下，导致环境变量中找不到这个包的路径。肯定是用PyCharm安装的时候装错了。再看PyCharm的设置，果然是的。 需要将上图中的这个install to user’s site packages directory (/Users/Richard/.local)勾掉（就是让它不选中），然后将Scrapy卸载重新安装就可以了。其他的包如果没有在命令行下启动的需求的话就勾选这个选项，对项目没影响的。 123456789101112131415161718192021→ scrapyScrapy 1.3.2 - no active projectUsage: scrapy &lt;command&gt; [options] [args]Available commands: bench Run quick benchmark test commands fetch Fetch a URL using the Scrapy downloader genspider Generate new spider using pre-defined templates runspider Run a self-contained spider (without creating a project) settings Get settings values shell Interactive scraping console startproject Create new project version Print Scrapy version view Open URL in browser, as seen by Scrapy [ more ] More commands available when run from project directoryUse \"scrapy &lt;command&gt; -h\" to see more info about a command","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Python","slug":"开发技术/Python","permalink":"http://qinjiangbo.com/categories/开发技术/Python/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"http://qinjiangbo.com/tags/scrapy/"},{"name":"error","slug":"error","permalink":"http://qinjiangbo.com/tags/error/"}]},{"title":"预加载让页面生动起来","slug":"web-page-preloading","date":"2017-02-21T11:36:06.000Z","updated":"2017-02-21T13:12:36.000Z","comments":true,"path":"web-page-preloading.html","link":"","permalink":"http://qinjiangbo.com/web-page-preloading.html","excerpt":"","text":"随着现在网站数量的爆炸式增长，越来越多的用户感到了信息爆炸带来的压力。互联网企业如何让自己的网站在如此众多的网站中脱颖而出，不仅需要自身强劲的企业实力，还需要一个好看的“门面”，这里指的是网站的UI或者App的UI。本文主要是探讨网络情况不佳时如何让用户的体验不那么糟糕？虽然这个要求比较急切，但是很多企业根本就不重视，这样是不好滴！今天就跟大家聊一聊网站的预加载。 作品赏析在进行深入的讨论之前我们先看一看国外的优秀网站是如何进行预加载的设计的。这对我们设计自己的网页有非常大的启发。 TINIA 点击查看Demo Orthosie 点击查看Demo JOVIAL 点击查看Demo Dies-Pater 点击查看Demo EUPORIE 点击查看Demo TARA 点击查看Demo 审查代码在Chrome打开这些网站，在控制台选中正在加载中的页面，我们不难看出，他们都在每一个页面中加入了一段相同的代码。 图片中代码如下： 12345678910&lt;div class=\"mk-body-loader-overlay page-preloader\" style=\"background-color: rgb(208, 17, 43); display: none;\"&gt;&lt;img alt=\"Tara Template - Jupiter WordPress Theme\" class=\"preloader-logo\" src=\"http://demos.artbees.net/jupiter5/tara/wp-content/uploads/sites/156/2016/12/icon-04.png\" width=\"109\" height=\"79\"&gt; &lt;div class=\"preloader-preview-area\"&gt; &lt;div class=\"ball-pulse-sync\"&gt; &lt;div style=\"background-color: #ffffff\"&gt;&lt;/div&gt; &lt;div style=\"background-color: #ffffff\"&gt;&lt;/div&gt; &lt;div style=\"background-color: #ffffff\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 可以看到，上面的代码是在每一个页面最开始加载的时候执行的，它的组成部分主要是一张背景图（大多是纯色背景，也可以有图案），还有一个加载动画组成。加载动画的形式可以多种多样，在上面的示例图中可以看到。 代码实现预加载主要是通过JavaScript和CSS3一起实现：其中稍微要点挑战性的部分就是动画的实现。还是以上面的代码块为例，来看看它的动画是如何实现的： CSS实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162.ball-pulse-sync &#123; display: inline-block&#125;.ball-pulse-sync&gt;div &#123; width: 15px; height: 15px; border-radius: 100%; margin: 2px; -webkit-animation-fill-mode: both; animation-fill-mode: both; display: inline-block&#125;.ball-pulse-sync&gt;div:nth-child(1) &#123; -webkit-animation: ball-pulse-sync .6s -.21s infinite ease-in-out; animation: ball-pulse-sync .6s -.21s infinite ease-in-out&#125;.ball-pulse-sync&gt;div:nth-child(2) &#123; -webkit-animation: ball-pulse-sync .6s -.14s infinite ease-in-out; animation: ball-pulse-sync .6s -.14s infinite ease-in-out&#125;.ball-pulse-sync&gt;div:nth-child(3) &#123; -webkit-animation: ball-pulse-sync .6s -70ms infinite ease-in-out; animation: ball-pulse-sync .6s -70ms infinite ease-in-out&#125;@-webkit-keyframes ball-pulse-sync &#123; 33% &#123; -webkit-transform: translateY(10px); transform: translateY(10px) &#125; 66% &#123; -webkit-transform: translateY(-10px); transform: translateY(-10px) &#125; 100% &#123; -webkit-transform: translateY(0); transform: translateY(0) &#125;&#125;@keyframes ball-pulse-sync &#123; 33% &#123; -webkit-transform: translateY(10px); transform: translateY(10px) &#125; 66% &#123; -webkit-transform: translateY(-10px); transform: translateY(-10px) &#125; 100% &#123; -webkit-transform: translateY(0); transform: translateY(0) &#125;&#125; JavaScript实现： 1234567891011121314function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; if (oldonload) &#123; oldonload(); &#125; func(); &#125; &#125;&#125;addLoadEvent(preloader); // preloader为预加载函数，这里大家自己定义 后记在预加载页面的实现上，需要知道预加载时发生在什么时候的。一般来说，页面的加载分为以下几个步骤： 解析HTML结构。 加载外部脚本（JavaScript）和样式表文件（CSS）。 解析并执行脚本代码。 构造HTML DOM模型。// ready阶段 加载图片等外部文件。 页面加载完毕。// load阶段 所以，我们可以看到，预加载页面中如果要使用图片的话，我们只能将事件写入到windows.load()中去。如果没有图片的加载，大家可以写到windows.ready()中去，这样会快一点。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"前端","slug":"开发技术/前端","permalink":"http://qinjiangbo.com/categories/开发技术/前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://qinjiangbo.com/tags/HTML/"},{"name":"预加载","slug":"预加载","permalink":"http://qinjiangbo.com/tags/预加载/"}]},{"title":"CentOS7安装redis集群QA","slug":"qa-of-redis-installations-in-centos7","date":"2017-02-20T10:06:31.000Z","updated":"2017-02-20T12:04:14.000Z","comments":true,"path":"qa-of-redis-installations-in-centos7.html","link":"","permalink":"http://qinjiangbo.com/qa-of-redis-installations-in-centos7.html","excerpt":"","text":"前一篇博客讲了如何来安装redis集群，那么本片博客主要讨论可能出现的各种问题。 issue1: ERR Invalid node address specified启动集群的时候如果使用hostname的话会报这个错误。这是由于redis-trib.rb对域名或主机名支持不好，故在创建集群的时候要使用ip:port的方式。 1redis-trib.rb create ip1:port1 ip2:port2 ip3:port3 issue2: ERR slot 0 is already busy (redis::commanderror)这是因为上一次失败的配置文件没有被删除，所以会导致这个问题的存在。这里推荐大家将redis目录下的appendonly.aof，dump.rdb以及nodes-6379.conf等文件全部删除。 issue3: Waiting for the cluster to join……..无限的等待，博主之前就是这个问题耽误了好久。这个问题主要还是管理机和节点机之间没有连接成功。原因两种： 防火墙屏蔽，可以在防火墙中加入相关的端口, xxxx以及xxxx+10000。 redis.conf中bind设置更改一下，改为它的真实地址，比如局域网地址192.168.131.141而不要使用内部环路地址127.0.0.1。 issue4: [ERR] Node XXXXXX is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0这个也是因为上一次失败的配置文件没有被删除，所以会导致这个问题的存在。推荐大家将redis目录下的appendonly.aof，dump.rdb以及nodes-6379.conf等文件全部删除。 好了，目前就这四个问题，后面如果还有新的问题我再更新！","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qinjiangbo.com/tags/Linux/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://qinjiangbo.com/tags/Hadoop/"}]},{"title":"CentOS7安装redis集群指南","slug":"guide-of-redis-installations-in-centos7","date":"2017-02-20T10:04:39.000Z","updated":"2017-02-20T11:28:44.000Z","comments":true,"path":"guide-of-redis-installations-in-centos7.html","link":"","permalink":"http://qinjiangbo.com/guide-of-redis-installations-in-centos7.html","excerpt":"","text":"写在前面先说一说为什么要写这一篇博客，主要是因为今天在配置redis集群的时候被恶心到了，各种杂七杂八的问题一涌而现，搞得我摸不着北。写这篇博文主要是起一个记录的作用，以免自己日后再遇到此类问题时不知所措，浪费时间。网上的一些博客大多数都写的是单机上的多个实例的情况，这个不符合实际的生产环境要求，所以本文按照完全分布式的情况来部署。本博客的Q&amp;A环节放在下一篇博客里面。现在按照常规的步骤来走一遍。 环境准备博主的操作环境是四台Linux服务器，版本都是CentOS 7 64bit。其中一台是管理机，另外三台是节点机。IP地址分别是，管理机（192.168.131.140），节点机1（192.168.131.141），节点机2（192.168.131.142），节点机3（192.168.131.143）。 配置安全环境CentOS 7默认是没有iptables服务的，好像变成了一个新的叫firewalld的服务。我们还是建议用户使用iptables服务，具体通过yum来安装： 1yum -y install iptables-services 其中，-y表示自动应答，免得安装过程中一直询问是否继续。 先关闭selinux安全设置，免得后面添加iptables服务失败。 1vim /etc/selinux/config 更改SELINUX的值为disabled。 1234567891011# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=disabled# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected.# mls - Multi Level Security protection.SELINUXTYPE=targeted 然后将iptables添加到系统启动项并开启它。 12systemctl enable iptablessystemctl start iptables 关于iptables是否需要开启存在一些争议，有些人认为需要直接关闭防火墙，这样后面节点之间就可以直接通了，但是出于企业安全的考虑，大多数公司是不会关闭它的，所以需要我们加上这个。当然了，关闭iptables的命令很简单（当前不推荐关闭）： 1systemctl stop iptables 安装zlib依赖包redis的安装需要依赖zlib包，所以我们先得安装好zlib包。采用yum安装非常简单。 1yum -y install zlib 安装ruby运行环境后面启动整个集群需要使用到ruby编写的脚本，所以有必要先创建好ruby运行环境。一样的使用yum安装。 1yum -y install ruby 安装redis集群这里推荐采用源码安装，因为可配置性更高。采用yum安装会有很多不方便的地方，比如添加一个新的redis实例。 在每一台机器Linux服务器里面分别使用wget工具从这里http://download.redis.io/releases/redis-3.2.6.tar.gz下载好redis的源码包。如果没有wget工具，采用yum先安装一个。 12yum -y install wgetwget http://download.redis.io/releases/redis-3.2.6.tar.gz 现在好以后，当前目录就会存在一个redis-3.2.6.tar.gz压缩文件。先解压，再安装。建议将其安装到一个/usr/local/目录下，因为这个目录是比较通用的一个目录。在里面创建一个文件夹redis_cluster。 1234tar -zxvf redis-3.2.6.tar.gzcd redis-3.2.6mkdir -p /usr/local/redis_clustermake install PREFIX /usr/local/redis_cluster 安装好了以后在/usr/local/redis_cluster目录下就会存在一个生成的bin文件夹，里面包含这些文件。redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-sentinel redis-server，将之前解压的文件夹redis-3.2.6中的redis.conf拷贝到/usr/local/redis_cluster中。 1cp redis.conf /usr/local/redis_cluster 好这一步安装完成。 安装gem-redis插件安装完ruby之后其实会存在一个rubygem插件管理工具，这里我们需要安装操作redis的工具。很简单，一行命令就搞定了。 1gem install redis 设置redis集群我们的目标是什么？[没有蛀牙]。我们的目标是一个管理机，三个节点机。然后每一个节点机当中起两个redis实例，也就是说，3台节点机，6个实例。 根据前面的步骤，redis已经成功安装完毕了，但是只有一个实例。就是端口为6379的实例。我们分别在三台节点机里面新建两个目录： 123cd /usr/local/redis_clustermkdir -p 6379mkdir -p 6380 并将刚刚安装的redis_cluster目录中的文件分别拷贝到文件夹6379和6380中。 123456cp -r bin 6379cp redis.conf 6379cp -r bin 6380cp redis.conf 6380rm -rf binrm -rf redis.conf 注意每一台节点机上都需要进行这个操作。 修改配置文件由于我们在一台设备上起了两个实例，所以端口不能冲突。文件夹6379和6380分别设置为他们文件名对应的端口号。因此，进入文件夹6379和文件夹6380修改redis.conf文件的内容是有区别的。 以节点机1（192.168.131.141）的文件夹6380为例，修改redis.conf中的下列选项： 1234567port 6380 # 对应端口bind 192.168.131.141 # 对应IP地址daemonize yescluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000appendonly yes 其他节点机按照这个对应地改就行了，重点是端口和bind的IP地址不能搞错。 添加iptables端口过滤由于redis集群内部通讯的时候会使用它的实例端口xxxx和总线端口10000+xxxx。因此，在每一台节点机上面，我们除了需要加上6379和6380两个过滤规则外，还需要添加16379和16380两个过滤规则。 打开/etc/sysconfig/iptables按照上面的22号端口的格式来添加： 123456789101112131415161718# sample configuration for iptables service# you can edit this manually or use system-config-firewall# please do not ask us to add additional ports/services to this default configuration*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 6379 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 6380 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 16379 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 16380 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT 保存退出。重新启动iptables。 1systemctl restart iptables 启动每一个redis实例在下面每一个节点机上启动redis实例。 节点机1（192.168.131.141）节点机2（192.168.131.142）节点机3（192.168.131.143） 126379/bin/redis-server 6379/redis.conf &amp;6380/bin/redis-server 6380/redis.conf &amp; 在管理机上创建redis集群还记得之前下载的redis-3.2.6文件夹么，打开它，找到里面的src文件夹，将redis-trib.rb，redis-server以及redis-cli拷贝到/usr/local/bin/下面。 然后直接启动集群 123redis-trib.rb create --replicas 1 192.168.131.141:6379192.168.131.141:6380 192.168.131.142:6379192.168.131.142:6380 192.168.131.143:6379 192.168.131.143:6380 可以看到以下信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&gt;&gt;&gt; Creating cluster&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:192.168.131.141:6379192.168.131.142:6379192.168.131.143:6379Adding replica 192.168.131.142:6380 to 192.168.131.141:6379Adding replica 192.168.131.141:6380 to 192.168.131.142:6379Adding replica 192.168.131.143:6380 to 192.168.131.143:6379M: fa18d9e08a38adb66b353a87833a874188604c02 192.168.131.141:6379 slots:0-5460 (5461 slots) masterS: 919e1155c9f93892cb5484fb44b85f8097f7aaea 192.168.131.141:6380 replicates f3cbfc4cf2f01041c340dbf6363e7bcfa06c6a1eM: f3cbfc4cf2f01041c340dbf6363e7bcfa06c6a1e 192.168.131.142:6379 slots:5461-10922 (5462 slots) masterS: df94fa0b43786db04413cef4effbb948f51e8d95 192.168.131.142:6380 replicates fa18d9e08a38adb66b353a87833a874188604c02M: ad4ea1bdfcdeec8e7e5e76fc46b315fcc122629b 192.168.131.143:6379 slots:10923-16383 (5461 slots) masterS: 744ccd205b0f817fd0346c19225ee3d1dc441c67 192.168.131.143:6380 replicates ad4ea1bdfcdeec8e7e5e76fc46b315fcc122629bCan I set the above configuration? (type 'yes' to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node[root@master ~]# redis-trib.rb create --replicas 1 192.168.131.141:6379 192.168.131.141:6380 192.168.131.142:6379 192.168.131.142:6380 192.168.131.143:6379 192.168.131.143:6380&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join.....&gt;&gt;&gt; Performing Cluster Check (using node 192.168.131.141:6379)M: fa18d9e08a38adb66b353a87833a874188604c02 192.168.131.141:6379 slots:0-5460 (5461 slots) master 1 additional replica(s)M: f3cbfc4cf2f01041c340dbf6363e7bcfa06c6a1e 192.168.131.142:6379 slots:5461-10922 (5462 slots) master 1 additional replica(s)S: 744ccd205b0f817fd0346c19225ee3d1dc441c67 192.168.131.143:6380 slots: (0 slots) slave replicates ad4ea1bdfcdeec8e7e5e76fc46b315fcc122629bS: df94fa0b43786db04413cef4effbb948f51e8d95 192.168.131.142:6380 slots: (0 slots) slave replicates fa18d9e08a38adb66b353a87833a874188604c02M: ad4ea1bdfcdeec8e7e5e76fc46b315fcc122629b 192.168.131.143:6379 slots:10923-16383 (5461 slots) master 1 additional replica(s)S: 919e1155c9f93892cb5484fb44b85f8097f7aaea 192.168.131.141:6380 slots: (0 slots) slave replicates f3cbfc4cf2f01041c340dbf6363e7bcfa06c6a1e[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 表示创建成功。 总结本片博客记录了如何安装redis集群，博主踩的坑是将redis.conf文件中的bind选项设置错误，设置成了bind 127.0.0.1 192.168.131.141这样，启动集群的时候每一次都会将结点的监听ip改写为127.0.0.1，所以这里需要去掉127.0.0.1，不然就要像我这样，找一天了。关于安装过程中可能会出现的各种问题，我们在下一篇博客里讨论。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qinjiangbo.com/tags/Linux/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://qinjiangbo.com/tags/Hadoop/"}]},{"title":"CentOS7 SSH免登录配置","slug":"ssh-non-login-configurations","date":"2017-02-19T04:46:37.000Z","updated":"2017-02-19T05:32:19.000Z","comments":true,"path":"ssh-non-login-configurations.html","link":"","permalink":"http://qinjiangbo.com/ssh-non-login-configurations.html","excerpt":"","text":"之前写过一篇关于SSH免登录的文章，不过那个是专门针对hadoop来设置的，感觉写的不是很详细，所以重新写一篇操作更具体的文章。供大家参考参考。本文的操作环境是CentOS7系统，一共有四台服务器，分别被命名为master，slave1， slave2以及slave3。 设置hostname在CentOS7中，hosts文件的所在地是/etc/hosts里面，大家直接使用vim工具将这个hosts文件打开，配置方式同windows或者mac一样。下面给出一个范例： 123456127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.131.140 master192.168.131.141 slave1192.168.131.142 slave2192.168.131.143 slave3 大家可以根据自己的实际情况进行相应地修改。 配置SSH免登录使用一个工具ssh-keygen在每一台机器上生成对应的私钥和公钥。命令为ssh-keygen -t rsa -P &quot;&quot;，然后一路回车就行： 12345678910111213141516171819ssh-keygen -t rsa -P \"\"Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:a0:0d:8a:b4:dd:e7:92:6f:44:25:36:9a:5b:75:10:a8 root@masterThe key's randomart image is:+--[ RSA 2048]----+| .oo || = o . || . . * = . ||..o..E + ||......=.S || .+. || o.. || o. || .. |+-----------------+ 按照同样的命令，在三台从服务器上分别生成对应的公钥和私钥。接下来就是将这些公钥拷贝到主服务器上来。 123scp ~/.ssh/id_rsa.pub root@master:~/.ssh/id_rsa.pub.slave1scp ~/.ssh/id_rsa.pub root@master:~/.ssh/id_rsa.pub.slave2scp ~/.ssh/id_rsa.pub root@master:~/.ssh/id_rsa.pub.slave3 接着将这些拷贝过来的公钥保存在主服务器的公钥文件~/.ssh/authorized_keys中。 1cat ~/.ssh/id_rsa.pub* &gt;&gt; ~/.ssh/authorized_keys 然后将这个公钥文件分发给每一个从服务器。 123scp ~/.ssh/authorized_keys root@slave1:~/.ssh/scp ~/.ssh/authorized_keys root@slave2:~/.ssh/scp ~/.ssh/authorized_keys root@slave3:~/.ssh/ 好了。 测试SSH免登录在每一台主机上面分别使用ssh命令来登录其他三台机器，看能否成功？ 1234[root@slave1 ~]# ssh masterLast login: Sun Feb 19 13:08:38 2017 from slave2[root@master ~]# logoutConnection to master closed. 成功！","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qinjiangbo.com/tags/Linux/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://qinjiangbo.com/tags/Hadoop/"}]},{"title":"（译）Java高效的计数器","slug":"effective-counters-in-java","date":"2017-01-15T15:14:41.000Z","updated":"2017-02-12T04:10:44.000Z","comments":true,"path":"effective-counters-in-java.html","link":"","permalink":"http://qinjiangbo.com/effective-counters-in-java.html","excerpt":"","text":"你可能需要一个计数器来统计来自于数据库或者某个文件的一些事物（比如单词数量）。Java中使用HashMap可以很简单地实现一个计数器。本文比较了实现计数器的不同方式。最后再总结得出一个比较有效率的计数器。 1. 朴素的计数器简单地来说，可以这么实现一个计数器： 1234567891011121314String s = \"one two three two three three\";String[] sArr = s.split(\" \"); //naive approach HashMap&lt;String, Integer&gt; counter = new HashMap&lt;String, Integer&gt;(); for (String a : sArr) &#123; if (counter.containsKey(a)) &#123; int oldValue = counter.get(a); counter.put(a, oldValue + 1); &#125; else &#123; counter.put(a, 1); &#125;&#125; 在每一次循环中，你都必须得检查这个键（Key）是不是存在。如果是，就把它原本的值加上1，如果不是，就把它设置为1。这个方式很简单而且很直接，但不是最有效的方式。为什么说它不是最有效的呢？主要基于以下两个原因： containsKey()和get()这两个方法在一个键（Key）存在的时候会被调用两次。那意味着它会搜索这整个Map两次。 因为整型（Integer）是不可变的，每一次的循环都会创建一个新的对象来容纳老的值加上1的结果。 2. 更好的计数器自然地我们想要一个可变的整型数值去避免创建大量的整型对象，一个可变的整型（Integer）类可以这么定义： 123456789101112131415161718192021class MutableInteger &#123; private int val; public MutableInteger(int val) &#123; this.val = val; &#125; public int get() &#123; return val; &#125; public void set(int val) &#123; this.val = val; &#125; //used to print value convinently public String toString()&#123; return Integer.toString(val); &#125;&#125; 然后这个计数器可以这么改进： 12345678910HashMap&lt;String, MutableInteger&gt; newCounter = new HashMap&lt;String, MutableInteger&gt;(); for (String a : sArr) &#123; if (newCounter.containsKey(a)) &#123; MutableInteger oldValue = newCounter.get(a); oldValue.set(oldValue.get() + 1); &#125; else &#123; newCounter.put(a, new MutableInteger(1)); &#125;&#125; 这个看起来似乎更好，因为它不再需要创建大量的整型对象了。然而，在一次循环中，如果一个键（Key）存在的情况下它依旧需要搜索两次。 3. 高效的计数器这个HashMap.put(key, value)方法返回这个键（Key）的当前值。这是很有用的，因为我们能使用原有的值的引用来更新这个值而不需要再次搜索一遍。 12345678910HashMap&lt;String, MutableInteger&gt; efficientCounter = new HashMap&lt;String, MutableInteger&gt;(); for (String a : sArr) &#123; MutableInteger initValue = new MutableInteger(1); MutableInteger oldValue = efficientCounter.put(a, initValue); if(oldValue != null)&#123; initValue.set(oldValue.get() + 1); &#125;&#125; 4. 性能上的差异下面的代码是为了测试这三种不同方式在性能上的差异。这个性能测试进行了100万次。原始的结果如下： 123Naive Approach : 222796000Better Approach: 117283000Efficient Approach: 96374000 差异是很明显的，223 vs 117 vs 96是它们的相对耗时比值。在“天真”计数器和更好的计数器之间存在着巨大的差异，这也提示我们创建对象的开销是巨大的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061String s = \"one two three two three three\";String[] sArr = s.split(\" \"); long startTime = 0;long endTime = 0;long duration = 0; // naive approachstartTime = System.nanoTime();HashMap&lt;String, Integer&gt; counter = new HashMap&lt;String, Integer&gt;(); for (int i = 0; i &lt; 1000000; i++) for (String a : sArr) &#123; if (counter.containsKey(a)) &#123; int oldValue = counter.get(a); counter.put(a, oldValue + 1); &#125; else &#123; counter.put(a, 1); &#125; &#125; endTime = System.nanoTime();duration = endTime - startTime;System.out.println(\"Naive Approach : \" + duration); // better approachstartTime = System.nanoTime();HashMap&lt;String, MutableInteger&gt; newCounter = new HashMap&lt;String, MutableInteger&gt;(); for (int i = 0; i &lt; 1000000; i++) for (String a : sArr) &#123; if (newCounter.containsKey(a)) &#123; MutableInteger oldValue = newCounter.get(a); oldValue.set(oldValue.get() + 1); &#125; else &#123; newCounter.put(a, new MutableInteger(1)); &#125; &#125; endTime = System.nanoTime();duration = endTime - startTime;System.out.println(\"Better Approach: \" + duration); // efficient approachstartTime = System.nanoTime(); HashMap&lt;String, MutableInteger&gt; efficientCounter = new HashMap&lt;String, MutableInteger&gt;(); for (int i = 0; i &lt; 1000000; i++) for (String a : sArr) &#123; MutableInteger initValue = new MutableInteger(1); MutableInteger oldValue = efficientCounter.put(a, initValue); if (oldValue != null) &#123; initValue.set(oldValue.get() + 1); &#125; &#125; endTime = System.nanoTime();duration = endTime - startTime;System.out.println(\"Efficient Approach: \" + duration); 所以，当你使用一个计数器的时候，你可能需要一个函数根据值来排序这个Map。 译文原文地址：http://www.programcreek.com/2013/10/efficient-counter-in-java/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://qinjiangbo.com/tags/JDK8/"},{"name":"集合框架","slug":"集合框架","permalink":"http://qinjiangbo.com/tags/集合框架/"}]},{"title":"（译）Java Map集合九问","slug":"nine-questions-of-map-collection","date":"2017-01-13T02:33:23.000Z","updated":"2017-01-14T07:17:46.000Z","comments":true,"path":"nine-questions-of-map-collection.html","link":"","permalink":"http://qinjiangbo.com/nine-questions-of-map-collection.html","excerpt":"","text":"一般来说，Map就是一个包含一个或多个键值对（Key-Value Pair）的数据结构，而且每一个键（Key）不允许重复出现。本文总结了Java Map九个最常见的问题。为了通用性考虑，我在每一个例子中都使用了泛型。在例子中你可以认为K和V这两个参数都是默认实现了Comparable接口的。 1. 将Map转化为List在Java中，Map接口提供了三种集合视图：key Set, value Set以及key-Value Set。通过List的构造函数或者是addAll()方法都可以将他们转化为List列表。下面的一段代码就是展示如何使用ArrayList的构造函数将Map转化为List。 123456// key listList keyList = new ArrayList(map.keySet());// value listList valueList = new ArrayList(map.values());// key-value listList entryList = new ArrayList(map.entrySet()); 2. 迭代一个Map通过遍历每一个键值对（Key-Value Pair）来遍历一个Map是Map集合遍历中最基础的操作了。在Java中，这样的键值对（Key-Value Pair）都存储在一个叫Map.Entry的数据结构中。Map.entrySet()方法返回一个键值对集合（Key-Value Set），因此，最有效的遍历Map集合中每个Entry的方式就是： 123456for(Entry entry: map.entrySet()) &#123; // get key K key = entry.getKey(); // get value V value = entry.getValue();&#125; 也可以使用迭代器，尤其是在JDK1.5以前的版本中： 12345678Iterator itr = map.entrySet().iterator();while(itr.hasNext()) &#123; Entry entry = itr.next(); // get key K key = entry.getKey(); // get value V value = entry.getValue();&#125; 3. 根据Key来排序一个Map根据键（Keys）来排序一个Map是另一个比较基础的操作。一种可行的操作就是将Map.Entry放入一个列表（List），然后通过比较器（Comparator）来排序这个列表。 123456789List list = new ArrayList(map.entrySet());Collections.sort(list, new Comparator() &#123; @Override public int compare(Entry e1, Entry e2) &#123; return e1.getKey().compareTo(e2.getKey()); &#125; &#125;); 注意：上述代码也可以使用Lambda表达式代替。 12List list = new ArrayList(map.entrySet());Collections.sort(list, (e1,e2)-&gt;e1.getKey().compareTo(e2.getKey())); 另一种方式就是使用SortedMap，它提供了一个基于键的排序机制。因此所有的键（Keys）必须实现Comparable接口或者是能被比较器（Comparator）接受。 SortedMap的另一种实现是TreeMap。它的构造函数能接受一个比较器（Comparator）。下面就展示了如何将一个普通的Map转化为一个排序的Map。 123456789SortedMap sortedMap = new TreeMap(new Comparator() &#123; @Override public int compare(K k1, K k2) &#123; return k1.compareTo(k2); &#125; &#125;);sortedMap.putAll(map); 4. 根据Value来排序一个Map把Map放入一个List或者是排序同样也都适用于基于值（Value）这种情况。但是这一次需要比较的是Entry.getValue()。 123456789List list = new ArrayList(map.entrySet());Collections.sort(list, new Comparator() &#123; @Override public int compare(Entry e1, Entry e2) &#123; return e1.getValue().compareTo(e2.getValue()); &#125; &#125;); 我们仍然可以使用一个SortedMap来解决这个问题，但是仅适用于所有的值都是唯一的情况。基于这样一个情况，你可以将键值对（Key-Value Pair）转化为值键对（Value-Key Pair）。这个解决方法有很大的限制性，所以不推荐大家使用。 5. 初始化一个不可变Map当你需要使一个Map集合不可变时，一个最佳实践就是将这个Map放入一个不可变的Map中。这种防御性编程技术将会帮助你创建一个不仅使用安全而且也线程安全的Map集合。 为了初始化一个不可变Map集合，我们可以使用一个静态初始化块（如下）。这个方法的问题就是，尽管Map已经被声明为了static final，我们仍然可以在它初始化完毕后修改它的内容。比如Test.map.put(3, &quot;three&quot;);。所以，这个并不是正真的不可变。通过静态初始化块去创建一个不可变的Map集合，我们需要额外的匿名类并且在初始化完毕的最后一步把它拷贝到一个不可修改的Map中。然后，当我们调用刚刚的那段代码时就会抛出UnsupportedOperationException的异常。 12345678910111213141516171819public class Test &#123; private static final Map map; static &#123; map = new HashMap(); map.put(1, \"one\"); map.put(2, \"two\"); &#125;&#125;public class Test &#123; private static final Map map; static &#123; Map aMap = new HashMap(); aMap.put(1, \"one\"); aMap.put(2, \"two\"); map = Collections.unmodifiableMap(aMap); &#125;&#125; Guava类库里面同样也支持不可变Map集合的多种初始化方式。更多关于Guava的教程请查看本博客的Guava优美代码系列。 6. HashMap，TreeMap以及HashTable之间的区别在Java中，Map接口的实现类主要有三个：HashMap，TreeMap和HashTable。它们最主要的不同主要包括以下三点： 迭代的顺序。HashMap和HashTable不保证Map的迭代顺序。确切地说，它们不保证这个迭代的顺序一直保持为恒定。但是TreeMap将会根据键（Keys）或者比较器（Comparator）的自然排序来迭代整个Map。 Key-Value键值对限制。HashMap允许出现空键（null key）和空值（null values）。（空键只允许出现一次，因为我们知道，Map的键不能出现重复。）HashTable不允许出现空键（null key）和空值（null values）。如果TreeMap使用自然排序或者它的比较器（Comparator）不允许空值的话，添加空值或者空键将会抛出异常。 同步（Synchronized）。仅HashTable是同步的，其他的两个不是。所以说，如果一个线程安全的实现在项目中并不是那么需要，推荐大家使用HashMap而不是HashTable。 更完整的比较如下： HashMap Hashtable TreeMap iteration order no no yes null key-value yes-yes no-no no-yes synchronized no yes no time performance O(1) O(1) O(log n) implementation buckets buckets red-black tree 7. 双向Map有时候我们需要一组键值对（Key-Value Pair Set），意味着这个Map的值和键一样都是不能出现重复的。也就是一对一映射（One-to-One Map）。这个限制可以让我们创建出一个双向Map。所以我们也可以根据值（Value）来查找键（Key）。这样的数据结构被称为双向Map（bidirectional map），不幸的是JDK并不支持这个结构。 在Apache Commons和Guava中这个数据结构都有实现，分别叫做BidiMap和BiMap。但是都强制键和值之间的映射关系为1:1。 8. Map的浅拷贝在Java中Map的大多数实现，都提供了一种能拷贝其他Map的构造函数。但是这个拷贝的过程并不是同步的（Synchronized）。意味着一旦有某个线程拷贝了一个Map，另外的一个县城可能会对它进行修改。所以，为了避免不同步的拷贝，大家都应该使用Collections.sysnchronizeMap()。 1Map copiedMap = Collections.synchronizedMap(map); 另一个有趣的浅拷贝就是使用clone()方法。然而这个方法连Java集合框架的设计者Josh Bloch自己都不推荐使用。在一次关于“构造函数拷贝VS克隆”的对话中他说道： 我经常在一个具体的类中提供公开的克隆方法clone()因为大家期待它。…但是很惭愧这样Cloneable就被打破了，但是它的确是发生了。…Cloneable是一个弱点，我希望大家看到它的局限性。 基于这个原因，我都不会告诉你如何利用Clone()方法去拷贝一个Map。 9. 创建一个空Map如果一个Map是不可变得，使用 1map = Collections.emptyMap(); 否则，利用任何一种实现都OK，比如 1map = new HashMap(); 完毕！ 译文原文地址：http://www.programcreek.com/2013/09/top-9-questions-for-java-map/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://qinjiangbo.com/tags/JDK8/"},{"name":"集合框架","slug":"集合框架","permalink":"http://qinjiangbo.com/tags/集合框架/"}]},{"title":"回首2016，展望2017","slug":"from-2016-to-2017","date":"2017-01-08T11:32:50.000Z","updated":"2017-01-13T02:30:38.000Z","comments":true,"path":"from-2016-to-2017.html","link":"","permalink":"http://qinjiangbo.com/from-2016-to-2017.html","excerpt":"","text":"Hi，各位小伙伴们，大家新年快乐！由于满满的论文写作安排，已经一个星期没有写博客啦，先跟大家说声对不起！但是我心里面还是一直惦记着大家啊！今天就跟大家聊聊我最近的动态以及刚刚过去的2016。 不知道各位小伙伴是如何度过2017年的元旦的呢？是出国旅游、走访亲戚、还是宅在家里，潜心学习，给自己充充电？无论是哪一种方式，我认为，心里开心最重要！2016年的最后一天，我还在忙着写面向对象程序设计的论文。研究生的生活嘛，论文是家常便饭。不过我挺享受写论文的过程，因为充分地感受到了知识的输入和输出。 2016年里发生了很多对于我很重要的事情，分别是从武汉大学本科毕业，公司实习满一年，武汉大学研究生入学，Github提交代码连击以及开通个人博客和微信公众号。这些事情让我的2016有了可圈可点的地方。 先说说从武汉大学本科毕业。记得四五月份的时候忙着写论文忙的不可开交，为了弄清楚要写的论文《社交网络影响最大化的分布式算法设计与实现》这个题目到底讲的是什么，三天两头往计算机学院大楼跑，请教博士学长相关的算法问题，第一次听说了什么是NP问题，什么是NP难问题，什么是马尔科夫链等等（原谅我当时真的是第一次）。这个题目咋一看的确不是很好明确研究方向，但是经过学长的一番讲解之后，我大概明白了。用简单的例子给小伙伴们描述这个问题吧，比如说某个游戏公司想推广一款游戏，由于预算是有限的，但是想要取得最大的推广效果，应该如何选择目标群体。那么就相当于在一个有限集合（社交网络用户）内部，如何选择一部分用户，给予他们优惠，然后通过他们的“安利”使得游戏被尽可能多的人知道（这里实际上描述的是一个传播模型）。针对这个问题主要是通过图的算法来解决的，由于图的遍历是无法有效地进行分布化处理的，所以针对图遍历的次数进行了分布式处理。每个节点负责相应次数地计算，随后汇总结果，取平均值。通过这个毕设了解到了Hadoop等大数据处理工具，收获还是挺大的。 再说说在公司实习的事情，其实从2015年就开始在公司实习啦，在公司的一年里其实是我进步飞快的一年，接触到了很多业内最前沿的开发技术和项目管理工具。一开始进入公司的时候，接触到了一个开源项目MyBatis，这是一款非常优秀的数据持久层框架，不像Hibernate那样，MyBatis很轻量，因为它对客户代码几乎没有侵略性。我问架构师，应该如何学习这个框架。他说，刚开始学习还是以熟悉功能为主，用熟用会即可。到后面我建议你研究它的源码，写得非常优秀。其实听了挺受鼓舞的，一年之后我就推出了自己的数据持久层框架OKJPA（http://qinjiangbo.com/okjpa），应该说是MyBatis的基于注解的版本吧，我个人不太喜欢XML配置。这也让我走上了源码研究的道路，而且我也会坚定地走下去。一直相信研究优秀的源码就等于向大师取经，看得多了，才能懂大师的道。 研究生生涯从9月8号研究生入学开始，见到了可爱的室友，室友间的关系是非常和谐的，因为大家都已经有本科的相处经验了嘛！研究生的生活就在忙忙碌碌的状态中度过了第一个学期。渐渐喜欢上了写作，觉得能跟大家分享自己的想法是一件很快乐而且很荣幸的事情。这里给大家说说两个写作神器。MacDown和TexPad，分别是Markdown和LaTex写作的工具。先说说Markdown写作神器MacDown，具有非常优秀的UI设计，支持多种主题，是博客写作不可多得的一款工具，关键是它还免费！现在Markdown写作已经越来越吸引大家的注意力了，尤其是几大博客平台比如CSDN，博客园，51CTO等等都已经陆陆续续推出了自己的Markdown写作工具，传统的富文本编辑器其实已经没有太大的竞争力了。TexPad是LaTex的专业写作工具，不过遗憾的是只有Mac平台才有，Windows用户可能没法使用，不过Windows平台也有非常优秀的LaTex写作工具。我已经成功安利了室友去使用LaTex进行学术写作。的确，LaTex是进行学术写作不可多得的好工具，我的五篇大论文就全部采用LaTex进行写作的，通过这么多论文的写作，现在LaTex的使用方式已经基本熟悉。也推荐给所有热爱写作的人Markdown和LaTex，研究它能给你带来无穷的惊喜！ 持续向Github提交代码是我开通个人博客和微信公众号时向小伙伴们说过的个人目标，转眼半年过去了，看着Github下面的一片绿色，心里面很是开心。这个目标必须持久地坚持下去，搞技术是一个长久的活动，是一个终身学习的活动，是一个持续研究的活动。技术是学不完的，但是我想说的是，在有限的时间内尽可能多的，有目标地进行深入地学习一定不是一件坏事！很多人都在说十年技术和技术十年的区别。我想说的是，不管是十年技术还是技术十年，都有自己的特点，十年技术代表的可能是各方面能力业务都很强的人，因为十年里，他换过不同的岗位，做过不同的研发工作等等，这对个人的能力锻炼是非常有帮助的。而技术十年可能是在一个研究方向上做了十年工作的人，那这个人很有可能就是这个领域内的佼佼者。不管如何，持续学习，终身学习应该成为我们的生活态度！ 开通博客和个人微信公众号是让我觉得比较有意义的事情，因为可以通过不断地写博客来明确自己的学习目标，明确自己需要跟大家分享的内容。这样一方面可以给大家分享比较有意义的文章，另一方面可以有效地梳理自己的知识体系。写文章是一个知识输出的过程，目前为止，我还不能源源不断地产生输出，因为储备还不够丰富。所以，知识的输入尤为重要，过去一年一直再通过各种渠道学习，比如在线学习网站看视频，技术论坛，还有就是直接买书。这几种方式我认为都很好，看视频效果比较好，可以跟着老师一起做一些小项目，小Demo。逛技术论坛可以看到别人分享的技术，一起遇到bug时的解决方案，看书的话知识会非常成体系，能够构建对某一领域的整体认知体系。具体的方式小伙伴们可以根据自己的实际情况选择。 2017年已经过去一个星期了，其实也在告诉我们一个事实，时间很紧迫，要抓紧时间做需要做的事情。2017年里我没有其他啥的目标，至少目前没想到其他的，一切按照原定计划进行，继续写博客，继续研究技术，看完该看的书，学好想学的技术，并与大家分享！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"新年","slug":"新年","permalink":"http://qinjiangbo.com/tags/新年/"}]},{"title":"（译）Java集合框架类和接口层级图","slug":"java-collection-framework-classes-and-interfaces","date":"2016-12-25T12:47:01.000Z","updated":"2017-01-14T07:17:55.000Z","comments":true,"path":"java-collection-framework-classes-and-interfaces.html","link":"","permalink":"http://qinjiangbo.com/java-collection-framework-classes-and-interfaces.html","excerpt":"","text":"1. Collection vs Collections首先，”Collection”和”Collections”是两个不同的概念。从下面的层级图你可以看到，”Collection”是集合框架层级图的根元素，但是”Collections”只是一个提供操作集合框架静态方法的工具类。 2. 集合框架类层级图下面一幅图显示了集合框架的类层级图。 3. Map映射的类层级图这是Map映射的类层级图。 4. 各个类汇总 Interfaces Hash table Resizable array Tree Linked list Hash table + Linked list Set HashSet TreeSet LinkedHashSet List ArrayList LinkedList Queue Map HashMap TreeMap LinkedHashMap 5. 代码示例下面这段代码阐释了不同的集合类型。 1234567891011121314151617181920212223242526272829303132List&lt;String&gt; a1 = new ArrayList&lt;String&gt;();a1.add(\"Program\");a1.add(\"Creek\");a1.add(\"Java\");a1.add(\"Java\");System.out.println(\"ArrayList Elements\");System.out.print(\"\\t\" + a1 + \"\\n\"); List&lt;String&gt; l1 = new LinkedList&lt;String&gt;();l1.add(\"Program\");l1.add(\"Creek\");l1.add(\"Java\");l1.add(\"Java\");System.out.println(\"LinkedList Elements\");System.out.print(\"\\t\" + l1 + \"\\n\"); Set&lt;String&gt; s1 = new HashSet&lt;String&gt;(); // or new TreeSet() will order the elements;s1.add(\"Program\");s1.add(\"Creek\");s1.add(\"Java\");s1.add(\"Java\");s1.add(\"tutorial\");System.out.println(\"Set Elements\");System.out.print(\"\\t\" + s1 + \"\\n\"); Map&lt;String, String&gt; m1 = new HashMap&lt;String, String&gt;(); // or new TreeMap() will order based on keysm1.put(\"Windows\", \"2000\");m1.put(\"Windows\", \"XP\");m1.put(\"Language\", \"Java\");m1.put(\"Website\", \"programcreek.com\");System.out.println(\"Map Elements\");System.out.print(\"\\t\" + m1); 输出结果： 12345678ArrayList Elements [Program, Creek, Java, Java]LinkedList Elements [Program, Creek, Java, Java]Set Elements [tutorial, Creek, Program, Java]Map Elements &#123;Windows=XP, Website=programcreek.com, Language=Java&#125; 译文原文地址：http://www.programcreek.com/2009/02/the-interface-and-class-hierarchy-for-collections/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://qinjiangbo.com/tags/JDK8/"},{"name":"集合框架","slug":"集合框架","permalink":"http://qinjiangbo.com/tags/集合框架/"}]},{"title":"（译）Java集合框架十问","slug":"ten-questions-of-java-collection-framework","date":"2016-12-25T12:42:11.000Z","updated":"2017-01-14T07:18:16.000Z","comments":true,"path":"ten-questions-of-java-collection-framework.html","link":"","permalink":"http://qinjiangbo.com/ten-questions-of-java-collection-framework.html","excerpt":"","text":"下面这些问题是Stackoverflow上面关于Java集合框架提问最多和讨论最多的问题。在你开始看这些问题之前，你最好先看看这些类层级图，以确保你知道它们的关系。 1. 什么时候最好使用LinkedList而不是ArrayList？从某种意义上来说，ArrayList就是数组。它的元素能够直接通过下标访问。但是如果这个数组快占满了，一个新的大的数组需要被分配出来，然后将原来的元素全部拷贝到新的数组里面去，这需要$O(n)$时间。同样的，添加或者移除某个元素需要将数组中剩下的元素移动。这恐怕是Arraylist最大的一个劣势了。 LinkedList是一条双向链接表。因此，当需要访问链表中间的某个元素时，它不得不从链表起始位置开始查找。另外，添加或者删除链表中的某个元素会更快，因为它只局部改变链表。 总结一下，最坏情况复杂度的比较如下： Arraylist LinkedList get(index) $O(1)$ $O(n)$ add(E) $O(n)$ $O(1)$ add(E, index) $O(n)$ $O(n)$ remove(index) $O(n)$ $O(n)$ Iterator.remove() $O(n)$ $O(1)$ Iterator.add(E) $O(n)$ $O(1)$ 除了运行时间以外，内存占用也是一个需要考虑的问题，尤其是针对大链表。在LinkedList中，每一个结点都需要至少两个额外的指针来链接前一个和后一个结点；而在ArrayList中，只需要一个元素的数组即可。 2. 在迭代一个集合框架的时候删除元素在迭代集合框架的时候删除其中的一个元素，只有一种正确的做法，就是使用Iterator.remove()方法，例如： 12345Iterator&lt;Integer&gt; itr = list.iterator();while(itr.hasNext()) &#123; // do something itr.remove();&#125; 最常见的错误就是: 123for(Integer i: list) &#123; list.remove(i);&#125; 知道会报什么错误吗？会报ConcurrentModificationException这样一个异常。这是因为在foreach循环语句中产生了一个迭代器，这个迭代器来遍历这个链表，而与此同时，这个链表又被另一个Iterator.remove()改变了。在Java中，一个线程在遍历一个链表的同时不允许另一个线程对其进行修改操作。 3. 怎样把链表转化为int数组？最简单的方法莫过于使用Apache Commons Lang库。 1int[] array = ArrayUtils.toPrimitive(list.toArray(new Integer[0])); 在JDK中，没有捷径。你不能使用List.toArray()，因为那样会把链表转换为int的包装类数组Integer[]。正确的方式如下： 1234int[] array = new int[list.size()];for(int i=0; i &lt; list.size(); i++) &#123; array[i] = list.get(i);&#125; 4. 怎样把int数组转化为链表？同上，最简单的方法还是使用Apache Commons Lang库。 1List list = Arrays.asList(ArrayUtils.toObject(array)); 在JDK中，也没有捷径可走。 12345int[] array = &#123;1,2,3,4,5&#125;;List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();for(int i: array) &#123; list.add(i);&#125; 5. 筛选一个集合框架元素的最好方式是什么？同样的，你也可以使用第三方的包，比如Guava或者Apache Commons Lang。这两个包都有filter()方法（Guava里面的Collections2和Apache里面的CollectionUtils）。这个filter()方法将会返回指定预言（Predicate）下的元素。 在JDK中，这些事情会变得更加困难。但是Java 8为我们带来了好消息，那就是Java里面添加了预言（Predicate）的支持。但是现在你可能得使用迭代器（Iterator）来遍历整个集合。 1234567Iterator&lt;Integer&gt; itr = list.iterator();while(itr.hasNext()) &#123; int i = itr.next(); if (i &gt; 5) &#123; // filter all ints bigger than 5 itr.remove(); &#125;&#125; 当然，你也可以模仿Guava和Apache Commons Lang中的实现方式，引用一个新的接口Predicate，这也是大多数高级程序员的做法。 123456789101112131415public interface Predicate&lt;T&gt; &#123; boolean test(T o);&#125; public static &lt;T&gt; void filter(Collection&lt;T&gt; collection, Predicate&lt;T&gt; predicate) &#123; if ((collection != null) &amp;&amp; (predicate != null)) &#123; Iterator&lt;T&gt; itr = collection.iterator(); while(itr.hasNext()) &#123; T obj = itr.next(); if (!predicate.test(obj)) &#123; itr.remove(); &#125; &#125; &#125;&#125; 下面的代码就简单了。 12345filter(list, new Predicate&lt;Integer&gt;() &#123; public boolean test(Integer i) &#123; return i &lt;= 5; &#125;&#125;); 其实这个方法还可以直接使用lambda表达式代替。具体是什么自己实践吧！哈哈！ 6. 将链表（List）转为集合（Set）的最简单方式是什么？有两种方式来实现这个过程。第一种方式就是把一个链表直接塞到一个集合里去。这个时候重复主要是根据hashCode()来判断啦。在大多数情况这么做是可行的，但是你需要指明它们比较的方式。所以，推荐使用第二种方式，就是可以自己指定这个比较方式。 第一种方式 1Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(list); 第二种方式 12Set&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;(aComparator);set.addAll(list); 7. 怎样从ArrayList中移除重复元素？这个问题和上面的一问很相似。但是如果你不关心ArrayList中的元素顺序的话，上面的方式是可以的。然后再将集合中的元素放回列表。 1234ArrayList list = ... // initial a list with duplicate elementsSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(list);list.clear();list.addAll(set); 如果你关心顺序的话，你可以把ArrayList中的元素放入LinkedHashSet中，然后执行上述过程。 8. 集合排序在Java中维护一个排好序的集合有很多种方式。都是基于自然排序的方式或者是指定一个排序器。对于自然排序，你也需要在被排序的元素中实现Comparable接口。 Collections.sort()能够排序一个列表。这种排序是稳定的，而且复杂度为$O(nlog(n))$。 PriorityQueue提供了一种排好序的队列。PriorityQueue和Collections.sort()不同的地方在于PriorityQueue无论什么时候都维护着一个有序队列，每次你只能获得队首元素。你不能像PriorityQueue.get(4)这样随机访问里面的元素。 如果集合中没有重复的元素，可以考虑使用TreeSet，和PriorityQueue一样，它也是每时每刻维护着一个有序的集合。你能得到最大值和最小值，但是你无法随机访问里面的元素。 简单来说，Collections.sort()就只是排序列表一次。而PriorityQueue和TreeSet一直都在排序这个集合，但是代价是不能随机访问里面的元素。 9. Collections.emptyList() vs new instance这个问题同样适用于emptyMap()和emptySet()。 两个方法都返回一个空的列表。但是Collections.emptyList()返回一个不可变的列表。这意味着你不能添加元素到这个空列表。准确地来说，每次调用这个Collections.emptyList()都会复用这个空列表。这里用到的是单例模式的思想。 10. Collections.copy有两种方式可以复制一个列表到另一个列表。一种是利用ArrayList构造函数。 1ArrayList&lt;Integer&gt; dstList = new ArrayList&lt;Integer&gt;(srcList); 另一种是利用这个Collecitons.copy()方法，注意我们在分配一个目标列表的空间时，至少得和源列表的大小相同。 12ArrayList&lt;Integer&gt; dstList = new ArrayList&lt;Integer&gt;(srcList.size());Collections.copy(dstList, srcList); 两种复制都是浅拷贝，但是这两种方式有什么不一样呢？ 首先，Collections.copy()方法不会重新分配目标列表的空间大小，即使目标列表的空间很小不足以装下所有的源列表元素。相反，它会抛出IndexOutOfBoundsException异常。有人会问这样做到底有什么好处呢？一种可能的原因就是它保证了程序在运行这个方法的时候时间是线性的。 其次，Collecitons.copy()方法仅接收List列表作为源列表和目标列表的类型。 译文原文地址：http://www.programcreek.com/2013/09/top-10-questions-for-java-collections/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://qinjiangbo.com/tags/JDK8/"},{"name":"集合框架","slug":"集合框架","permalink":"http://qinjiangbo.com/tags/集合框架/"}]},{"title":"（译）ArrayList vs. LinkedList vs. Vector","slug":"array-list-vs-linked-list-vs-vector","date":"2016-12-22T11:17:54.000Z","updated":"2017-01-14T07:21:45.000Z","comments":true,"path":"array-list-vs-linked-list-vs-vector.html","link":"","permalink":"http://qinjiangbo.com/array-list-vs-linked-list-vs-vector.html","excerpt":"","text":"1. List链表一览链表，就像它名字说的一样，是一个由各个元素组成的有序序列。当我们谈论链表的时候，将它与集合Set相比较是一个不错的想法。集合Set由一组不重复的元素组成的无序集合。下面的一幅图描述了Java中集合框架的层次关系，通过这幅图你能对集合框架有一个不错的认识。 2. ArrayList vs. LinkedList vs. Vector从这个层次图来说，ArrayList，LinkedList以及Vector都实现了List接口。所以它们仨的使用非常相似。不同点主要体现在他们具体的实现不一样。使用的时候要根据它们的实现不同以及使用的场景不同选择合适的集合框架，以便于发挥它们最大的性能。 ArrayList它的实现是基于一个可以改变大小的数组。 因为允许更多的元素不断地加入到集合中去，所以ArrayList的大小是可以动态调整的。另外，它的元素可以直接通过下标访问，这是因为底层是数组。 LinkedList它的实现基于双向链接表。它的性能主要体现在添加和移除元素上面，在访问元素上面的性能比较差。 Vector它和ArrayList非常接近，但是它是同步的。如果你的代码是线程安全的，ArrayList将会是一个更好的选择。Vector和ArrayList都需要更多的空间来存放元素，因为会有更多的元素源源不断地加入进来。Vector每次都是扩大一倍它的容量size，而ArrayList每次都是扩大它的容量size的50%。LinkedList，因为实现的是Queue接口，所以它有比ArrayList和Vector更多的方法，比如offer()，peek()和poll()。 注意：ArrayList默认的初始容量是非常小的。查看源码可以知道是10。这里希望大家养成一个好习惯，就是先估计一下自己的目标集合的容量，比如50，那么可以在申请ArrayList的时候就直接指定它的容量为50或者更高一点，避免每次重新调整大小而造成性能损失。 3. ArrayList实例12345678910111213ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;();al.add(3);al.add(2); al.add(1);al.add(4);al.add(5);al.add(6);al.add(6);Iterator&lt;Integer&gt; iter1 = al.iterator();while(iter1.hasNext())&#123; System.out.println(iter1.next());&#125; 4. LinkedList实例12345678910111213LinkedList&lt;Integer&gt; ll = new LinkedList&lt;Integer&gt;();ll.add(3);ll.add(2); ll.add(1);ll.add(4);ll.add(5);ll.add(6);ll.add(6);Iterator&lt;Integer&gt; iter2 = ll.iterator();while(iter2.hasNext())&#123; System.out.println(iter2.next());&#125; 正如上面的实例所体现的，其实他们的用法都差不多，主要的不同在于它们实现的机制不同而且它们执行相同操作的复杂度不同。 5. VectorVector几乎和ArrayList一样，它们俩之间的不同就是Vector是同步的。因为这一点，它比ArrayList稍微耗性能一点。通常，除非你的代码明确指定要使用同步的代码，否则一般我不建议你使用Vector，使用ArrayList是一个比Vector更好的选择。 6. ArrayList vs. LinkedList性能对比时间复杂度对比： ArrayList LinkedList get() $O(1)$ $O(n)$ add() $O(1)$ $O(1)$ remove() $O(n)$ $O(n)$ * 表中add()指代add(E e)，remove()指代remove(int index) ArrayList在add/remove的随机索引访问上的复杂度为$O(n)$，而在链表的末尾进行的操作复杂度为$O(1)$。 LinkedList在add/remove的随机索引访问上的复杂度为$O(n)$，在链表的首尾进行的操作复杂度为$O(1)$。 使用下面的代码来测试它们的性能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;();// ArrayList addlong startTime = System.nanoTime();for (int i = 0; i &lt; 100000; i++) &#123; arrayList.add(i);&#125;long endTime = System.nanoTime();long duration = endTime - startTime;System.out.println(\"ArrayList add: \" + duration);// LinkedList addstartTime = System.nanoTime();for (int i = 0; i &lt; 100000; i++) &#123; linkedList.add(i);&#125;endTime = System.nanoTime();duration = endTime - startTime;System.out.println(\"LinkedList add: \" + duration);// ArrayList getstartTime = System.nanoTime();for (int i = 0; i &lt; 10000; i++) &#123; arrayList.get(i);&#125;endTime = System.nanoTime();duration = endTime - startTime;System.out.println(\"ArrayList get: \" + duration);// LinkedList getstartTime = System.nanoTime();for (int i = 0; i &lt; 10000; i++) &#123; linkedList.get(i);&#125;endTime = System.nanoTime();duration = endTime - startTime;System.out.println(\"LinkedList get: \" + duration);// ArrayList removestartTime = System.nanoTime();for (int i = 9999; i &gt;=0; i--) &#123; arrayList.remove(i);&#125;endTime = System.nanoTime();duration = endTime - startTime;System.out.println(\"ArrayList remove: \" + duration);// LinkedList removestartTime = System.nanoTime();for (int i = 9999; i &gt;=0; i--) &#123; linkedList.remove(i);&#125;endTime = System.nanoTime();duration = endTime - startTime;System.out.println(\"LinkedList remove: \" + duration); 结果是： 123456ArrayList add: 13265642LinkedList add: 9550057ArrayList get: 1543352LinkedList get: 85085551ArrayList remove: 199961301LinkedList remove: 85768810 它们在性能上的区别很明显，就是LinkedList在添加和移除的操作上更快，而在元素访问的操作上很慢。基于复杂度表格以及这个实验的结果，我们能更好地使用这三个链表。事实上，如果存在下列情况，我建议你优先考虑LinkedList： 没有大量随机访问链表元素的需求； 存在大量的添加和移除操作； 译文原文地址：http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://qinjiangbo.com/tags/JDK8/"},{"name":"list","slug":"list","permalink":"http://qinjiangbo.com/tags/list/"}]},{"title":"武汉大学论文格式要求","slug":"format-of-thesis-in-wuhan-university","date":"2016-12-10T14:30:28.000Z","updated":"2016-12-10T14:56:05.000Z","comments":true,"path":"format-of-thesis-in-wuhan-university.html","link":"","permalink":"http://qinjiangbo.com/format-of-thesis-in-wuhan-university.html","excerpt":"","text":"一、文字和字数除有特殊要求的专业外，毕业论文一般用简化汉语文字撰写，毕业论文的字数人文社科类专业一般不应少于1万字，理工医类专业一般不应少于1.5万字。对于部分专业毕业设计成果由毕业设计图纸和毕业论文两部分组成者，其毕业论文字数原则上应不低于1万字。各专业可根据需要确定具体的文字和字数要求，并报教务部备案。 二、书写及装订论文按照本规范的要求单面打印，论文裁切后规格为70g白色A4打印纸。一律左侧装订。封面为120g白色铜版纸。 三、字体和字号 内容 字体大小 论文题目 黑体2号 各章标题 黑体小2号 各节的一级标题 黑体4号 各节的二级标题 黑体小4号 各节的三级标题 黑体小4号 款项 黑体小4号 正文 宋体小4号 中文摘要、结论、参考文献标题 黑体小2号 中文摘要、结论、参考文献内容 宋体小4号 英文摘要标题 Time New Roman大写粗体小2号 英文摘要内容 Time New Roman体小4号 中文关键词标题 黑体小4号 中文关键词 宋体小4号 英文关键词标题 Time New Roman粗体小4号 英文关键词 Time New Roman小4号 目录标题 黑体小2号 目录内容中章的标题 黑体4号 目录中其他内容 宋体小4号 论文页码 页面底端居中、阿拉伯数字（Times new roman 5号）连续编码 页眉与页脚 宋体5号居中 四、封面论文具体排版规范见封面示例，字体与字号要求如下： 内容 字体大小 学号 （黑体5号） 密级 （黑体5号） 武汉大学本科生毕业论文（设计） （宋体1号居中） 论文题目 （黑体2号居中） 院（系）名称 （宋体小3号） 专业名称 （宋体小3号） 学生姓名 （宋体小3号） 指导教师 （宋体小3号） 年 月 （宋体3号） 五、学术声明 内容 字体大小 郑重声明 (宋体粗体2号居中) 声明内容 （宋体4号） 见学术声明示例。 六、页面设置页边距标准：上边距为25mm，下边距为20mm，左边距为30mm，右边距为30mm。段前、段后及行间距：章标题的段前为0.8行，段后为0.5行；节标题段前为0.5行，段后0.5行；标题以外的文字行距为“固定值”23磅，字符间距为“标准”。 七、摘要摘要正文下空一行顶格打印“关键词”款项，每个关键词之间用“；”分开，最后一个关键词不打标点符号，英文摘要应另起一页。具体示例见中、英文摘要示例。 八、目录目录应包括章、节、条三级标题，目录和正文中的标题题序统一按照“1……、1.1……、1.1.1……”的格式编写，目录中各章节题序中的阿拉伯数字用Time New Roman体。目录的具体排版格式见目录示例。 九、正文正文各章节应拟标题，每章结束后应另起一页。标题要简明扼要，不应使用标点符号。各章、节、条的层次按照“1……、1.1……、1.1.1……”标识，条以下具体款项的层次依次按照“1.1.1.1”、“（1）”、“①”标识。见正文示例。 十、引文标示引文标示应全文统一，采用方括号上标的形式置于所引内容最末句的右上角，引文编号用阿拉伯数字置于半角方括号中，用小4号字体，如：“……模式[3]”。各级标题不得使用引文标示。正文中如需对引文进行阐述时，引文序号应以逗号分隔并列排列于方括号中，如“文献[1，2，6-9]从不同角度阐述了……” 十一、名词术语全文应统一科技名词术语、行业通用术语以及设备、元器件的名称。有国家标准的应采用标准中规定的术语，没有国家标准的应使用行业通用术语或名称。特定含义的名词术语或新名词应加以说明或注释。 十二、物理量名称、符号与计量单位论文中某一物理量的名称和符号应统一，一律采用国务院发布的《中华人民共和国法定计量单位》，单位名称和符号的书写方式，应采用国际通用符号。在不涉及具体数据表达时允许使用中文计量单位如“千克”。表达时刻应采用中文计量单位，如“下午3点10分”，不能写成“3h10min”。在表格中可以用“3:10PM”表示。物理量符号、物理量常量、变量符号用斜体，计量单位符号均用正体。 十三、数字无特别约定情况下，一般均采用阿拉伯数字表示。年份一概用4位数字表示。小数的表示方法，一般情形下，小于1的数，需在小数点之前加0。但当某些特殊数字不可能大于1时（如相关系数、比率、概率值），小数之前的0要去掉，如r=.26，p&lt;.05。统计符号的字形格式，一般除μ、α、β、λ、ε以及V等符号外，其余统计符号一律以斜体字呈现，如ANCOVA，ANOVA，MANOVA，N，nl，M，SD，F，p，r等。 十四、公式公式应另起一行居中，统一用公式编辑器编辑。公式与编号之间不加虚线。公式较长时应在“＝”前转行或在“＋、－、×、÷”运算符号处转行，等号或运算符号应在转行后的行首，公式的编号用圆括号括起来放在公式右边行末。公式序号按章编排，如第3章第2个公式序号为“（3.2）”，附录中的第n个公式用序号“（An）”表示。文中引用公式时，采用“见公式（3.2）”表述。具体见公式图表示例。 十五、表格每一个表格都应有表标题和表序号。表序号一般按章编排，如第2章第4个表的序号为“表2.4”。表标题和表序之间应空一格，表标题中不能使用标点符号，表标题和表序号居中置于表上方（黑体小4号，数字和字母为Time New Roman粗体小4号）。引用表格应在表标题的右上角加引文序号。表与表标题、表序号为一个整体，不得拆开排版为两页。当页空白不够排版该表整体时，可将其后文字部分提前，将表移至次页最前面。统计表一律采用开口表格的标准格式，具体见公式图表示例。 十六、图插图应与文字内容相符，技术内容正确。所有制图应符合国家标准和专业标准。对无规定符号的图形应采用该行业的常用画法。每幅插图应有图标题和图序号。图序号按章编排，如第1章第4幅插图序号为“图1.4”。图序号之后空一格写图标题，图序号和图标题居中置于图下方，用小4号宋体。引用图应在图标题右上角标注引文序号。图中若有分图，分图号用（a）、（b）等置于分图下、图标题之上。图中的各部分中文或数字标示应置于图标题之上（有分图者置于分图序号之上）。图与图标题、图序号为一个整体，不得拆开排版为两页。当页空白不够排版该图整体时，可将其后文字部分提前，将图移至次页最前面。对坐标轴必须进行文字标示，有数字标注的坐标图必须注明坐标单位。具体见公式图表示例。 十七、注释注释是对论文中特定名词或新名词的注解。注释可用页末注或篇末注的一种。选择页末注的应在注释与正文之间加细线分隔，线宽度为1磅，线的长度不应超过纸张的三分之一宽度。同一页类列出多个注释的，应根据注释的先后顺序编排序号。字体为宋体5号，注释序号以“①、②”等数字形式标示在被注释词条的右上角。页末或篇末注释条目的序号应按照“①、②”等数字形式与被注释词条保持一致。 十八、参考文献参考文献的著录应符合国家标准，参考文献的序号左顶格，并用数字加方括号表示，与正文中的引文标示一致，如[1]，[2]……。每一条参考文献著录均以“.”结束。具体各类参考文献的编排格式如下：1.文献是期刊时，书写格式为：[序号] 作者. 文章题目[J]. 期刊名, 出版年份，卷号(期数):起止页码.2.文献是图书时，书写格式为：[序号] 作者. 书名[M]. 版次. 出版地：出版单位，出版年份：起止页码.3.文献是会议论文集时，书写格式为：[序号] 作者. 文章题目[A].主编.论文集名[C], 出版地：出版单位，出版年份:起止页码.4.文献是学位论文时，书写格式为：[序号] 作者. 论文题目[D].保存地：保存单位，年份.5.文献是来自报告时，书写格式为：[序号] 报告者. 报告题目[R].报告地：报告会主办单位，报告年份.6.文献是来自专利时，书写格式为：[序号] 专利所有者. 专利名称：专利国别，专利号[P].发布日期.7.文献是来自国际、国家标准时，书写格式为：[序号] 标准代号. 标准名称[S].出版地：出版单位，出版年份.8.文献来自报纸文章时，书写格式为：[序号] 作者. 文章题目[N].报纸名，出版日期（版次）.9.文献来自电子文献时，书写格式为：[序号] 作者.文献题目[电子文献及载体类型标识].电子文献的可获取地址，发表或更新日期/引用日期（可以只选择一项）.电子参考文献建议标识：［DB/OL］——联机网上数据库(database online)［DB/MT］——磁带数据库(database on magnetic tape)［M/CD］ ——光盘图书(monograph on CD-ROM)［CP/DK］——磁盘软件(computer program on disk)［J/OL］ ——网上期刊(serial online)［EB/OL］——网上电子公告(electronic bulletin board online) 十九、附录论文附录依次用大写字母“附录A、附录B、附录C……”表示，附录内的分级序号可采用“附A1、附A1.1、附A1.1.1”等表示，图、表、公式均依此类推为“图A1、表A1、式（A1）”等。 二十、印刷与装订顺序毕业论文应按以下顺序装订：封面→学术声明→中文摘要→英文摘要→目录→正文→参考文献→致谢→附录","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"武汉大学","slug":"武汉大学","permalink":"http://qinjiangbo.com/tags/武汉大学/"},{"name":"论文格式要求","slug":"论文格式要求","permalink":"http://qinjiangbo.com/tags/论文格式要求/"}]},{"title":"设计模式学习之单例模式","slug":"design-pattern-singleton","date":"2016-12-05T14:04:52.000Z","updated":"2017-03-09T17:54:11.000Z","comments":true,"path":"design-pattern-singleton.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-singleton.html","excerpt":"","text":"什么是单例模式单例模式（Singleton Desgin Pattern）确保一个类只有一个实例，并提供一个全局的访问点。 为啥使用单例模式使用单例模式有什么好处呢？一般来说，我们在程序编写中，有些对象我们只需要一个，比如：线程池（threadpool）、缓存（cache）、对话框、处理偏好设置以及注册表（registry）的对象、日志对象等等。事实上，有些对象其实只能有一个，因为如果有多个的话程序可能还会出问题，或者是导致资源使用过量的问题。 单例模式类图 这个应该是史上最简单的类图啦~不过还是需要解释一下： uniqueInstance类变量持有唯一的单例实例。单例类可以是非常普通的类，拥有非常普通的方法。 getInstance()方法是静态的，这意味着它是一个类方法，所以可以在代码的任何地方使用Singleton.getInstance()访问它。这和访问全局变量一样简单，只是多了一个优点：单例可以延迟实例化。 单例模式具体实现这一篇我们就不举（扯）实（犊）例（子）啦，直接上代码，代码很简单，非常容易理解。 12345678910111213141516171819202122232425262728package com.qinjiangbo.singleton;public class Singleton &#123; public static Singleton instance; /** * 防止直接实例化 */ private Singleton() &#123; &#125; /** * 双重检查锁 * @return */ public static Singleton getSingletonInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 单例模式 VS 全局变量我们前面说了单例模式可以提供一个全局的访问点，保证该单例类的对象在全局只实例化一次。全局变量（也就是类变量）也可以保证全局只有一个访问点，为什么我们不提倡使用它呢？ 这里需要说明的是，的确，全局变量能为我们提供全局的访问点。但是，我们需要知道，如果将一个对象赋值给一个全局变量，那么你必须在程序一开始就创建好对象，对吧？万一这个对象非常的耗资源，而程序在此时并不需要使用这个对象，不就很浪费吗？我们之所以使用单例模式，还有一个重要的原因就是这个，单例模式能够保证对象的延迟实例化。这个是非常重要的一个理念，只有当程序需要的时候才进行实例化，有利于程序发挥最大的性能。 注意 单例模式中，单例类的构造函数必须声明为private，切记！不然该类就能在全局各个地方进行实例化了。 设计模式GitHub仓库地址：https://github.com/QinJiangbo/DesignPatterns","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"http://qinjiangbo.com/tags/单例模式/"}]},{"title":"单例模式双重检查锁机制","slug":"mechanism-of-double-locking-check","date":"2016-12-04T19:45:47.000Z","updated":"2017-12-25T02:27:25.000Z","comments":true,"path":"mechanism-of-double-locking-check.html","link":"","permalink":"http://qinjiangbo.com/mechanism-of-double-locking-check.html","excerpt":"","text":"单例模式的特点： 首先，单例模式使类在程序生命周期的任何时刻都只有一个实例， 然后，单例的构造函数是私有的，外部程序如果想要访问这个单例类的话， 必须通过getInstance()来请求（注意是请求）得到这个单例类的实例。 有的时候，总是容易把全局变量和单例模式给弄混了，下面就剖析一下全局变量和单例模式相比的缺点： 首先，全局变量呢就是对一个对象的静态引用，全局变量确实可以提供单例模式实现的全局访问这个功能。但是，它并不能保证您的应用程序中只有一个实例，同时，在编码规范中，也明确指出，应该要少用全局变量，因为过多的使用全局变量，会造成代码难读，还有就是全局变量并不能实现继承（虽然单例模式在继承上也不能很好的处理，但是还是可以实现继承的）。而单例模式的话，其在类中保存了它的唯一实例，这个类，它可以保证只能创建一个实例，同时，它还提供了一个访问该唯一实例的全局访问点。 为何要使用双重检查锁定呢？考虑这样一种情况，就是有两个线程同时到达，即同时调用getInstance()，此时由于singleton == null，所以很明显，两个线程都可以通过第一重的singleton == null，进入第一重 if 语句后，由于存在锁机制，所以会有一个线程进入 lock 语句并进入第二重 singleton == null ，而另外的一个线程则会在lock语句的外面等待。而当第一个线程执行完 new Singleton()语句后，便会退出锁定区域，此时，第二个线程便可以进入lock语句块，此时，如果没有第二重singleton == null的话，那么第二个线程还是可以调用new Singleton()语句，这样第二个线程也会创建一个Singleton实例，这样也还是违背了单例模式的初衷的，所以这里必须要使用双重检查锁定。 细心的朋友一定会发现，如果我去掉第一重singleton == null，程序还是可以在多线程下完好的运行的，考虑在没有第一重singleton == null的情况下，当有两个线程同时到达，此时，由于lock机制的存在，第一个线程会进入lock语句块，并且可以顺利执行new Singleton()，当第一个线程退出lock语句块时， singleton这个静态变量已不为null了，所以当第二个线程进入lock时，还是会被第二重singleton == null挡在外面，而无法执行new Singleton(). 所以在没有第一重singleton == null的情况下，也是可以实现单例模式的。 那么为什么需要第一重singleton == null呢？这里就涉及一个性能问题了，因为对于单例模式的话，new Singleton()只需要执行一次就 OK 了，而如果没有第一重singleton == null的话，每一次有线程进入getInstance()时，均会执行锁定操作来实现线程同步，这是非常耗费性能的，而如果我加上第一重singleton == null 的话，那么就只有在第一次，也就是singleton ==null成立时的情况下执行一次锁定以实现线程同步，而以后的话，便只要直接返回Singleton实例就 OK 了而根本无需再进入lock语句块了，这样就可以解决由线程同步带来的性能问题了。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"http://qinjiangbo.com/tags/单例模式/"}]},{"title":"设计模式学习之抽象工厂模式","slug":"design-pattern-abstract-factory","date":"2016-12-04T16:50:24.000Z","updated":"2017-03-09T17:54:23.000Z","comments":true,"path":"design-pattern-abstract-factory.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-abstract-factory.html","excerpt":"","text":"什么是抽象工厂模式抽象工厂模式（Abstract Factory Design Pattern）提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 是时候使用抽象工厂模式啦抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或者关心）实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。 抽象工厂模式类图 Client客户的代码中只需要涉及抽象工厂，运行时将使用实际的工厂。 AbstractFactory抽象工厂定义了一个接口，所有的具体工厂都必须实现此接口，这个接口中包含一组方法用来生产产品。 ConcreteFactory具体工厂实现不同的产品家族，要创建一个产品，客户完全不需要知道产品是如何创建的，它只需要使用其中的一个具体工厂即可。 AbstractProduct是抽象产品类，是所有具体产品类必须实现的类。AbstractProductA和AbstractProductB形成了一个产品族。每个具体工厂类都能产生一整组的产品。 实例分析-调料工厂前面我们说了这个披萨店的问题，发现不同的披萨店可以生产不同的披萨，但是为什么披萨的口味会不同呢？答案当然是调料不一样啦。那么纽约风味的披萨店和芝加哥风味的披萨店他们的调料从哪儿来呢？这里可以很容易的想到，从两个不同城市的工厂直接就近运输过来。所以是两个工厂来生产这个调料。 调料工厂的类图 哇！好复杂的图！别急，骚年~仔细一看其实还是很简单滴~这个类图待我慢慢给你解释。 首先对照上面的抽象工厂模式类图，我们会发现，披萨店的两个具体实例（NYPizzaStore和ChicagoPizzaStore）就是抽象工厂的客户。图中给出的是NYPizzaStore，大概是因为它做出来的东西好吃吧。 其次我们会发现原料工厂PizzaingredientFactory，这是一个原料工厂接口，它定义了如何产生一组相关产品的家族。这个家族包含了所有制作披萨的原料。下面两个NYPizzaingredientFactory和ChicagoingredientFactory则是这个接口的两个具体实现工厂，这两个具体工厂专门负责生产披萨的原料，每个工厂都知道如何去生产符合本地区口味的原料。对于这个产品家族，每个原料工厂都有自己不同的实现。 工厂方法模式 VS 抽象工厂模式主要有以下两点不同： 工厂方法使用类创建对象；抽象工厂使用对象来创建对象。这里有点绕，说白了，工厂方法模式下面时直接调用的类方法（也叫静态工厂方法）创建对象，而抽象工厂则是传递一个具体工厂实例，通过这个具体工厂实例去创建对象。 工厂方法创建的是一个产品；而抽象工厂创建的是一个产品家族。 工厂方法是否包含在抽象工厂里面是的！抽象工厂的任务是需要定一个负责创建一组产品的接口。这个接口内的每个方法都负责创建一个具体产品。同时我们利用实现抽象工厂的子类来实现这些具体的做法。所以，在抽象工厂中利用工厂方法实现生产方法是相当自然的做法。 总结关于抽象工厂的代码实现就不写啦，因为大部分和上一篇博客（设计模式学习之工厂方法模式）比较像，所以本次我们只讨论设计模型本身，不讨论具体代码的实现。相信小伙伴们都能自己实现的出来。抽象工厂里面有一个非常重要的原则就是依赖倒置原则，这个原则指导我们避免依赖具体类型而应该依赖抽象。 设计模式GitHub仓库地址：https://github.com/QinJiangbo/DesignPatterns","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"抽象工厂模式","slug":"抽象工厂模式","permalink":"http://qinjiangbo.com/tags/抽象工厂模式/"}]},{"title":"设计模式学习之工厂方法模式","slug":"design-pattern-factory-method","date":"2016-12-04T11:56:38.000Z","updated":"2017-03-09T17:54:21.000Z","comments":true,"path":"design-pattern-factory-method.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-factory-method.html","excerpt":"","text":"什么是工厂方法模式工厂方法模式(Factory Method Design Pattern)定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到了子类。 是时候从new中解放出来啦当我们看到new，就会立马想到具体。是的，的确是这样的，我们在使用new创建一个对象的时候，我们实际上是针对实现编程，而不是针对接口。设计模式中有一个原则就是针对接口编程而不是针对实现编程。针对接口编程，可以隔离掉以后系统可能发生的一大堆改变。为什么呢？因为代码是针对接口编写的，通过多态，它可以与任何新类实现该接口。但是，当代码使用大量的具体类时，等于自找麻烦，因为一旦加入新的具体类，我们就必须改代码。 工厂方法模式类图 Product是所有的产品必须实现的一个共同的接口，这样一来，使用这些产品的类就可以引用这个接口，而不是具体类。 Creator是一个抽象创建者类，它实现了所有操作产品的方法，但不实现工厂方法。它的子类必须实现这个factoryMethod()方法。 ConcreteProduct是具体产品类，实现了Product接口。 ConcreteCreator类是具体创建者类，它实现了factoryMethod()方法，知道如何创建一个或者多个具体产品，只有ConcreteCreator类知道如何创建这些产品。 实例分析-披萨店(Pizza Store)假设你开了一家披萨店，生意不错，每天来你的店子吃披萨的人很多。你不小心告诉我你是这么做披萨的： 123456789Pizza orderPizz() &#123; Pizza pizza = new Pizza(); // 制作过程，绝密！ pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza;&#125; 为了满足市场的需求，你决定增加一些口味的披萨，但是你不想自己亲手去制作每一个披萨啦，你希望有一个代工厂能帮你做，你付给他一定的酬劳，他负责帮你创建这些披萨。 1234567891011121314151617181920212223242526272829303132333435package com.qinjiangbo.factory.simpleFactory;public class SimpleFactory &#123; private Pizza pizza; public SimpleFactory() &#123; //no args &#125; /** * 生产Pizza对象 * @param type * @return */ public Pizza createPizza(String type) &#123; if (type.equals(\"Pepperoni\")) &#123; pizza = new PepperoniPizza(); &#125; else if (type.equals(\"Clam\")) &#123; pizza = new ClamPizza(); &#125; else if (type.equals(\"Veggie\")) &#123; pizza = new VeggiePizza(); &#125; else if (type.equals(\"Cheese\")) &#123; pizza = new CheesePizza(); &#125; else &#123; System.out.println(\"Invalid Type!\"); &#125; return pizza; &#125;&#125; 似乎问题好像变得容易多了，至少下一次你想去掉或者增加一个新品种的披萨时，只需要跟代工厂说一下（只需要修改这一处的代码）。但是如果我想要开另一家店呢？ 卑鄙的我我也看到了商机啊，我说，给你保守这个秘密可以，但是前提是我自己加盟你的披萨店，成立一个连锁店，如何？你说：嗯，好啊！太好了！（缺心眼？？哈哈）于是我就顺（臭）理（不）成（要）章（脸）地成立了自己的披萨店。我们使用同样一个代工厂帮我们生产披萨，但是我有自己的想法，我说，我需要研发自己的一种披萨风味，和你的不一样，你的是纽约风味，我的要做成芝加哥风味。这个时候，代工厂这边就需要做很大的改变了，他需要为两家店同时制作不同口味的披萨。不过还好我负责和代工厂老板沟通具体制作事宜。 披萨连锁店系统的结构图 这张图很好理解，但是还是需要解释一下，右边是创建者类，它是一个抽象类，定义了一个抽闲的方法，下面的NYPizzaStore和ChicagoPizzaStore是这个创建者类的两个实现类，分别负责创建不同风味的披萨。这个也就代表了我们两家不同的连锁店。 左边的这个很重要，你还是坚持你的纽约风味的披萨，但是我坚持采用全新的芝加哥风味，所以我们两家的披萨产品虽然都源自于Pizza这个产品类别，但是已经完全不一样了。 披萨生产流程说明ChicagoPizzaStore只负责生产芝加哥风味的披萨，NYPizzaStore只负责生产纽约风味的披萨。职责相当明确，不能混合生产，必须独立分开生产。 开工生产创建产品（Product）先创建所有产品的父类Pizza： 1234567891011121314151617181920212223242526272829303132333435363738package com.qinjiangbo.factory.factoryMethod;import java.util.ArrayList;public abstract class Pizza &#123; String name; String dough; String sauce; @SuppressWarnings(\"rawtypes\") ArrayList toppings = new ArrayList(); void prepare() &#123; System.out.println(\"Preparing \" + name); System.out.println(\"Tossing dough...\"); System.out.println(\"Adding sauce...\"); System.out.println(\"Adding toppings: \"); for (int i = 0; i &lt; toppings.size(); i++) &#123; System.out.println(\" \" + toppings.get(i)); &#125; &#125; void bake() &#123; System.out.println(\"Bake for 25 minutes\"); &#125; void cut() &#123; System.out.println(\"cut the pizza into triangle slices\"); &#125; void box() &#123; System.out.println(\"Place pizza in a box\"); &#125; public String getName() &#123; return this.name; &#125;&#125; 然后创建各类纽约风味的披萨： NYCheesePizza 123456789101112package com.qinjiangbo.factory.factoryMethod;public class NYCheesePizza extends Pizza &#123; @SuppressWarnings(\"unchecked\") public NYCheesePizza() &#123; name = \"NY style Sauce and Cheese Pizza\"; dough = \"Thin Crust dough\"; sauce = \"Marinara Sauce\"; toppings.add(\"Grated Raggiano Cheese\"); &#125;&#125; NYClamPizza 12345678package com.qinjiangbo.factory.factoryMethod;public class NYClamPizza extends Pizza &#123; public NYClamPizza() &#123; System.out.println(\"New York Clam Pizza!\"); &#125;&#125; NYPepperoniPizza 12345678package com.qinjiangbo.factory.factoryMethod;public class NYPepperoniPizza extends Pizza &#123; public NYPepperoniPizza() &#123; System.out.println(\"New York Pepperoni Pizza!\"); &#125;&#125; NYVeggiePizza 12345678package com.qinjiangbo.factory.factoryMethod;public class NYVeggiePizza extends Pizza &#123; public NYVeggiePizza() &#123; System.out.println(\"New York Veggie Pizza!\"); &#125;&#125; 好，接下来创建芝加哥风味的披萨： ChicagoCheesePizza 12345678910111213141516package com.qinjiangbo.factory.factoryMethod;public class ChicagoCheesePizza extends Pizza &#123; @SuppressWarnings(\"unchecked\") public ChicagoCheesePizza() &#123; name = \"Chicago style Sauce and Cheese Pizza\"; dough = \"Thin Crust dough\"; sauce = \"Marinara Sauce\"; toppings.add(\"Grated Raggiano Cheese\"); &#125; void cut() &#123; System.out.println(\"Cutting the pizza into square slices\"); &#125;&#125; ChicagoClamPizza 12345678package com.qinjiangbo.factory.factoryMethod;public class ChicagoClamPizza extends Pizza &#123; public ChicagoClamPizza() &#123; System.out.println(\"Chicago Clam Pizza!\"); &#125;&#125; ChicagoPepperoniPizza 12345678package com.qinjiangbo.factory.factoryMethod;public class ChicagoPepperoniPizza extends Pizza &#123; public ChicagoPepperoniPizza() &#123; System.out.println(\"Chicago Pepperoni Pizza!\"); &#125;&#125; ChicagoVeggiePizza 12345678package com.qinjiangbo.factory.factoryMethod;public class ChicagoVeggiePizza extends Pizza &#123; public ChicagoVeggiePizza() &#123; System.out.println(\"Chicago Veggie Pizza!\"); &#125;&#125; 创建生产者（Creator）先创建所有生产者的父类 123456789101112131415161718package com.qinjiangbo.factory.factoryMethod;public abstract class PizzaStore &#123; public Pizza orderPizza(String type) &#123; Pizza pizza = createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125; protected abstract Pizza createPizza(String type);&#125; 再创建你的纽约风味披萨店： 123456789101112131415161718192021222324package com.qinjiangbo.factory.factoryMethod;public class NYPizzaStore extends PizzaStore &#123; @Override protected Pizza createPizza(String type) &#123; if (type.equals(\"Pepperoni\")) &#123; return new NYPepperoniPizza(); &#125; else if (type.equals(\"Clam\")) &#123; return new NYClamPizza(); &#125; else if (type.equals(\"Veggie\")) &#123; return new NYVeggiePizza(); &#125; else if (type.equals(\"Cheese\")) &#123; return new NYCheesePizza(); &#125; else &#123; System.out.println(\"Invalid Type!\"); return null; &#125; &#125;&#125; 接着创建我的芝加哥风味披萨店： 123456789101112131415161718192021222324package com.qinjiangbo.factory.factoryMethod;public class ChicagoPizzaStore extends PizzaStore &#123; @Override protected Pizza createPizza(String type) &#123; if (type.equals(\"Pepperoni\")) &#123; return new ChicagoPepperoniPizza(); &#125; else if (type.equals(\"Clam\")) &#123; return new ChicagoClamPizza(); &#125; else if (type.equals(\"Veggie\")) &#123; return new ChicagoVeggiePizza(); &#125; else if (type.equals(\"Cheese\")) &#123; return new ChicagoCheesePizza(); &#125; else &#123; System.out.println(\"Invalid Type!\"); return null; &#125; &#125;&#125; 现在开始接受预定1234567891011121314151617package com.qinjiangbo.factory.test;import com.qinjiangbo.factory.factoryMethod.ChicagoPizzaStore;import com.qinjiangbo.factory.factoryMethod.PizzaStore;import com.qinjiangbo.factory.factoryMethod.NYPizzaStore;public class FactoryMethodTest &#123; public static void main(String[] args) &#123; PizzaStore nyStore = new NYPizzaStore(); PizzaStore chicagoStore = new ChicagoPizzaStore(); nyStore.orderPizza(\"Cheese\"); chicagoStore.orderPizza(\"Cheese\"); &#125;&#125; 运行结果： 12345678910111213141516Preparing NY style Sauce and Cheese PizzaTossing dough...Adding sauce...Adding toppings: Grated Raggiano CheeseBake for 25 minutescut the pizza into triangle slicesPlace pizza in a boxPreparing Chicago style Sauce and Cheese PizzaTossing dough...Adding sauce...Adding toppings: Grated Raggiano CheeseBake for 25 minutesCutting the pizza into square slicesPlace pizza in a box 总结工厂方法模式是一个非常好的实践，它实现了面向接口编程，将我们从new中解放了出来。但是千万别以为我们没有使用new啊，这里需要明确指出，我们只是将具体的实例化类的方法封装起来了，主要是便于统一管理，而且必须使用new，这里只不过相当于是把new隐藏了。 设计模式GitHub仓库地址：https://github.com/QinJiangbo/DesignPatterns","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"工厂方法模式","slug":"工厂方法模式","permalink":"http://qinjiangbo.com/tags/工厂方法模式/"}]},{"title":"设计模式学习之装饰者模式","slug":"design-pattern-decoration","date":"2016-12-03T16:18:42.000Z","updated":"2017-03-09T17:54:32.000Z","comments":true,"path":"design-pattern-decoration.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-decoration.html","excerpt":"","text":"什么是装饰者模式装饰者模式(Decorator Desgin Pattern)动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 给爱用继承的人一个全新的设计眼界我们会再次讨论继承滥用的问题。我们之前说过，设计模式有一个原则就是多用组合 ，少用继承。那么在本设计模式中，我们将讨论如何使用对象组合的方式，在运行时动态地装饰类。这样我们就可以在运行时不修改任何底层代码的情况下动态地将我们自己的（或着别人的）对象赋予新的职责。 装饰者模式类图这个类图刚开始一看可能会觉得有点难以理解，别着急，下面给你解释类图中每个模块的作用。 Component是所有组件的父类，通常它是一个抽象类。每个组件都可以单独使用，也可以被装饰者包装起来用。这个抽象类有两种子类，分别是具体组件类ConcreteComponent和装饰者类Decorator。 ConcreteComponent类是具体组件类。使我们将要动态地加上新行为的对象，它拓展自Component类。 Decorator类是装饰者类。每个装饰者都“有一个”（包装一个）组件，也就是说，装饰者有一个实例变量以保存某个Component的引用。这个Decorator是装饰者共同实现的接口（当然也可以是抽象类）。 ConcreteDecorator是具体装饰者，它有一个实例变量，可以记录所装饰的事物（装饰者包着的Component）。装饰者可以加上新的方法。新行为是通过在就行为前面或者后面做一些计算来添加的。装饰者可以拓展Component的状态。 实例分析-星巴兹咖啡星巴兹（为啥不是星巴克呢？）是以扩张速度闻名的咖啡连锁店。在马路上到处都可以看到它，无处不在啊！因为扩张速度实在是太快了，所以他们呢想更新自己的订单系统。主要的需求如下: 顾客在购买咖啡的时候需要加入不同的调味料，比如说燕奶（Steamed Milk），豆浆（Soy），摩卡（Mocha）或者奶泡。星巴兹会根据用户预定的不同的调料动态地计算用用户所需支付的金额。 这个需求如何实现呢？这个好办啊，我们可以针对每一种可能的调料组合计算不同的价格。如下：我的第一反应就是“炸了啊”。的确，这是一个“类爆炸”的典型例子。这当然是不可行的！这个设计违背了设计模式中封装变化和多用组合，少用继承的设计原则。是非常不合理的。那么有没有好的解决办法呢？可以考虑装饰者模式。 装饰者模式的解决方案根据装饰者模式，星巴兹咖啡的订单系统的架构图可以设计如下：我们可以看到，调料盒和饮品已经被解耦了，这里我们通过组合的方式可以产生用户想要的任意味道的饮品。 注意这里可能会有人问道，这里不是使用了继承么？不是原则上说不能使用继承的么？这问题问的很好！应该这么说，这里用的继承纯粹是为了保证装饰者和被装饰者的类型一致，而我们说的新行为取得则是通过组合的方式获取的。所以，并没有违背我们多用组合，少用继承的设计原则。这里请各位读者朋友多加注意！ 星巴兹订单系统代码实现先设计Beverage类： 123456789101112package com.qinjiangbo.decorator.component;public abstract class Beverage &#123; public String description = \"Unknown Beverage\"; public String getDescription() &#123; return description; &#125; public abstract double cost();&#125; Beverage类很简单，让我们看看CondimentDecorator类（也就是装饰者）的实现吧： 12345678package com.qinjiangbo.decorator.decorator;import com.qinjiangbo.decorator.component.Beverage;public abstract class CondimentDecorator extends Beverage &#123; //重新实现getDescription方法 public abstract String getDescription();&#125; 哇！更简单不是吗？现在我们重点实现具体饮料和具体调料的实现类： 饮料类的实现具体饮料Espresso类的实现: 12345678910111213package com.qinjiangbo.decorator.component;public class Espresso extends Beverage &#123; public Espresso() &#123; description = \"Escpresso\"; &#125; @Override public double cost() &#123; return 2.45; &#125;&#125; 具体饮料Decaf类的实现: 12345678910111213package com.qinjiangbo.decorator.component;public class Decaf extends Beverage &#123; public Decaf() &#123; description = \"Decaf\"; &#125; @Override public double cost() &#123; return 2.30; &#125;&#125; 具体饮料DarkRoast类的实现: 1234567891011121314package com.qinjiangbo.decorator.component;public class DarkRoast extends Beverage &#123; public DarkRoast() &#123; description = \"DarkRoast\"; &#125; @Override public double cost() &#123; return 1.25; &#125;&#125; 具体饮料HouseBlend类的实现: 12345678910111213package com.qinjiangbo.decorator.component;public class HouseBlend extends Beverage &#123; public HouseBlend() &#123; description = \"HouseBlend\"; &#125; @Override public double cost() &#123; return 1.50; &#125;&#125; 调料类的实现具体调料Milk类的实现： 12345678910111213141516171819202122package com.qinjiangbo.decorator.decorator;import com.qinjiangbo.decorator.component.Beverage;public class Milk extends CondimentDecorator &#123; Beverage beverage; public Milk(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public String getDescription() &#123; return this.beverage.getDescription() + \"+milk\"; &#125; @Override public double cost() &#123; return 0.55 + this.beverage.cost(); &#125;&#125; 具体调料Mocha类的实现： 12345678910111213141516171819202122package com.qinjiangbo.decorator.decorator;import com.qinjiangbo.decorator.component.Beverage;public class Mocha extends CondimentDecorator &#123; public Beverage beverage; public Mocha(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public String getDescription() &#123; return this.beverage.getDescription() + \"+mocha\"; &#125; @Override public double cost() &#123; return 0.99 + this.beverage.cost(); &#125;&#125; 具体调料Soy类的实现： 12345678910111213141516171819202122package com.qinjiangbo.decorator.decorator;import com.qinjiangbo.decorator.component.Beverage;public class Soy extends CondimentDecorator &#123; public Beverage beverage; public Soy(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public String getDescription() &#123; return this.beverage.getDescription() + \"+soy\"; &#125; @Override public double cost() &#123; return 0.68 + this.beverage.cost(); &#125;&#125; 具体调料Whip类的实现： 12345678910111213141516171819202122package com.qinjiangbo.decorator.decorator;import com.qinjiangbo.decorator.component.Beverage;public class Whip extends CondimentDecorator &#123; public Beverage beverage; public Whip(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public String getDescription() &#123; return this.beverage.getDescription() + \"+whip\"; &#125; @Override public double cost() &#123; return 0.88 + this.beverage.cost(); &#125;&#125; 最后写一个测试类12345678910111213141516package com.qinjiangbo.decorator.test;import com.qinjiangbo.decorator.component.DarkRoast;import com.qinjiangbo.decorator.component.Beverage;import com.qinjiangbo.decorator.decorator.Milk;import com.qinjiangbo.decorator.decorator.Soy;import com.qinjiangbo.decorator.decorator.Whip;public class TestDecorator &#123; public static void main(String[] args) &#123; Beverage beverage = new Whip(new Soy(new Milk(new DarkRoast()))); System.out.println(\"description: \" + beverage.getDescription()); System.out.println(\"cost: \" + beverage.cost()); &#125;&#125; 打印结果： 12description: DarkRoast+milk+soy+whipcost: 3.36 JDK中的装饰者模式写过Java代码的同学都知道java.io这个常用的包。这里面就包含了装饰者模式的一种实现。不知道大家注意到没有，这里面有一些类和我们上面测试用例里面的类包装的使用方式很接近。下面给大家列出这些类： 大家可以看到这个类图和我们前面星巴兹的订单系统的设计并没有什么不同。这个就是设计模式的妙处！大家细细体会！关于JDK中这个java.io包里面装饰类的使用就交给大家自己去动手实践啦~ 设计模式GitHub仓库地址：https://github.com/QinJiangbo/DesignPatterns","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"装饰者模式","slug":"装饰者模式","permalink":"http://qinjiangbo.com/tags/装饰者模式/"}]},{"title":"感悟《从容的底气》篇章一","slug":"think-of-confidence-in-calmness","date":"2016-12-01T08:41:52.000Z","updated":"2016-12-01T09:55:26.000Z","comments":true,"path":"think-of-confidence-in-calmness.html","link":"","permalink":"http://qinjiangbo.com/think-of-confidence-in-calmness.html","excerpt":"","text":"最近在看林清玄的《从容的底气》，感受颇多。先说说我为什么读文学吧，我总是在想，一天到晚搞技术，人会不会变得很NERD？对我来说，答案是肯定的。不管和家人聊天还是和女友聊天，总是会心不在焉，心里想的一直都是这段代码里面为什么一直报空指针，难道是我代码中Java多线程机制这一块出问题了吗？亦或是这个网站不错，讲设计模式挺全，Python的，Javascript的都有，挺好的。。。然后就草草地和家里人以及女友挂了视频，继续钻研技术。以前我不是这样的，半年之前都不是这样的。 那么，问题出现在哪儿呢？我想，问题就出现在我不能同时专注于两件事，但是可能内心更倾向于搞技术，所以忽略了他们。还好现在没出现啥问题我就意识到了，希望自己后面能调整好自己的。钻研技术和好好与家人相处从来都不是一个矛盾的事情！于是，为了改变自己的NERD的倾向，我买了一套文学的书读一读。 说一说读林清玄的文章的感受吧，俩字—-大师！通过很质朴的文字讲述很多很有哲理的故事，其中很多故事以前遇到过，但是没啥触动。不知怎么地，这一次读他的文章，得到了很多自己苦苦寻找的答案，收获颇多。这一本书讲述的是从容的主题，我一想到从容这个词就想到了“习大大”，在处理国内外大事的时候宠辱不惊，从从容容。我也明白，这样的从容并不是与生俱来的，而是自己一点一点地积累和成长起来的。我很佩服！ 下面是我的一些读书摘要，与君分享： 人最大的缺憾就是和他人比较，和高人比较使我们自卑；和俗人比较，使我们下流；和下人比较，使我们骄满。外来的比较是我们心灵动荡不能自在的来源，也使得大部分的人都迷失了自我，障蔽自己心灵原有的氤氲馨香。 如果一个人没有梦想，这个人过了三十岁，生命就可悲了，因为生命过了三十岁开始走下坡，一步一步走向死亡的道路。“保持梦想”就是一直到死前的那一刻都保持着向前的姿势。 心里的安慰比实际的生活来的更加重要。只要在困难的日子里面可以坦然地活下去，就没有走不通的路，因此如何使我们自己的心宽广乐观地应对生活，比汲汲营营地想过好日子来得更重要，归根到底不是米或者番薯的问题，而是自己心态的问题。 我感触最深的就是比较这个事情，因为比较会分散自己很多很多精力，被比较者可能不会察觉任何问题，但是自己若是一味地陷入比较之中则会浪费自己大量的时间和精力，反而还得不到好的结果。当然了，在心底有一个可以追赶的对象是没错的，但是不能过分地要求自己在每个方面都比别人优秀，没有人在所有的方面都是优秀的，走好自己方向就是最好的。人最难得的就是和自己比较，希望大家将目光更多地聚集到自己的身上，要知道，最大的宝藏往往是挖掘自己获得的！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"美文","slug":"美文","permalink":"http://qinjiangbo.com/tags/美文/"},{"name":"感悟","slug":"感悟","permalink":"http://qinjiangbo.com/tags/感悟/"},{"name":"林清玄","slug":"林清玄","permalink":"http://qinjiangbo.com/tags/林清玄/"}]},{"title":"软件工程学习体会","slug":"thoughts-in-software-engineering","date":"2016-11-27T12:23:05.000Z","updated":"2016-11-27T13:49:45.000Z","comments":true,"path":"thoughts-in-software-engineering.html","link":"","permalink":"http://qinjiangbo.com/thoughts-in-software-engineering.html","excerpt":"","text":"研究生的课程基本上都快结束了，说一说这个学期所学课程的一个宏观感受吧，纵观学院开设的这些课程，（如下图） 软件项目管理 软件过程管理 软件需求管理 软件架构设计 面向对象程序设计 专业英语 研究生英语 高级数据库 高级Java编程 数学建模 中国特设社会主义（这个必须的） … 从这个课程设计来看，我个人认为这些课程主要是偏理论，实战性不是很强，包括Java也是偏理论，当然了，Java的学习主要还是自己在下面多花时间去实践。说一说我对这些课程的感受吧。 管理类课程先说说管理类的课程，软件项目管理，软件过程管理以及软件需求管理。软件项目管理主要是偏向项目管理这一块，比如项目评价，项目集管理，项目策划以及风险管控等等。这一门课程呢，主要是偏向那些致力于成为项目经理的同学（当然了，成为项目经理肯定需要多方面的能力）。软件过程管理这一门课程主要是介绍了软件过程相关的知识，另外介绍了几种非常使用的模型，最典型的当然是CMM（Capability Maturity Model）能力成熟度模型了，这个是衡量一个企业的在软件过程（管理过程，支持过程以及实现过程）几个方面的能力的模型。CMM一般分为五个等级，等级越高，能力越强，说明项目管理越规范，项目风险越低。 软件需求管理主要是讲需求工程的，包括需求如何确定，需求说明规约如何编写等等。本来还在想这门课其实应该是一门水课，但是老师在这个上面花的功夫让我们很惭愧，其实这门课很不错的。其中有一个概念国内基本上还没有太多企业采用，但是国外已经完全普及了，那就是架构假设条件(AA[Asumption of Architecture])，这门课程我们一直在维护需求方的AA，同时我们自己也是另一个项目的需求方。AA描述的是我们这个软件设计过程中我们期望的样子（功能性的和非功能性的），但是不是所有的假设条件都能成为AA，AA必须是要花很大代价才能改动的，因为涉及到架构的变动。 架构类课程再说说软件架构设计，这应该是我最感兴趣的一门课程了，这门课程重点介绍了软件架构设计中的思想，还有介绍了很多软件架构的实例，比如SOA架构，BS/CS架构，实时系统架构，以及并发系统架构等等。面向对象程序设计主要是介绍了UML，个人认为和前面的课程比较重复。通过这门课，主要学习了如何去设计一个系统，通过什么样的方式去表示一个系统的架构，最简单的比如使用用例来表示一个系统的功能性需求。通过系统的类图表示系统的各个组件之间的组成关系。 Java编程和数据库接着说说我认为实战性稍微强一点的Java和高级数据库。Java课程一直是备受关注的，即使老师宣布不点名，但依然还是有很多的同学来上课。桂浩老师的课程干货很多，让我们收获很大，高级Java课程主要介绍了Java的内存模型，Java8的相关编程，JVM虚拟机底层原理。其中让我收获最大的是Java内存模型和JVM虚拟机底层原理。Java内存模型中主要介绍了Java内存清理的集中算法，比如标记标记-清除算法，复制-清除算法以及二者综合的算法，Java的内存结构（比如堆结构里面的新生代，年老代以及永久代）等。JVM虚拟机主要讲了Java Class文件的文件结构，以及ClassLoader类加载器相关原理，受益匪浅，感谢！ 高级数据库是董红斌老师给我们授课的，董老师的课程讲解非常清晰，数据库高级课程主要是讲了数据库的底层实现，数据库性能优化（比如索引优化，事务设计）等。虽然目前感觉东西太过于底层需要时间消化，但是有一个基础为日后自己深入理解数据库有相当大的帮助。现在我主要是在研究MySQL和PostgreSQL数据库，这两个都是非常优秀的开源数据库。 实验室研究嗯，以上一对于一些专业课程的相关感受和想法。现在说一说我在实验室的感受，实验室里面主要在研究机器学习中自然语言处理相关的方向，目前在研究LDA主题模型。感受最深的是这个算法真的很实用，能自动的根据文档生成相关的主题，比如给定一条新闻（比如昨天卡斯特罗逝世），我们通过这个算法就能自动贴上相关的主题标签，这样就能帮助搜索引擎自动分类相关的新闻。 博主的学习路线继续深入学习Java编程，深入学习Python编程，踏踏实实写Shell脚本，熟练进行Linux编程，深入理解数据库原理，继续研究算法！！！，这个是内功。然后就是继续关注大型网站架构相关的走向，并学习相关的构建之法。 机器学习和数据挖掘的道路还很远，我还只是刚刚开始，但是满怀信心和期待并踏踏实实地做研究，相信结果不会令自己失望。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"软件工程","slug":"架构师/软件工程","permalink":"http://qinjiangbo.com/categories/架构师/软件工程/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://qinjiangbo.com/tags/软件工程/"}]},{"title":"禁止Mac下产生.DS_Store文件","slug":"forbid-ds-store-files-in-mac","date":"2016-11-21T04:05:00.000Z","updated":"2018-01-23T01:41:28.000Z","comments":true,"path":"forbid-ds-store-files-in-mac.html","link":"","permalink":"http://qinjiangbo.com/forbid-ds-store-files-in-mac.html","excerpt":"","text":"在你使用u盘拷贝东西到win电脑下使用文件时是不是经常发现在win下许多文件夹下都有.DS_Store名称的文件是不是觉得很烦 ，其实.DS_Store是OS X系统生成的文件它包含了与文件夹相关的信息 ，但是因为OS X系统默认是隐藏这类文件所以在Mac下交互使用这些文件是没有任何问题的 。 1.禁止这个文件生成的方法：打开 “终端” （finder －应用程序－实用工具－终端） 输入下面的命令 并 按下 enter 键 运行 ！然后必须注销Mac并重新登陆系统才能生效！！ defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE 2.如果您后悔了觉得 怪怪的 或者 只是暂时 使用 ，可以使用下面的方法恢复回来 ！打开 “终端” （finder －应用程序－实用工具－终端） 输入下面的命令 并 按下 enter 键 运行 ！然后必须注销Mac并重新登陆系统才能生效！！ defaults delete com.apple.desktopservices DSDontWriteNetworkStores 转载自http://www.macappbox.com/showinfo-35-373-0.html","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"http://qinjiangbo.com/tags/MacOS/"},{"name":".DS_Store","slug":"DS-Store","permalink":"http://qinjiangbo.com/tags/DS-Store/"}]},{"title":"PEP8 Python编码规范","slug":"pep8-coding-specifications-in-python","date":"2016-11-18T04:00:08.000Z","updated":"2016-11-18T04:14:40.000Z","comments":true,"path":"pep8-coding-specifications-in-python.html","link":"","permalink":"http://qinjiangbo.com/pep8-coding-specifications-in-python.html","excerpt":"","text":"决定开始Python之路了，利用业余时间，争取更深入学习Python。编程语言不是艺术，而是工作或者说是工具，所以整理并遵循一套编码规范是十分必要的。所以今天下午我根据PEP8整理了一份，以后都照此编码了，还会持续更新。 PEP8 Python编码规范一 代码编排 缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。 每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。 类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。 二 文档编排 模块内容的顺序：模块说明和docstring—import—globals&amp;constants—其他定义。其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。 不要在一句import中多个库，比如import os, sys不推荐。 如果采用from XX import XX引用库，可以省略‘module.’，都是可能出现命名冲突，这时就要采用import XX。 三 空格的使用总体原则，避免不必要的空格。 各种右括号前不要加空格。 逗号、冒号、分号前不要加空格。 函数的左括号前不要加空格。如Func(1)。 序列的左括号前不要加空格。如list[2]。 操作符左右各加一个空格，不要为了对齐增加空格。 函数默认参数使用的赋值符左右省略空格。 不要将多句语句写在同一行，尽管使用‘；’允许。 if/for/while语句中，即使执行语句只有一句，也必须另起一行。 四 注释总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释！ 注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。 块注释，在一段代码前增加的注释。在‘#’后加一空格。段落之间以只有‘#’的行间隔。比如： 12345# Description : Module config.# # Input : None## Output : None 行注释，在一句代码后加注释。比如：x = x + 1 # Increment x但是这种方式尽量少使用。 避免无谓的注释。 五 文档描述 为所有的共有模块、函数、类、方法写docstrings；非共有的没有必要，但是可以写注释（在def的下一行）。 如果docstring要换行，参考如下例子,详见PEP 257 12345\"\"\"Return a foobangOptional plotz says to frobnicate the bizbaz first.\"\"\" 六 命名规范总体原则，新编代码必须按下面命名风格进行，现有库的编码尽量保持风格。 尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。 模块命名尽量短小，使用全部小写的方式，可以使用下划线。 包命名尽量短小，使用全部小写的方式，不可以使用下划线。 类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。 异常命名使用CapWords+Error后缀的方式。 全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是__all__机制;二是前缀一个下划线。 函数命名使用全部小写的方式，可以使用下划线。 常量命名使用全部大写的方式，可以使用下划线。 类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。 类的属性有3种作用域public、non-public和subclass API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。 类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。 为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明__a,访问时，只能通过Foo._Foo__a，避免歧义。如果子类也叫Foo，那就无能为力了。 类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。 七 编码建议 编码中考虑到其他python实现的效率等问题，比如运算符‘+’在CPython（Python）中效率很高，都是Jython中却非常低，所以应该采用.join()的方式。 尽可能使用‘is’‘is not’取代‘==’，比如if x is not None要优于if x。 使用基于类的异常，每个模块或包都有自己的异常类，此异常类继承自Exception。 异常中不要使用裸露的except，except后跟具体的exceptions。 异常中try的代码尽可能少。比如： 123456try:value = collection[key]except KeyError:return key_not_found(key)else:return handle_value(value) 要优于 123456try:# Too broad!return handle_value(collection[key])except KeyError:# Will also catch KeyError raised by handle_value()return key_not_found(key) 使用startswith() and endswith()代替切片进行序列前缀或后缀的检查。比如Yes: if foo.startswith(‘bar’):优于No: if foo[:3] == ‘bar’: 使用isinstance()比较对象的类型。比如Yes: if isinstance(obj, int): 优于No: if type(obj) is type(1): 判断序列空或不空，有如下规则Yes: if not seq: if seq:优于No: if len(seq) if not len(seq) 字符串不要以空格收尾。 二进制数据判断使用if boolvalue的方式。 来源地址: https://www.douban.com/note/134971609/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Python","slug":"开发技术/Python","permalink":"http://qinjiangbo.com/categories/开发技术/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://qinjiangbo.com/tags/Python/"},{"name":"PEP8","slug":"PEP8","permalink":"http://qinjiangbo.com/tags/PEP8/"}]},{"title":"Guava优美代码-21-反射","slug":"guava-reflection-21","date":"2016-11-07T15:31:51.000Z","updated":"2018-04-02T09:03:15.000Z","comments":true,"path":"guava-reflection-21.html","link":"","permalink":"http://qinjiangbo.com/guava-reflection-21.html","excerpt":"","text":"Guava中的反射工具类我们很多时候需要在运行时获取相关类的信息，比如它的方法有哪些，它的父类是什么，它的字段有哪些等等。其实这些JDK已经为我们做得很好了，我个人还是比较喜欢欣赏JDK里面做的反射处理的。不过这里为什么要讲Guava里面的反射呢？因为Guava对于JDK做了大量的封装和优化，最简单的比如动态代理，以前我们JDK里面要写一大堆，现在用Guava就能很方便的实现了。下面分别介绍Guava中的反射特性。 反射类使用实例动态代理Dynamic Proxy公共类(Student.java) 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Student implements People &#123; String name; int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; /** * 打印People信息 */ public void printPeople() &#123; System.out.println(\"name: \" + name + \", age: \" + age); &#125; /** * 两个数之和 * * @param a * @param b * @return */ @ABC public int add(int a, int b) throws NumberFormatException &#123; return a + b; &#125;&#125; 公共接口(People.java) 123interface People &#123; void printPeople();&#125; JDK实现1234567891011121314151617181920/** * 测试JDK的动态代理功能 */@Testpublic void testJDKProxy() &#123; People student = new Student(\"Qin Jiangbo\", 23); People people = (People) Proxy.newProxyInstance( People.class.getClassLoader(), new Class[]&#123;People.class&#125;, getHandler(student)); people.printPeople();&#125;public InvocationHandler getHandler(Object proxiedObject) &#123; return (proxy, method, args) -&gt; &#123; System.out.println(\"method name: \" + method.getName()); System.out.println(\"args: \" + (args == null ? \"null\" : args)); return method.invoke(proxiedObject, args); &#125;;&#125; Guava实现1234567891011121314151617/** * 测试Guava的动态代理 */@Testpublic void testGuavaProxy() &#123; People student = new Student(\"Qin Jiangbo\", 23); People people = Reflection.newProxy(People.class, getHandler(student)); people.printPeople();&#125;public InvocationHandler getHandler(Object proxiedObject) &#123; return (proxy, method, args) -&gt; &#123; System.out.println(\"method name: \" + method.getName()); System.out.println(\"args: \" + (args == null ? \"null\" : args)); return method.invoke(proxiedObject, args); &#125;;&#125; TypeTokenTypeToken类使用这种变通的方法以最小的语法开销去支持泛型类型的操作。 123456789101112@Testpublic void testTypeToken() &#123; ArrayList&lt;String&gt; stringList = Lists.newArrayList(); ArrayList&lt;Integer&gt; intList = Lists.newArrayList(); // 类型被擦除了 System.out.println(stringList.getClass().isAssignableFrom(intList.getClass())); // 利用TypeToken解析原来的类型 TypeToken&lt;ArrayList&lt;String&gt;&gt; typeToken = new TypeToken&lt;ArrayList&lt;String&gt;&gt;() &#123; &#125;; TypeToken&lt;?&gt; genericType = typeToken.resolveType(ArrayList.class.getTypeParameters()[0]); System.out.println(genericType.getType()); // class java.lang.String&#125; InvokableGuava的Invokable是对java.lang.reflect.Method和java.lang.reflect.Constructor的流式包装。它简化了常见的反射代码的使用。(看了一下底层代码实现，好吧，真相就是几乎都是调用JDK的实现完成的。。。。) 12345678910111213141516171819202122232425@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@interface ABC &#123; String value() default \"Hello\";&#125;@Testpublic void testInvokable() throws NoSuchMethodException &#123; Invokable invokable = Invokable.from(Student.class.getMethod(\"add\", int.class, int.class)); System.out.println(invokable.isPublic()); // true System.out.println(invokable.getDeclaringClass()); // class com.qinjiangbo.Student System.out.println(invokable.getParameters()); // [int arg0, int arg1] System.out.println(invokable.getOwnerType()); // com.qinjiangbo.Student System.out.println(invokable.getExceptionTypes()); // [java.lang.NumberFormatException] System.out.println(invokable.getReturnType()); // int System.out.println(invokable.getModifiers()); // 1 System.out.println(invokable.getName()); // add System.out.println(invokable.isOverridable()); // true System.out.println(invokable.isVarArgs()); // false System.out.println(invokable.isPublic()); // true System.out.println(invokable.isAbstract()); // false System.out.println(invokable.isAccessible()); // false System.out.println(invokable.isAnnotationPresent(ABC.class)); // true System.out.println(invokable.isStatic()); // false&#125; 总结从上面的代码我们可以看到，相当一部分代码都被很好地封装了起来，为我们提供了非常方便的实现反射的接口。具体的操作就不细说了，大家对照着上面的测试代码跑一遍就会慢慢体会了。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"反射","slug":"反射","permalink":"http://qinjiangbo.com/tags/反射/"}]},{"title":"Guava优美代码-20-Math","slug":"guava-math-20","date":"2016-11-06T17:26:05.000Z","updated":"2018-04-02T09:02:35.000Z","comments":true,"path":"guava-math-20.html","link":"","permalink":"http://qinjiangbo.com/guava-math-20.html","excerpt":"","text":"Guava中的数学数学处理有很多种方式，JDK里面也为我们提供相应的方法，为什么这里我们需要使用Guava里面方法呢？主要由以下几点原因： Guava Math针对各种不常见的溢出情况都有充分的测试；对溢出语义，Guava文档也有相应的说明；如果运算的溢出检查不能通过，将导致快速失败； Guava Math的性能经过了精心的设计和调优；虽然性能不可避免地依据具体硬件细节而有所差异，但Guava Math的速度通常可以与Apache Commons的MathUtils相比，在某些场景下甚至还有显著提升； Guava Math在设计上考虑了可读性和正确的编程习惯；IntMath.log2(x, CEILING)所表达的含义，即使在快速阅读时也是清晰明确的。而32-Integer.numberOfLeadingZeros(x – 1)对于阅读者来说则不够清晰。 数学工具类使用实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.qinjiangbo;import com.google.common.math.BigIntegerMath;import com.google.common.math.DoubleMath;import com.google.common.math.IntMath;import org.junit.Test;import java.math.BigInteger;import java.math.RoundingMode;/** * Date: 9/20/16 * Author: qinjiangbo@github.io */public class MathTest &#123; @Test public void testSqrt() &#123; System.out.println(IntMath.sqrt(26, RoundingMode.DOWN)); // 5 &#125; @Test public void testFactorial() &#123; System.out.println(DoubleMath.factorial(10)); // 3628800.0 &#125; @Test public void testMean() &#123; System.out.println(DoubleMath.mean(10, 276, 89, 46, 59)); // 96.0 &#125; @Test public void testDivide() &#123; System.out.println(IntMath.divide(10, 3, RoundingMode.UP)); &#125; @Test public void testGcd() &#123; System.out.println(IntMath.gcd(60, 24)); // 12 &#125; @Test public void testMod() &#123; System.out.println(IntMath.mod(192, 54)); // 30 &#125; @Test public void testPow() &#123; System.out.println(IntMath.pow(2, 10)); // 1024 &#125; @Test public void testIsPowerOfTwo() &#123; System.out.println(IntMath.isPowerOfTwo(36)); // false &#125; @Test public void testBinomial() &#123; System.out.println(IntMath.binomial(10, 4)); // 210 [等于C(10, 4)] &#125;&#125; 总结上面的代码中方法名称是自解释型的，读者朋友可以自己查看这些代码来体会Guava是如何来处理数学中的常见运算的。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Math","slug":"Math","permalink":"http://qinjiangbo.com/tags/Math/"}]},{"title":"Guava优美代码-19-EventBus","slug":"guava-eventbus-19","date":"2016-11-06T17:10:27.000Z","updated":"2018-04-02T09:02:07.000Z","comments":true,"path":"guava-eventbus-19.html","link":"","permalink":"http://qinjiangbo.com/guava-eventbus-19.html","excerpt":"","text":"Guava事件总线EventBus是Guava的事件处理机制，是设计模式中的观察者模式（生产/消费者编程模型）的优雅实现。对于事件监听和发布订阅模式，EventBus是一个非常优雅和简单解决方案，我们不用创建复杂的类和接口层次结构。 对于观察者模式，我这里就不再赘述了，大家可以去我的另一篇博文《设计模式学习之观察者模式(Observer)》里面详细了解观察者模式。 EventBus使用实例单事件监听消息监听 123456789101112131415161718192021package com.qinjiangbo.service;import com.google.common.eventbus.Subscribe;/** * Date: 9/20/16 * Author: qinjiangbo@github.io */public class EventListener &#123; public int lastMessage = 0; @Subscribe public void listen(OurTestEvent event) &#123; lastMessage = event.getMessage(); &#125; public int getLastMessage() &#123; return lastMessage; &#125;&#125; 消息发送 123456789101112131415161718package com.qinjiangbo.service;/** * Date: 9/20/16 * Author: qinjiangbo@github.io */public class OurTestEvent &#123; private final int message; public OurTestEvent(int message) &#123; this.message = message; &#125; public int getMessage() &#123; return message; &#125;&#125; 测试类 12345678@Testpublic void testReceiveEvent() &#123; EventBus eventBus = new EventBus(\"test\"); EventListener eventListener = new EventListener(); eventBus.register(eventListener); eventBus.post(new OurTestEvent(200)); System.out.println(eventListener.getLastMessage());&#125; // 200 多事件监听多事件监听类 12345678910111213141516171819202122232425262728293031package com.qinjiangbo.service;import com.google.common.eventbus.Subscribe;/** * Date: 9/20/16 * Author: qinjiangbo@github.io */public class MultipleListener &#123; public Integer lastInteger; public Long lastLong; @Subscribe public void listenInteger(Integer event) &#123; lastInteger = event; &#125; @Subscribe public void listenLong(Long event) &#123; lastLong = event; &#125; public Integer getLastInteger() &#123; return lastInteger; &#125; public Long getLastLong() &#123; return lastLong; &#125;&#125; 测试类 12345678910@Testpublic void testReceiveMultipleEvents() &#123; EventBus eventBus = new EventBus(\"test\"); MultipleListener multipleListener = new MultipleListener(); eventBus.register(multipleListener); eventBus.post(new Integer(100)); eventBus.post(new Long(200L)); System.out.println(multipleListener.getLastInteger()); // 100 System.out.println(multipleListener.getLastLong()); // 200&#125; 总结事件监听者[Listeners]监听特定事件（如，CustomerChangeEvent）： 传统实现：定义相应的事件监听者类，如CustomerChangeEventListener； EventBus实现：以CustomerChangeEvent为唯一参数创建方法，并用Subscribe注解标记。 把事件监听者注册到事件生产者： 传统实现：调用事件生产者的registerCustomerChangeEventListener方法；这些方法很少定义在公共接口中，因此开发者必须知道所有事件生产者的类型，才能正确地注册监听者； EventBus实现：在EventBus实例上调用EventBus.register(Object)方法；请保证事件生产者和监听者共享相同的EventBus实例。 按事件超类监听（如，EventObject甚至Object）： 传统实现：很困难，需要开发者自己去实现匹配逻辑； EventBus实现：EventBus自动把事件分发给事件超类的监听者，并且允许监听者声明监听接口类型和泛型的通配符类型（wildcard，如 ? super XXX）。 检测没有监听者的事件： 传统实现：在每个事件分发方法中添加逻辑代码（也可能适用AOP）； EventBus实现：监听DeadEvent；EventBus会把所有发布后没有监听者处理的事件包装为DeadEvent（对调试很便利）。 事件生产者[Producers]管理和追踪监听者： 传统实现：用列表管理监听者，还要考虑线程同步；或者使用工具类，如EventListenerList； EventBus实现：EventBus内部已经实现了监听者管理。 向监听者分发事件： 传统实现：开发者自己写代码，包括事件类型匹配、异常处理、异步分发； EventBus实现：把事件传递给EventBus.post(Object)方法。异步分发可以直接用EventBus的子类AsyncEventBus。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"EventBus","slug":"EventBus","permalink":"http://qinjiangbo.com/tags/EventBus/"}]},{"title":"Guava优美代码-18-哈希","slug":"guava-hash-18","date":"2016-11-06T15:40:11.000Z","updated":"2018-04-02T09:02:20.000Z","comments":true,"path":"guava-hash-18.html","link":"","permalink":"http://qinjiangbo.com/guava-hash-18.html","excerpt":"","text":"Guava哈希算法Java内建的散列码(hash code)概念被限制为32位，并且没有分离散列算法和它们所作用的数据，因此很难用备选算法进行替换。此外，使用Java内建方法实现的散列码通常是劣质的，部分是因为它们最终都依赖于JDK类中已有的劣质散列码。 Object.hashCode往往很快，但是在预防碰撞上却很弱，也没有对分散性的预期。这使得它们很适合在散列表中运用，因为额外碰撞只会带来轻微的性能损失，同时差劲的分散性也可以容易地通过再散列来纠正（Java中所有合理的散列表都用了再散列方法）。然而，在简单散列表以外的散列运用中，Object.hashCode几乎总是达不到要求——因此，Guava为我们提供了补充的Hash工具类。 Guava哈希工具类HashFunctionHashFunction是一个单纯的（引用透明的）、无状态的方法，它把任意的数据块映射到固定数目的位指，并且保证相同的输入一定产生相同的输出，不同的输入尽可能产生不同的输出。 HasherHashFunction的实例可以提供有状态的Hasher，Hasher提供了流畅的语法把数据添加到散列运算，然后获取散列值。Hasher可以接受所有原生类型、字节数组、字节数组的片段、字符序列、特定字符集的字符序列等等，或者任何给定了Funnel实现的对象。 FunnelFunnel描述了如何把一个具体的对象类型分解为原生字段值，从而写入PrimitiveSink。 HashCode一旦Hasher被赋予了所有输入，就可以通过hash()方法获取HashCode实例（多次调用hash()方法的结果是不确定的）。HashCode可以通过asInt()、asLong()、asBytes()方法来做相等性检测，此外，writeBytesTo(array, offset, maxLength)把散列值的前maxLength字节写入字节数组。 HashingHashing类提供了若干哈希函数，以及运算HashCode对象的工具方法。 md5 sha256 sha512 sha1 murmur3_128 murmur3_32 goodFastHash 哈希工具类使用实例防碰撞哈希123456789101112131415161718192021222324252627282930@Testpublic void testMd5Hash() &#123; Student student1 = new Student(2012302580314l, 21, \"Richard\"); Student student2 = new Student(2012302580311l, 21, \"Richard\"); HashFunction hashFunction = Hashing.md5(); HashCode hashCod1 = hashFunction.newHasher() .putObject(student1, (Funnel&lt;Student&gt;) (from, into) -&gt; into .putLong(from.sid) .putInt(from.age) .putString(from.name, Charsets.UTF_8)).hash(); HashCode hashCode2 = hashFunction.newHasher() .putObject(student2, (Funnel&lt;Student&gt;) (from, into) -&gt; into .putLong(from.sid) .putInt(from.age) .putString(from.name, Charsets.UTF_8)).hash(); System.out.println(hashCod1.asInt()); System.out.println(hashCode2.asInt());&#125;class Student &#123; final long sid; final int age; final String name; Student(long sid, int age, String name) &#123; this.sid = sid; this.age = age; this.name = name; &#125;&#125; 一致性哈希123456789101112@Testpublic void testConsistentHash() &#123; List&lt;String&gt; ips = Lists.newArrayList(\"192.168.1.100\", \"192.168.1.110\", \"192.168.1.120\"); long ipHashCode1 = Hashing.md5().newHasher().putString(ips.get(0), Charsets.UTF_8).hash().asLong(); long ipHashCode2 = Hashing.md5().newHasher().putString(ips.get(1), Charsets.UTF_8).hash().asLong(); long ipHashCode3 = Hashing.md5().newHasher().putString(ips.get(2), Charsets.UTF_8).hash().asLong(); System.out.println(\"ip1: \" + Hashing.consistentHash(ipHashCode1, 3)); System.out.println(\"ip2: \" + Hashing.consistentHash(ipHashCode2, 3)); System.out.println(\"ip3: \" + Hashing.consistentHash(ipHashCode3, 3));&#125; 上面两个例子，分别从防碰撞和分布性两个角度来说明哈希工具类的使用方法的。首先是防碰撞，第一个测试采用了md5方式，当然了，还可以使用其他的一些算法，不过md5算法是比较好的选择，这种方式能有效地保证各个对象的hash值不发生碰撞。第二种方式是一致性哈希算法，这种方式适用范围较广，一般用在分布式环境下，当请求过多的时候，一致性哈希能有效地将请求均匀地发送到不同的主机上执行，保证了很好的负载均衡。 总结关于一致性哈希我建议读者到CSDN的这篇博文下好好了解一下，这篇文章的作者对一致性哈希有非常透彻的理解，能帮助大家很好地理解一致性哈希是什么以及它能做什么。 CSDN博文地址：http://blog.csdn.net/cywosp/article/details/23397179/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Hash","slug":"Hash","permalink":"http://qinjiangbo.com/tags/Hash/"}]},{"title":"Guava优美代码-17-IO操作","slug":"guava-io-17","date":"2016-11-06T14:41:09.000Z","updated":"2018-04-02T09:02:32.000Z","comments":true,"path":"guava-io-17.html","link":"","permalink":"http://qinjiangbo.com/guava-io-17.html","excerpt":"","text":"Guava文件IO操作博主认为JDK中属文件IO的操作最麻烦而且最容易出错了，比如什么Stream啊，Reader啊，太多了，时间长了就容易记不住，经常写的话还是OK的，因为很熟练嘛，哈哈！那有没有什么方法能解放我们的文件操作呢？答案是Guava！Guava为我们提供了文件IO的各种工具类，其中使用最多的就是Files。下面我们仔细讨论Files的具体使用方式。 Files使用实例(1) 读文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final String FILE_DIR = \"/Users/Richard/Documents/R/\";@Testpublic void testReadLines() throws IOException &#123; String fileName = \"data.txt\"; File file = new File(FILE_DIR + fileName); List&lt;String&gt; lines = Files.readLines(file, Charsets.UTF_8); for (String line : lines) &#123; System.out.println(line); &#125;&#125;@Testpublic void testReadFirstLine() throws IOException &#123; String fileName = \"data.txt\"; File file = new File(FILE_DIR + fileName); String line = Files.readFirstLine(file, Charsets.UTF_8); System.out.println(line); // I have a dream,&#125;@Testpublic void testFileToByteArray() throws IOException &#123; String fileName = \"data.txt\"; File file = new File(FILE_DIR + fileName); byte[] bytes = Files.toByteArray(file); for (byte bt : bytes) &#123; System.out.println(bt + \" : \" + (char) bt); &#125;&#125;@Testpublic void testFileToString() throws IOException &#123; String fileName = \"data.txt\"; File file = new File(FILE_DIR + fileName); String contents = Files.toString(file, Charsets.UTF_8); System.out.println(contents);&#125;@Testpublic void testNewReader() throws IOException &#123; String fileName = \"data.txt\"; File file = new File(FILE_DIR + fileName); BufferedReader bufferedReader = Files.newReader(file, Charsets.UTF_8); String line; while ((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; bufferedReader.close();&#125; 上面的代码分别展示了如何从文件中读取数据，Guava的语法非常的简洁，极大地简化了我们读取文件的操作。而且提供了多种多样的方式来读取数据，比如readLines，readFirstLine，fileToByteArray以及fileToString等，开发者只需要关心文件中的数据，并不需要关心具体是怎么读取的。 (2) 写文件1234567891011121314151617181920212223242526272829303132333435363738394041public final String FILE_DIR = \"/Users/Richard/Documents/R/\";@Testpublic void testWriteWithByteArray() throws IOException &#123; String fileName = \"data2.txt\"; File file = new File(FILE_DIR + fileName); String lyrics = \"I will not make the same mistakes that you did\\n\" + \"I will not let myself cause my heart so much misery\\n\" + \"I will not break the way you did\\n\" + \"You fell so hard\\n\" + \"I learned the hard way, to never let it get that far\"; byte[] lyricsArray = lyrics.getBytes(); Files.write(lyricsArray, file);&#125;@Testpublic void testWriteWithCharSequence() throws IOException &#123; String fileName = \"data2.txt\"; File file = new File(FILE_DIR + fileName); String lyrics = \"I will not make the same mistakes that you did\\n\" + \"I will not let myself cause my heart so much misery\\n\" + \"I will not break the way you did\\n\" + \"You fell so hard\\n\" + \"I learned the hard way, to never let it get that far\"; CharSequence charSequence = lyrics.subSequence(0, lyrics.length() - 1); Files.write(charSequence, file, Charsets.UTF_8);&#125;@Testpublic void testNewWriter() throws IOException &#123; String fileName = \"data2.txt\"; File file = new File(FILE_DIR + fileName); String lyrics = \"I will not make the same mistakes that you did\\n\" + \"I will not let myself cause my heart so much misery\\n\" + \"I will not break the way you did\\n\" + \"You fell so hard\\n\" + \"I learned the hard way, to never let it get that far\"; BufferedWriter bufferedWriter = Files.newWriter(file, Charsets.UTF_8); bufferedWriter.write(lyrics); bufferedWriter.close();&#125; 上面的代码主要是测试如何将数据写入文件，这里Guava提供了三种方式，以字节数组，以字符串以及新建一个Writer对象。博主推荐大家使用前面两种方式，因为大家无需手动地去关闭流，第三种需要开发者手动关闭这个Writer，稍不注意会引起一些错误。 (3) 更新文件最后修改时间123456789101112public final String FILE_DIR = \"/Users/Richard/Documents/R/\";@Testpublic void testTouch() throws IOException &#123; String fileName = \"data.txt\"; File file = new File(FILE_DIR + fileName); System.out.println(new Date(file.lastModified())); // Sun Nov 06 21:49:19 CST 2016 Files.touch(file); System.out.println(new Date(file.lastModified())); // Sun Nov 06 22:14:26 CST 2016&#125; 这个我必须得单独拿出来介绍，因为博主发现这个方法名字取得太好啦，哈哈！和Linux中的touch命令一样，而且功能一样，都是更改文件的最后修改时间，如果文件不存在，就新建一个文件，真的是不得不佩服Guava的开发人员代码功底！代码可读性非常好！ 总结Guava中文件操作有很多，除了上面的读写修改之外，还有以下的操作，读者朋友们感兴趣的可以自己看一下： 方法名 方法说明 createParentDirs(File) 必要时为文件创建父目录 getFileExtension(String) 返回给定路径所表示文件的扩展名 getNameWithoutExtension(String) 返回去除了扩展名的文件名 simplifyPath(String) 规范文件路径，并不总是与文件系统一致，请仔细测试 fileTreeTraverser() 返回TreeTraverser用于遍历文件树 文件操作值得花时间好好看一下！^_^！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Files","slug":"Files","permalink":"http://qinjiangbo.com/tags/Files/"}]},{"title":"Guava优美代码-16-区间","slug":"guava-range-16","date":"2016-11-06T11:45:04.000Z","updated":"2018-04-02T09:03:12.000Z","comments":true,"path":"guava-range-16.html","link":"","permalink":"http://qinjiangbo.com/guava-range-16.html","excerpt":"","text":"Guava区间Range区间，有时也称为范围，是特定域中的凸性（非正式说法为连续的或不中断的）部分。在形式上，凸性表示对a&lt;=b&lt;=c, range.contains(a)且range.contains(c)意味着range.contains(b)。 Range的表示形式 区间 数学表达式 (a..b) {a &lt; x &lt; b} [a..b] {a &lt;= x &lt;= b} [a..b) {a &lt;= x &lt; b} (a..b] {a &lt; x &lt;= b} (a..+∞) {x &gt; a} [a..+∞) {x &gt;= a} (-∞..b) {x &lt; b} (-∞..b] {x &lt;= b} (-∞..+∞) 所有值 上面的a、b称为端点 。为了提高一致性，Guava中的Range要求上端点不能小于下端点。上下端点有可能是相等的，但要求区间是闭区间或半开半闭区间（至少有一个端点是包含在区间中的）。 区间构建 区间 方法 (a..b) open(C, C) [a..b] closed(C, C) [a..b) closedOpen(C, C) (a..b] openClosed(C, C) (a..+∞) greaterThan(C) [a..+∞) atLeast(C) (-∞..b) lessThan(C) (-∞..b] atMost(C) (-∞..+∞) all() Range使用实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.qinjiangbo;import com.google.common.collect.*;import org.junit.Test;import java.util.ArrayList;import java.util.Set;/** * Date: 9/19/16 * Author: qinjiangbo@github.io */public class RangesTest &#123; @Test public void testCheckThatElementIsInRange() &#123; Range&lt;Integer&gt; range = Range.closed(2, 20); // [2, 20] Range&lt;Integer&gt; rangeWithRightOpen = Range.closedOpen(2, 20); // [2, 20) System.out.println(range.contains(20)); // true System.out.println(rangeWithRightOpen.contains(20)); // false &#125; @Test public void testCheckThatRangeIsEnclosedInOtherRange() &#123; Range&lt;Long&gt; range = Range.openClosed(2L, 20L); // (2, 20] Range&lt;Long&gt; smallerRange = Range.closed(1L, 15L); // [1, 15] System.out.println(range.encloses(smallerRange)); // false Range newRange = range.span(smallerRange); System.out.println(newRange); // [1..20] Range newRange2 = range.intersection(smallerRange); System.out.println(newRange2); // (2..15] &#125; @Test public void testCheckThatAllElementIsInRange() &#123; Range&lt;Integer&gt; range = Range.closed(2, 20); System.out.println(range.containsAll(Lists.newArrayList(10, 20, 18, 8, 5, 19))); &#125; // true @Test public void testGenerateSetOfElementInRange() &#123; Range&lt;Integer&gt; range = Range.open(2, 20); Range&lt;Integer&gt; integers = range.canonical(DiscreteDomain.integers()); System.out.println(integers); // [3..20) System.out.println(integers.contains(6)); // true System.out.println(integers.contains(7)); // true &#125; @Test public void testCreateRangeForGivenNumbers() &#123; ArrayList&lt;Integer&gt; numbers = Lists.newArrayList(4, 3, 6, 8, 5, 9); Range&lt;Integer&gt; range = Range.encloseAll(numbers); System.out.println(range.lowerEndpoint() == 3); // true System.out.println(range.upperEndpoint() == 9); // true &#125; @Test public void testRangeMap() &#123; RangeMap&lt;Integer, String&gt; rangeMap = TreeRangeMap.create(); rangeMap.put(Range.closed(1, 19), \"foo\"); System.out.println(\"rangeMap: \" + rangeMap); // rangeMap: [[1‥19]=foo] rangeMap.put(Range.open(3, 6), \"bar\"); System.out.println(\"rangeMap: \" + rangeMap); // rangeMap: [[1‥3]=foo, (3‥6)=bar, [6‥19]=foo] rangeMap.put(Range.open(10, 20), \"foo\"); System.out.println(\"rangeMap: \" + rangeMap); // rangeMap: [[1‥3]=foo, (3‥6)=bar, [6‥10]=foo, (10‥20)=foo] rangeMap.remove(Range.closed(5, 11)); System.out.println(\"rangeMap: \" + rangeMap); // rangeMap: [[1‥3]=foo, (3‥5)=bar, (11‥20)=foo] &#125; @Test public void testRangeSet() &#123; RangeSet&lt;Integer&gt; rangeSet = TreeRangeSet.create(); rangeSet.add(Range.closed(1, 10)); System.out.println(\"rangeSet: \" + rangeSet); // rangeSet: [[1‥10]] rangeSet.add(Range.closedOpen(11, 15)); System.out.println(\"rangeSet: \" + rangeSet); // rangeSet: [[1‥10], [11‥15)] rangeSet.add(Range.open(15, 20)); System.out.println(\"rangeSet: \" + rangeSet); // rangeSet: [[1‥10], [11‥15), (15‥20)] rangeSet.add(Range.closedOpen(20, 25)); System.out.println(\"rangeSet: \" + rangeSet); // rangeSet: [[1‥10], [11‥15), (15‥25)] &#125;&#125; 说明一下，上面的代码主要测试了区间的contains包含方法，span取并集方法，intersection取交集方法，lowerEndpoint和upperEndpoint取端点方法等方法。我们可以很方便的利用区间完成元素集合的创建和筛选。 总结区间一般在开发中使用的不多，但是既然Guava为我们提供了如此好的方法，我们有必要好好了解和使用它。因为一旦我们的项目需要使用相关的操作时，Range区间能为我们提供最高效的解决方案。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"区间","slug":"区间","permalink":"http://qinjiangbo.com/tags/区间/"}]},{"title":"Guava优美代码-15-基本类型","slug":"guava-primitive-15","date":"2016-11-06T11:17:20.000Z","updated":"2018-04-02T09:03:08.000Z","comments":true,"path":"guava-primitive-15.html","link":"","permalink":"http://qinjiangbo.com/guava-primitive-15.html","excerpt":"","text":"Guava基本类型关于基本类型，我们在Java中有：byte、short、int、long、float、double、char和boolean。我们知道除了这些之外，还有关于这些基本类型的包装类：Byte、Short、Integer、Long、Float、Double、Character和Boolean。原因是这些基本类型没法当成对象或者泛型的参数使用。这意味着许多通用的方法都不支持它们。基于这个原因，Guava提供了若干通用工具，包括原生类型数组与集合API的交互，原生类型和字节数组的相互转换，以及对某些原生类型的无符号形式的支持。 Java基本类型与Guava对应工具类 原生类型 Guava工具类 byte Bytes, SignedBytes, UnsignedBytes short Shorts int Ints, UnsignedInteger, UnsignedInts long Longs, UnsignedLong, UnsignedLongs float Floats double Doubles char Chars boolean Booleans Bytes工具类没有定义任何区分有符号和无符号字节的方法，而是把它们都放到了SignedBytes和UnsignedBytes工具类中，因为字节类型的符号性比起其它类型要略微含糊一些。 int和long的无符号形式方法在UnsignedInts和UnsignedLongs类中，但由于这两个类型的大多数用法都是有符号的，Ints和Longs类按照有符号形式处理方法的输入参数。 此外，Guava为int和long的无符号形式提供了包装类，即UnsignedInteger和UnsignedLong，以帮助你使用类型系统，以极小的性能消耗对有符号和无符号值进行强制转换。 基本类型使用实例我们说基本类型的操作大多都是一样的，所以我就不每一个类都给出具体的实例啦，这里我们以Ints工具类为例，来解释Guava中基本类型工具类的使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.qinjiangbo;import com.google.common.collect.Lists;import com.google.common.primitives.Ints;import org.junit.Test;import java.util.List;/** * Date: 9/20/16 * Author: qinjiangbo@github.io */public class IntsTest &#123; @Test public void testFindGivenNumberInArray() &#123; final int[] array1 = new int[]&#123;0, 15, 49&#125;; final int[] array2 = new int[]&#123;5, 2, 4, -18, 450&#125;; System.out.println(Ints.contains(array1, 49)); // true System.out.println(Ints.indexOf(array2, 4)); // 2 &#125; @Test public void testConcatArrays() &#123; final int[] array1 = new int[]&#123;0, 15, 4, 49&#125;; final int[] array2 = new int[]&#123;5, 2, 4, -18, 450&#125;; System.out.println(Ints.concat(array1, array2).length); // 9 &#125; @Test public void testJoinArrayUsingSeprator() &#123; final int[] array1 = new int[]&#123;0, 15, 4, 49&#125;; final int[] array2 = new int[]&#123;5, 2, 4, -18, 450&#125;; System.out.println(Ints.join(\" : \", array2)); // 5 : 2 : 4 : -18 : 450 &#125; @Test public void testFindMaxAndMinInArray() &#123; final int[] array = new int[]&#123;5, 2, 4, -18, 450&#125;; System.out.println(Ints.min(array)); // -18 System.out.println(Ints.max(array)); // 450 &#125; @Test public void testToArray() &#123; List&lt;Integer&gt; ints = Lists.newArrayList(1, 45, 5, 76, 34, 26, 68); System.out.println(Ints.toArray(ints)); // [I@1b701da1 System.out.println(Ints.toArray(ints)[2]); // 5 &#125; @Test public void testAsList() &#123; final int[] ints = new int[]&#123;1, 45, 36, 76, 23, 6&#125;; System.out.println(Ints.asList(ints)); // [1, 45, 36, 76, 23, 6] &#125;&#125; 上面的代码中注释的部分表示每个测试方法的打印值，大家可以根据打印的值来查看Ints类相应的使用方法。我们注意到Ints类能处理数组转链表以及链表转数组的功能，以及在一个数组中找出最大值和最小值，将一个数组使用某个连接符连接起来成为一个字符串，还有很多很多使用的方法。为我们处理基本类型带来了极大的便利。其他的基本类型工具类可以参考Ints的使用方法。 总结Guava以极小的代价为我们写了一套完整的基本类型处理工具类，让我们可以更高效地处理基本类型相关的问题。其实有很多方法在JDK中我们就会经常使用到，比如说toArray以及asList。Guava没有简单地复用这些方法作为它的方法，而是重新设计实现了一遍，所以效率非常高，建议多多使用Guava提供的方法，它和JDK的性能谁会更高一点？Guava在大多数情况下在相同的或者类似的方法下面都做了大量的优化，所以Guava的效率更高一点，而且最重要的是Guava更优美！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"基本类型","slug":"基本类型","permalink":"http://qinjiangbo.com/tags/基本类型/"}]},{"title":"Guava优美代码-14-Strings","slug":"guava-strings-14","date":"2016-11-06T08:32:14.000Z","updated":"2018-04-02T09:03:20.000Z","comments":true,"path":"guava-strings-14.html","link":"","permalink":"http://qinjiangbo.com/guava-strings-14.html","excerpt":"","text":"Guava字符串处理字符串不管在什么时候都是我们最为关心的，尤其是从事Web开发的朋友，字符串的各种操作也都是工作中必备的技能。Google也看到了我们广大的开发者处理字符串的痛点，于是他们为我们带来了Strings的工具类，这个工具类套件包含了很多有用的类，比如Strings类本身，还有用于分割的Splitter类，用于连接的Joiner类以及用于字符串匹配的CharMatcher类等等。下面我们就针对这些类进行详细的说明。 Strings类使用实例123456789101112131415161718192021222324252627282930313233343536373839404142package com.qinjiangbo;import com.google.common.base.Strings;import org.junit.Test;/** * Date: 9/12/16 * Author: qinjiangbo@github.io */public class StringsTest &#123; @Test public void testNullOrEmptyString() &#123; System.out.println(Strings.isNullOrEmpty(\"\")); // true &#125; @Test public void testNullOrEmptyString2() &#123; System.out.println(Strings.isNullOrEmpty(null)); // true &#125; @Test public void testStringsPadEnd() &#123; System.out.println(Strings.padEnd(\"Hello World\", 20, '-')); // Hello World--------- &#125; @Test public void testStringsPadStart() &#123; System.out.println(Strings.padStart(\"Hello World\", 20, '*')); // *********Hello World &#125; @Test public void testStringsRepeat() &#123; System.out.println(Strings.repeat(\"I love you!\\n\", 20)); // I love you! // I love you! // ...... // I love you! &#125;&#125; 上面的代码中的测试方法都是自解释型的，所以我就不一一做详细的介绍了。不过需要解释一下其中的pad相关的方法，pad就是padding的简写，有两个方法padStart和padEnd，这两个方法说的是字符串的偏移，案例中Strings.padStart(&quot;Hello World&quot;, 20, &#39;*&#39;)是从起始位置向右偏移，左边空出来的位置使用*号填充，同理，Strings.padEnd(&quot;Hello World&quot;, 20, &#39;-&#39;)是从起始位置向左边偏移，右边空出来的部分使用-填充。 Splitter类使用实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.qinjiangbo;import com.google.common.base.CharMatcher;import com.google.common.base.Splitter;import com.google.common.collect.Lists;import org.junit.Test;import java.util.List;/** * Date: 9/10/16 * Author: qinjiangbo@github.io */public class SplitterTest &#123; @Test public void testSplitOnSemicolons() &#123; Iterable&lt;String&gt; iterable = Splitter.on(\";\").split(\"Java;Scala;Php;Haskell\"); List&lt;String&gt; splittedList = Lists.newArrayList(iterable); System.out.println(splittedList.get(2).equals(\"Php\")); // true &#125; @Test public void testSplitOnRegExp() &#123; Iterable&lt;String&gt; iterable = Splitter.onPattern(\"\\\\d+\").split(\"Java13Scala41Php5C#6\"); List&lt;String&gt; splittedList = Lists.newArrayList(iterable); System.out.println(splittedList.get(2).equals(\"Php\")); // true &#125; @Test public void testSplitUsingCharMatcher() &#123; Iterable&lt;String&gt; iterable = Splitter.on(CharMatcher.inRange('3', '8')).split(\"Java3Scala4Haskell7Brain9Kotlin\"); List&lt;String&gt; splittedList = Lists.newArrayList(iterable); System.out.println(splittedList.get(3)); // Brain9Kotlin &#125; @Test public void testSplitOmitEmptyStrings() &#123; Iterable&lt;String&gt; iterable = Splitter.on(\";\").omitEmptyStrings().split(\"Java;Scala; ;;Haskell;;Kotlin\"); List&lt;String&gt; splittedList = Lists.newArrayList(iterable); System.out.println(splittedList.get(2)); // [说明一下,这里输出是空格] &#125; @Test public void testSplitTrimResults() &#123; Iterable&lt;String&gt; iterable = Splitter.on(\";\").trimResults().omitEmptyStrings().split(\"Java;Scala; ;;Haskell;;Kotlin\"); List&lt;String&gt; splittedList = Lists.newArrayList(iterable); System.out.println(splittedList.get(2)); // Haskell &#125; @Test public void testSplitOnFixedLength() &#123; Iterable&lt;String&gt; iterable = Splitter.fixedLength(7).split(\"Someone once told me that I was lucky!\"); List&lt;String&gt; splittedList = Lists.newArrayList(iterable); System.out.println(splittedList.get(1)); &#125;&#125; 我们很容易从这个类的名字知道，这个类是用来分割字符串的，其实Java中的String类也可以分割字符串，比如String.split()方法，但是为什么我们要使用Guava的Splitter类呢？原因很简单，因为它更简单而且更强大！上面的测试方法也都是自解释型的，所以我还是只打算解释其中一两个测试方法的使用。testSplitUsingCharMatcher这个方法使用了我们即将要介绍的CharMatcher类，这个类能极大地提升这个分割的灵活性和多样性，基本上能涵盖我们平时开发中的所有要求。关于CharMatcher类具体的使用方式我们接下来介绍。 CharMatcher类使用实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.qinjiangbo;import com.google.common.base.CharMatcher;import org.junit.Test;/** * Date: 9/10/16 * Author: qinjiangbo@github.io */public class CharMatcherTest &#123; @Test public void testNotMatchChar() &#123; System.out.println(CharMatcher.noneOf(\"xZ\").matchesAnyOf(\"anything\")); &#125; // true @Test public void testMatchAny() &#123; System.out.println(CharMatcher.ANY.matchesAllOf(\"anything\")); &#125; // true @Test public void testMatchBreakingWhiteSpace() &#123; System.out.println(CharMatcher.BREAKING_WHITESPACE.matchesAllOf(\"\\r\\n\\r\\n\")); &#125; // true @Test public void testMatchDigits() &#123; System.out.println(CharMatcher.DIGIT.matchesAllOf(\"1212121\")); &#125; // true @Test public void testMatchDigits2() &#123; System.out.println(CharMatcher.DIGIT.matchesAnyOf(\"123abc123\")); &#125; // true @Test public void testMatchJavaDigits() &#123; System.out.println(CharMatcher.JAVA_DIGIT.matchesAllOf(\"123456\")); &#125; // true @Test public void testMatchJavaLetter() &#123; System.out.println(CharMatcher.JAVA_LETTER.matchesAllOf(\"Opera\")); &#125; // true @Test public void testMatchAscii() &#123; System.out.println(CharMatcher.ASCII.matchesAllOf(\"azt*1\")); &#125; // true @Test public void testMatchUpperCase() &#123; System.out.println(CharMatcher.JAVA_UPPER_CASE.matchesAllOf(\"JAVAC\")); &#125; // true @Test public void testMatchDigitsWithWhiteSpaces() &#123; System.out.println(CharMatcher.DIGIT.matchesAnyOf(\"1111 abc\")); &#125; // true @Test public void testMatchRetainsDigits() &#123; System.out.println(CharMatcher.DIGIT.retainFrom(\"123gb6789\")); &#125; // 1236789 @Test public void testMatchRetainsDigitsOrWhiteSpaces() &#123; System.out.println(CharMatcher.DIGIT.or(CharMatcher.WHITESPACE).retainFrom(\"Hello world 123 javac!\")); &#125; // 123 [注意123前后都变成空格了] @Test public void testMatchRetainsNothingAsConstrainsAreExcluding() &#123; System.out.println(CharMatcher.DIGIT.and(CharMatcher.JAVA_LETTER).retainFrom(\"hello 123 abc!\")); &#125; // [这里是空格] @Test public void testMatchRetainsDigitsAndLetters() &#123; System.out.println(CharMatcher.DIGIT.or(CharMatcher.JAVA_LETTER).retainFrom(\"hello 123 abc!\")); &#125; // hello123abc @Test public void testMatchCollapseAllDigitsByX() &#123; System.out.println(CharMatcher.DIGIT.collapseFrom(\"Hello 167 j176\", 'x')); &#125; // Hello x jx @Test public void testMatchReplaceAllDigitsByX() &#123; System.out.println(CharMatcher.DIGIT.replaceFrom(\"Hello 17689 jik009\", 'x')); &#125; // Hello xxxxx jikxxx @Test public void testMatchReplaceAllLettersByX() &#123; System.out.println(CharMatcher.JAVA_LETTER.or(CharMatcher.is('*')).replaceFrom(\"password 97321321 **65\", 'X')); &#125; // XXXXXXXX 97321321 XX65 @Test public void testMatchCountIn() &#123; System.out.println(CharMatcher.DIGIT.countIn(\"*** 121 * a ** b\")); &#125; // 3 @Test public void testMatchCountIn2() &#123; System.out.println(CharMatcher.is('*').countIn(\"*** 121 * a ** b\")); &#125; // 6 @Test public void testMatchIndexIn() &#123; System.out.println(CharMatcher.is('*').indexIn(\"666 *** 121 * a ** b\")); &#125; // 4 @Test public void testMatchLastIndexIn() &#123; System.out.println(CharMatcher.is('*').lastIndexIn(\"666 *** 121 * a ** b\")); &#125; // 17 @Test public void testMatchRemoveDigitsBetween3And6() &#123; System.out.println(CharMatcher.inRange('3', '8').removeFrom(\"117787321daa096aa453aa299\")); &#125; // 1121daa09aaaa299 @Test public void testNegateMatchingAbove() &#123; System.out.println(CharMatcher.inRange('3', '8').negate().removeFrom(\"117787321daa096aa453aa299\")); &#125; // 778736453 @Test public void testRemoveStartingAndEndingDollarsAndKeepOthersUnchanged() &#123; System.out.println(CharMatcher.is('$').trimFrom(\"$$$ This is a $ sign $$$\")); &#125; // This is a $ sign [前后都有空格] @Test public void testRemoveOnlyStartingDollarsAndKeepOthersUnchanged() &#123; System.out.println(CharMatcher.is('$').trimLeadingFrom(\"$$$ This is a $ sign $$$\")); &#125; // This is a $ sign $$$ @Test public void testRemoveOnlyEndingDollarsAndKeepOthersUnchanged() &#123; System.out.println(CharMatcher.is('$').trimTrailingFrom(\"$$$ This is a $ sign $$$\")); &#125; // $$$ This is a $ sign @Test public void testRemoveStartingAndEndingDollarsAndReplaceOtherDollarsWithX() &#123; System.out.println(CharMatcher.is('$').trimAndCollapseFrom(\"$$$ This is a $$ and $ sign $$$\", 'X')); &#125; // This is a X and X sign&#125; CharMatcher为我们提供了非常强大的处理字符串的能力，可以看到CharMatcher类基本上涵盖了我们操作字符串的各种方式。大家可以仔细看看上面的测试实例，并且好好琢磨琢磨它的使用方式。 Joiner类使用实例12345678910111213141516171819202122232425262728293031323334353637383940414243package com.qinjiangbo;import com.google.common.base.Joiner;import com.google.common.collect.Maps;import org.junit.Test;import java.util.Arrays;import java.util.List;import java.util.Map;/** * Date: 9/10/16 * Author: qinjiangbo@github.io */public class JoinerTest &#123; @Test public void testJoinerOn() &#123; List&lt;String&gt; languages = Arrays.asList(\"Java\", \"Haskell\", \"Scala\", \"Brainfuck\"); System.out.println(Joiner.on(',').join(languages)); &#125; // Java,Haskell,Scala,Brainfuck @Test public void testJoinerJoinWithCommasAndOmitNulls() &#123; List&lt;String&gt; countriesWithNullValue = Arrays.asList(\"Poland\", \"Brazil\", \"Ukraine\", null, \"China\"); System.out.println(Joiner.on(',').skipNulls().join(countriesWithNullValue)); &#125; // Poland,Brazil,Ukraine,China @Test public void testJoinerJoinWithCommasAndReplaceNullWithDefaultValue() &#123; List&lt;String&gt; countriesWithNullValue = Arrays.asList(\"Poland\", \"Brazil\", \"Ukraine\", null, \"China\"); System.out.println(Joiner.on(',').useForNull(\"NONE\").join(countriesWithNullValue)); &#125; // Poland,Brazil,Ukraine,NONE,China @Test public void testJoinerJoinMap() &#123; Map&lt;Integer, String&gt; numberWords = Maps.newHashMap(); numberWords.put(1, \"one\"); numberWords.put(2, \"two\"); numberWords.put(3, null); numberWords.put(4, \"four\"); System.out.println(Joiner.on(\" | \").withKeyValueSeparator(\" -&gt; \").useForNull(\"Unknown\").join(numberWords)); &#125; // 1 -&gt; one | 2 -&gt; two | 3 -&gt; Unknown | 4 -&gt; four&#125; 需要说明一下最后一个测试方法，这个是将Joiner类应用到了Map上面，我们可以利用Joiner类将Map表现形式转换成为我们想要的形式，这样更加易于读和理解。 总结好了，Guava中的Strings相关的操作类在上面已经用实例代码进行了说明，每段代码都给出了相应的输出，测试全部通过。大家可以将上面的代码拷贝下来，自己到本机上跑一下，感受一下这段代码给我们带来的便捷与强大的操作能力。总的来说，Guava中涉及到字符串操作相关的类还有很多，这里不一一列出了。因为那些都没有上面列出的这些类方便和强大。我们主要是关注主要的类，我建议读者朋友们有时间自己还是多跑一跑上面的这些代码，更好地就是自己能动手敲一遍，这样更能加深自己的理解。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"字符串","slug":"字符串","permalink":"http://qinjiangbo.com/tags/字符串/"}]},{"title":"Guava优美代码-13-Predicate","slug":"guava-pridicate-13","date":"2016-11-06T07:11:49.000Z","updated":"2018-04-02T09:03:04.000Z","comments":true,"path":"guava-pridicate-13.html","link":"","permalink":"http://qinjiangbo.com/guava-pridicate-13.html","excerpt":"","text":"Guava函数式编程上一节篇文章我们说了Guava的Function函数的用法，这一节我们来说一说Predicate预言。Predicate的使用也是非常多的，因此读者朋友们也需要多多重视Predicate的用法。简单说一下Predicate和Function的区别，你可以理解为Predicate主要是用来判断一些条件成不成立的，而Function主要是用来执行一些操作的，侧重点不同。 Predicate和PredicatesPredicate&lt;T&gt;，它声明了单个方法boolean apply(T input)。Predicate对象通常也被预期为无副作用函数，并且”相等”语义与equals一致。 同样我们说Predicates提供了更多构造和处理Predicate的方法，下面是一些例子： 方法名 方法名 方法名 instanceOf(Class) assignableFrom(Class) contains(Pattern) in(Collection) isNull() alwaysFalse() alwaysTrue() equalTo(Object) compose(Predicate, Function) and(Predicate…) or(Predicate…) not(Predicate) Predicate使用案例和前一节的国家-首都的例子一样，我们使用相同的数据来说明。这里我们还是列出他们的源码，方便大家阅读。 CountryEnum.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.qinjiangbo.vo;import com.google.common.collect.Lists;import java.util.List;/** * Date: 9/4/16 * Author: qinjiangbo@github.io */public enum CountryEnum &#123; CHINA(\"CHINA\", \"BEIJING\", 2000, \"ASIA\"), US(\"US\", \"WASHINGTON DC\", 200, \"AMERICA\"), KOREA(\"KOREA\", \"SEUL\", 500, \"ASIA\"), GB(\"GB\", \"LONDON\", 1000, \"EURO\"), FINLAND(\"FINLAND\", \"\", 1000, \"EURO\"); private String name; private String capital; private int age; private String continent; private CountryEnum(String name, String capital, int age, String continent) &#123; this.name = name; this.capital = capital; this.age = age; this.continent = continent; &#125; public static List&lt;CountryEnum&gt; findCountries() &#123; return Lists.newArrayList(CHINA, US, KOREA, FINLAND, GB); &#125; public String getContinent() &#123; return continent; &#125; public void setContinent(String continent) &#123; this.continent = continent; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getCapital() &#123; return capital; &#125; public void setCapital(String capital) &#123; this.capital = capital; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 同样地，我们对国家-首都关系数据作出如下的判断： (1) 判断列表中的国家是否定义了首都123456789101112131415@Testpublic void testHasCapitalDefined() &#123; Predicate&lt;CountryEnum&gt; capitalCityProvidedPredicate = new Predicate&lt;CountryEnum&gt;() &#123; @Override public boolean apply(@Nullable CountryEnum country) &#123; return !Strings.isNullOrEmpty(country.getCapital()); &#125; &#125;; boolean allCountriesSpecifyCapital = Iterables.all( Lists.newArrayList(CountryEnum.CHINA, CountryEnum.GB, CountryEnum.FINLAND), capitalCityProvidedPredicate ); System.out.println(allCountriesSpecifyCapital); // false&#125; 上面这个结果是false，因为我们可以看到，上面的枚举类中FINLAND的首都是没有定义的，为空，所以这个预言的结果是false。 (2) 复合预言Composed Predicate1234567891011121314151617181920212223242526@Testpublic void testComposedPredicate() &#123; Predicate&lt;CountryEnum&gt; fromAsiaPredicate = new Predicate&lt;CountryEnum&gt;() &#123; @Override public boolean apply(@Nullable CountryEnum country) &#123; return country.getContinent().equals(\"ASIA\"); &#125; &#125;; Predicate&lt;CountryEnum&gt; historyPredicate = new Predicate&lt;CountryEnum&gt;() &#123; @Override public boolean apply(@Nullable CountryEnum country) &#123; return country.getAge() &gt; 1000; &#125; &#125;; Predicate&lt;CountryEnum&gt; composedPredicate = Predicates.and(fromAsiaPredicate, historyPredicate); Iterable&lt;CountryEnum&gt; filteredCountries = Iterables.filter(CountryEnum.findCountries(), composedPredicate); Iterator iterator = filteredCountries.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; // CHINA&#125; 输出的结果是CHINA，因为从数据来看，只有中国既是亚洲国家，历史也超过了1000年。所以她是唯一合格的选项。 (3) 预言包含关系123456@Testpublic void testContainsPredicate() &#123; Predicate&lt;CharSequence&gt; containsPredicate = Predicates.containsPattern(\"\\\\d\\\\d\"); boolean isContained = containsPredicate.apply(\"hello world 21!\"); System.out.println(isContained); // true&#125; 这个例子和上面的国家-首都数据无关了，纯粹是一个功能点的说明，这里我们需要判断一个句子中是否包含我们需要检测的字符串。这里我们使用了正则表达式\\\\d\\\\d，表示匹配连续的两个数字，hello world 21!中有21，所以这段代码结果是true。 总结简单总结一下，这篇博文里面知识简单地为大家介绍了Predicate类中的一些方法，其实Predicate类中还有很多实用的方法，大家可以自己调用Guava的相关方法好好体会。看的再多，不如自己动手敲一波！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Predicate","slug":"Predicate","permalink":"http://qinjiangbo.com/tags/Predicate/"}]},{"title":"设计模式学习之观察者模式","slug":"design-pattern-observation","date":"2016-11-04T17:25:44.000Z","updated":"2017-03-09T17:54:28.000Z","comments":true,"path":"design-pattern-observation.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-observation.html","excerpt":"","text":"什么是观察者模式观察者模式(Observer Design Pattern)定义了对象之间的一对多依赖，这样一来，当一个对象改变状态的时候，它的所有依赖者都会收到通知并自动更新。 出版者+订阅者=观察者模式如果你了解报纸的订阅方式，我想你基本上也就知道了观察者模式是怎样的一回事了。在观察者模式中我们一般使用主题来表示出版者，用观察者来表示订阅者。 观察者模式类图 可以看到整个类图非常简单，定义了两个接口Subject和Observer，然后Subject中包含了Observer的引用，以便于数据变化时能及时调用Observer的更新方法。Subject和Observer分别有自己的具体实现类，ConcreteSubject和ConcreteObserver。这个很重要，我们说过一个原则，针对接口编程，不针对实现编程。另外，大家也看到，具体的观察者ConcreteObserver中包含了一个ConcreteSubject的引用，这个是为了在Subject注册自己用的。 实例分析-气象站现在有一个气象站找到你做一个需求，要求做一个天气状况和天气预报推送的软件。这个系统分为三个部分。气象站（获取实际气象数据的物理装置）、天气数据对象（追踪天气天气数据，并更新布告板）以及布告板（显示天气给用户看）。 系统的结构简单描述下 如果我们接受这个项目，那我们需要做的事情就是建立一个应用，利用这个WeatherData对数据采样并及时更新三个布告板：目前状况、气象统计和天气预报。 好了，怎么做呢？我们挨个分析。 WeatherData气象数据类（主题）我们需要弄清楚这个WeatherData的具体功能是什么？目前已知的就是 WeatherData类具有getter方法，利用这个方法它可以获取各个观测指标，温度、湿度和气压。 其次当观测数据变化的时候，它需要通知布告板更新，这里我们定义一个方法来说明它measurementsChanged()，一旦数据发生变化，这个方法就会被调用。 我们需要实现三个布告板来显示天气的数据，目前状况，气象统计和天气预报。 布告板类（订阅者）布告板类的功能非常简单，被通知更新，以及显示天气的数据。 被通知更新，所以布告板里面需要提供一个更新方法，以便于及时更新布告板当前的数据。我们使用update方法来表示。 显示各个指标，这里我们使用display来表示。 代码实现首先是WeatherData，这里我们不讨论这个类的getter方法是如何获取数据的，因为这个涉及到物理方面的知识，我们就认为气象站给我们实时提供了这些数据，我们直接获取就行了。 先定义一个Subject接口 1234567891011121314151617181920212223package com.qinjiangbo.observer.subject;import com.qinjiangbo.observer.observer.Observer;/** * Created by IntelliJ IDEA. * Date: 8/16/15 4:55 PM * Author: Richard */public interface Subject &#123; //注册观察者 public void registerObserver(Observer o); //移除观察者 public void removeObserver(Observer o); //计算观察者数量 public int countObservers(); //通知观察者 public void notifyObservers();&#125; 接着实现Subject接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.qinjiangbo.observer.subject;import com.qinjiangbo.observer.observer.Observer;import java.util.ArrayList;/** * Created by IntelliJ IDEA. * Date: 8/16/15 5:00 PM * Author: Richard *///pushpublic class WeatherData implements Subject &#123; private ArrayList&lt;Observer&gt; list; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; list = new ArrayList&lt;Observer&gt;(); &#125; @Override public void registerObserver(Observer o) &#123; list.add(o); &#125; @Override public void removeObserver(Observer o) &#123; int index = list.indexOf(o); if(index != -1) &#123; list.remove(index); &#125; &#125; @Override public int countObservers() &#123; return list.size(); &#125; @Override public void notifyObservers() &#123; for (Observer observer: list) &#123; observer.update(temperature, humidity, pressure); &#125; &#125; public void measurementsChanged() &#123; notifyObservers(); &#125; /** * 设置各参数 * @param temperature * @param humidity * @param pressure */ public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125;&#125; 那么我们的主题就实现了。在主题里面我们统计了订阅者的数量，并且允许注册订阅者，当数据有更新时及时通知订阅者更新。 现在定义一个订阅者Observer 123456789101112package com.qinjiangbo.observer.observer;/** * Created by IntelliJ IDEA. * Date: 8/16/15 4:56 PM * Author: Richard */public interface Observer &#123; //更新天气信息 public void update(float temp, float humidity, float pressure);&#125; 根据需求分析我们需要实现两个订阅者，分别显示不同的资讯。但是显示的功能是公共的，这个可以单独提出来作为一个接口。 123456789101112package com.qinjiangbo.observer.observer;/** * Created by IntelliJ IDEA. * Date: 8/16/15 4:59 PM * Author: Richard */public interface DisplayElement &#123; //显示数据 public void display();&#125; 当前天气状态和气象数据 1234567891011121314151617181920212223242526272829303132package com.qinjiangbo.observer.observer;import com.qinjiangbo.observer.subject.Subject;/** * Created by IntelliJ IDEA. * Date: 8/16/15 5:15 PM * Author: Richard */public class CurrentConditionDisplay implements Observer, DisplayElement &#123; private float temperature; private float humidity; private float pressure; public CurrentConditionDisplay(Subject weatherData) &#123; weatherData.registerObserver(this); &#125; @Override public void display() &#123; System.out.println(\"current conditions: \" + temperature + \" F degrees and \"+ humidity + \"% humidity and pressure \" + pressure); &#125; @Override public void update(float temp, float humidity, float pressure) &#123; this.temperature = temp; this.humidity = humidity; this.pressure = pressure; display(); &#125;&#125; 天气预报 12345678910111213141516171819202122232425262728293031323334353637383940package com.qinjiangbo.observer.observer;import com.qinjiangbo.observer.subject.WeatherData2;import java.util.*;/** * Created by IntelliJ IDEA. * Date: 8/16/15 5:52 PM * Author: Richard */public class ForecastDisplay implements java.util.Observer, DisplayElement &#123; private float temperature; private float humidity; private float pressure; @SuppressWarnings(\"unused\") private Observable observable; public ForecastDisplay(Observable observable) &#123; this.observable = observable; observable.addObserver(this); &#125; @Override public void display() &#123; System.out.println(\"current conditions: \" + temperature + \" F degrees and \"+ humidity + \"% humidity and pressure \" + pressure); &#125; @Override public void update(Observable o, Object arg) &#123; if (o instanceof WeatherData2) &#123; WeatherData2 weatherData2 = (WeatherData2) o; this.temperature = weatherData2.getTemperature(); this.humidity = weatherData2.getHumidity(); this.pressure = weatherData2.getPressure(); display(); &#125; &#125;&#125; 最重要的是需要来一个测试，来认识一下模式是如何工作的？ 1234567891011121314151617181920package com.qinjiangbo.observer.test;import com.qinjiangbo.observer.observer.CurrentConditionDisplay;import com.qinjiangbo.observer.subject.WeatherData;/** * Created by IntelliJ IDEA. * Date: 8/16/15 5:21 PM * Author: Richard */public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); @SuppressWarnings(\"unused\") CurrentConditionDisplay currentConditionDisplay = new CurrentConditionDisplay(weatherData); weatherData.setMeasurements(80, 65, 30.4f); &#125;&#125; 结果 1current conditions: 80.0 F degrees and 65.0% humidity and pressure 30.4 Java中的观察者模式我们需要了解的是，Java也为我们提供了观察者模式非常好的实现，大家可以在java.util.Observerable和java.util.Obserever中查看。不知道发现没有，Java中的主题实现java.util.Observerable是一个具体的实现类！！！这不符合我们的设计要求啊！没办法，它就这么设计的，在JDK1.0版本就已经确定了，不过这会导致很多问题，比如我们继承这个类，但同时我需求添加许多其他的功能，这个直接限制了我们的复用。因为毕竟Java不支持多继承。 观察者模式总结观察者模式有很多广泛的应用，我们最熟悉就是Java Swing的监听事件的实现，用的就是观察者模式。使用过Java Swing的都知道每个控件我们都需要注册一些监听器，以便于相应对应的用户操作。 我们也说过，JDK中的观察者模式的实现是有很多缺陷的，但如果符合你的实际需求，可以使用，不过博主推荐你还是自己实现一个，因为这样灵活性和复用性更高。毕竟提升代码的复用性和灵活性不一直是我们研究设计模式追求的最终目标吗？ 设计模式GitHub仓库地址：https://github.com/QinJiangbo/DesignPatterns","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"观察者模式","slug":"观察者模式","permalink":"http://qinjiangbo.com/tags/观察者模式/"}]},{"title":"利用七牛云给Hexo博客加速","slug":"speed-hexo-blog-with-qiniu-cloud","date":"2016-11-04T01:10:13.000Z","updated":"2016-11-04T02:12:55.000Z","comments":true,"path":"speed-hexo-blog-with-qiniu-cloud.html","link":"","permalink":"http://qinjiangbo.com/speed-hexo-blog-with-qiniu-cloud.html","excerpt":"","text":"本文背景昨天夜里本来想写一篇设计模式的博文，先去查看了一下博客，忽然发现博客系统的css和js样式全部失效了。通过默认的访问方式全部都没有用，整个博客的用户体验非常差。然后我就开始找原因，因为采用的是阿里云CDN加速的，又是在深夜，我在想是不是阿里云官方在升级CDN系统导致我的全站样式文件全部失效，后来发现过了俩小时还不行，那就不是阿里云的问题了。然后一直找到3点钟还没有头绪，就睡了一觉，睡的时候还在想如何加载这个css和js的问题。 到了今天早上终于有头绪了，因为发现默认访问路径是当前路径加上当前系统根路径。那既然我的默认的访问方式不支持，那为什么不把相对路径改为绝对路径，这个时候我又想起了远方的朋友—七牛云！ 问题详述首先说一下我的博客系统，采用hexo 3.0+版本，主题采用的是PPOffice的Hueman。因为接下来的变化和修改都是基于这个主题来的，但是大家也不要担心，其实别的主题结构也一样，对照着改就行了。我们可以看到执行hexo g命令以后根路径下面会生成public文件夹，这个文件夹里面有我们需要的样式文件，是从hueman主题文件夹下的source文件夹拷贝过来的。 解决方案我们下面的任务就是将上图中的css，js和vendor三个文件夹全部上传至七牛云，怎么做呢？七牛云为我们提供了了官方的sdk支持，这下就方便多了。先贴一下脚本代码： 123456789101112131415161718192021222324252627282930313233343536373839404142# coding=utf-8\"\"\" Date: 04/11/2016 Author: qinjiangbo@github.io \"\"\"from qiniu import Auth, put_fileimport osimport reaccess_key = '/YOUR/ACCESS/KEY/HERE'secret_key = '/YOUR/SECRET/KEY/HERE'q = Auth(access_key, secret_key)bucket_name = 'static'# 根路径(对应修改为你博客的根路径)blog = '/Users/Richard/Github/qinjiangbo.github.io/'#public文件夹vendor_dir = 'public/vendor'css_dir = 'public/css'js_dir = 'public/js'def list_file(file_path): for path in os.listdir(file_path): full_path = os.path.join(file_path, path) if os.path.isfile(full_path): key = re.sub(r\".*?public/\", \"\", full_path) token = q.upload_token(bucket_name, key, 3600) ret, info = put_file(token, key, full_path) print(ret) print(info) if os.path.isdir(full_path): list_file(full_path)list_file(blog + vendor_dir)list_file(blog + css_dir)list_file(blog + js_dir) 等一下，先别着急运行代码，因为没有导入七牛的SDK一定会报错！！！具体有以下几步需要做： 首先到七牛的官网下载SDK，如果你还没注册七牛云的话需要先注册，然后进入开发者中心。如下 其次进入你的控制台，到个人面板里面找到密钥管理—&gt;访问密钥(AK)和授权密钥(SK)。复制 到上面的代码中相应的位置填上。 在PyCharm或者Eclipse里面运行这段代码，然后你的js，css以及vendor三个文件夹下面的所有的文件就全部上传至七牛云了。 下面一步很关键，修改相对路径为绝对路径 修改hueman主题的配置文件.config.yml，添加一个路径cdn_prefix，这个路径是你的七牛云的对象存储里面CDN加速的路径，你可以点击https随机生成一个，或者是添加自定义的域名，博主建议你选择前者。 12# cdncdn_prefix: https://og3d9wq14.qnssl.com/ 进入这个目录/Users/Richard/GitHub/qinjiangbo.github.io/themes/hueman/layout，修改为你对应的就行，可以看到下面这些文件 你需要更改的文件夹common和plugin，先进入common，找到head.ejs，修改如下代码 plugin下面的scripts.ejs也是一样的，就不赘述了。读者朋友们可以根据自己的实际情况去查看自己博客中对应的文件，不一定非得和博主一样，只要是涉及到前面说的jss, css和vendor三个文件夹下面的脚本文件的，全部都这么处理。后面记得把layout文件夹下面的.DS_Store文件删除（如果有的话，不然hexo g会报错） 好了，基本上大功告成！运行hexo d发布博客，就可以看效果了！ 总结出现问题不可怕，一定会解决的！那还担心啥！心态调整好，该睡觉睡觉，该思考思考！换个角度想问题可能会更好！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"七牛云","slug":"七牛云","permalink":"http://qinjiangbo.com/tags/七牛云/"},{"name":"静态资源","slug":"静态资源","permalink":"http://qinjiangbo.com/tags/静态资源/"}]},{"title":"Guava优美代码-12-Function","slug":"guava-function-12","date":"2016-10-31T15:45:28.000Z","updated":"2018-04-02T09:02:12.000Z","comments":true,"path":"guava-function-12.html","link":"","permalink":"http://qinjiangbo.com/guava-function-12.html","excerpt":"","text":"Guava函数式编程关于函数式编程，好像越来越多的编程语言都开始逐渐支持这个特性，最明显的就是python，javascript，还有Swift等等。Java终于在1.8中支持了函数式编程，但是在JDK1.8推出来以前，Guava就为我们提供了强大的函数式编程框架—Function。 Function和FunctionsFunction&lt;A, B&gt;，它声明了单个方法B apply(A input)。Function对象通常被预期为引用透明的并且引用透明性中的”相等”语义与equals一致，如a.equals(b)意味着function.apply(a).equals(function.apply(b))。 Functions类为操作Function提供了很多方便的方法，比如合并两个函数compose，以及操作集合框架forMap等等。 Function 使用案例我们有一些国家的首都和国家的相关数据。如下： CountryEnum.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.qinjiangbo.vo;import com.google.common.collect.Lists;import java.util.List;/** * Date: 9/4/16 * Author: qinjiangbo@github.io */public enum CountryEnum &#123; CHINA(\"CHINA\", \"BEIJING\", 2000, \"ASIA\"), US(\"US\", \"WASHINGTON DC\", 200, \"AMERICA\"), KOREA(\"KOREA\", \"SEUL\", 500, \"ASIA\"), GB(\"GB\", \"LONDON\", 1000, \"EURO\"), FINLAND(\"FINLAND\", \"\", 1000, \"EURO\"); private String name; private String capital; private int age; private String continent; private CountryEnum(String name, String capital, int age, String continent) &#123; this.name = name; this.capital = capital; this.age = age; this.continent = continent; &#125; public static List&lt;CountryEnum&gt; findCountries() &#123; return Lists.newArrayList(CHINA, US, KOREA, FINLAND, GB); &#125; public String getContinent() &#123; return continent; &#125; public void setContinent(String continent) &#123; this.continent = continent; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getCapital() &#123; return capital; &#125; public void setCapital(String capital) &#123; this.capital = capital; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 现在对国家及国家的相关信息作如下处理： (1) 查找每个国家的首都信息1234567891011121314public List&lt;String&gt; transformCapitalsInUpperCase() &#123; Function&lt;Country, String&gt; capitalCityFunction = new Function&lt;Country, String&gt;() &#123; @Override public String apply(@Nullable CountryEnum country) &#123; if (country == null) &#123; return null; &#125; return country.getCapital().toUpperCase(); &#125; &#125;; List&lt;String&gt; capitalList = Lists.transform(countryList.findCountries(), capitalCityFunction); return capitalList; &#125; (2) 查找每个国家的首都信息并将其转换为大写以及倒排12345678910111213141516171819202122232425262728public List&lt;String&gt; composeTwoFunctions() &#123; //改为大写 Function&lt;Country, String&gt; upperCaseFunction = new Function&lt;Country, String&gt;() &#123; @Override public String apply(@Nullable CountryEnum country) &#123; if (country == null) &#123; return \"\"; &#125; return country.getCapital().toUpperCase(); &#125; &#125;; //倒排名称 Function&lt;String, String&gt; reverseFunction = new Function&lt;String, String&gt;() &#123; @Override public String apply(String s) &#123; if (s == null) &#123; return null; &#125; return new StringBuilder(s).reverse().toString(); &#125; &#125;; //混合方法 Function&lt;Country, String&gt; composeFunction = Functions.compose(reverseFunction, upperCaseFunction); List&lt;String&gt; capitals = Lists.transform(countryList.findCountries(), composeFunction); return capitals; &#125; (3) 从Map中加载数据到指定的List中12345678910111213141516public List&lt;String&gt; forMapFunction() &#123; Map&lt;String, String&gt; map = Maps.newHashMap(); map.put(CountryEnum.CHINA.getName(), CountryEnum.CHINA.getCapital()); map.put(CountryEnum.US.getName(), CountryEnum.US.getCapital()); map.put(CountryEnum.KOREA.getName(), CountryEnum.KOREA.getCapital()); map.put(CountryEnum.GB.getName(), CountryEnum.GB.getCapital()); Function&lt;String, String&gt; capitalNameFromCountryFunction = Functions.forMap(map); List&lt;String&gt; countries = Lists.newArrayList(); countries.add(CountryEnum.CHINA.getName()); countries.add(CountryEnum.US.getName()); List&lt;String&gt; capitals = Lists.transform(countries, capitalNameFromCountryFunction); return capitals; &#125; (4) forMap函数测试二123456789101112131415public List&lt;String&gt; forMapFunction2() &#123; Map&lt;String, String&gt; map = Maps.newHashMap(); map.put(CountryEnum.CHINA.getName(), CountryEnum.CHINA.getCapital()); map.put(CountryEnum.US.getName(), CountryEnum.US.getCapital()); map.put(CountryEnum.KOREA.getName(), CountryEnum.KOREA.getCapital()); Function&lt;String, String&gt; capitalNameFromCountryName = Functions.forMap(map, \"Unknown\"); List&lt;String&gt; countries = Lists.newArrayList(); countries.add(CountryEnum.CHINA.getName()); countries.add(CountryEnum.GB.getName()); List&lt;String&gt; capitals = Lists.transform(countries, capitalNameFromCountryName); return capitals; &#125; 总结Function使用的门槛会有点高，因为使用起来可能不是那么容易习惯。不过时间长了就会感受到函数式编程带来的乐趣，但是同时也必须提醒你，不要为了使用函数式编程而去使用函数式编程。这一点必须切记！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Function","slug":"Function","permalink":"http://qinjiangbo.com/tags/Function/"}]},{"title":"Guava优美代码-11-Cache","slug":"guava-cache-11","date":"2016-10-31T14:57:46.000Z","updated":"2018-04-02T09:01:59.000Z","comments":true,"path":"guava-cache-11.html","link":"","permalink":"http://qinjiangbo.com/guava-cache-11.html","excerpt":"","text":"Guava缓存Cache缓存（Cache）是我们在开发中为了提高系统的性能，把经常的访问业务数据在第一次访问时没有就先处理结果然后放到缓存中，第二次就不用在对相同的业务数据再重新处理一遍，这样就大大提高了系统的性能。缓存被广泛地引用在各个企业的业务系统中，Guava为我们提供了一个非常好的缓存架构，下面介绍Guava Cache的具体使用方法。 缓存分类缓存分好几种： 本地缓存。 数据库缓存。 分布式缓存。 本地缓存目前使用比较广泛的有EhCache，这是一个完全基于本地内存的缓存框架，可以做成分布式，也可以做成单机模式。分布式缓存比较常用的有memcached， redis等，memcached是高性能的分布式内存缓存服务器，缓存业务处理结果，减少数据库访问次数和相同复杂逻辑处理的时间，以提高动态Web应用的速度、 提高可扩展性。 Guava缓存之LoadingCacheLoadingCache是附带CacheLoader构建而成的缓存实现。创建自己的CacheLoader通常只需要简单地实现V load(K key) throws Exception方法。 1234567891011121314151617@Testpublic void testLoadingCache() throws ExecutionException &#123; Map&lt;String, String&gt; database = Maps.newHashMap(); database.put(\"richard\", \"That's my way!\"); database.put(\"amy\", \"I love you!\"); database.put(\"nike\", \"Just do it!\"); LoadingCache&lt;String, String&gt; cache = CacheBuilder .newBuilder() .build(new CacheLoader&lt;String, String&gt;() &#123; @Override public String load(String key) throws Exception &#123; return database.get(key); &#125; &#125;); cache.put(\"whu\", \"WuHan University\"); System.out.println(cache.get(\"whu\"));&#125; 注意上面代码中，CacheLoader这个类的内部定义了一个load(String key)方法，专门用来加载数据，我们一般会在这个地方写上具体的业务逻辑，比如这里的参数key可以是我们的一个业务编号id，通过这个id我们可以查询企业相关的业务信息，然后将业务信息缓存起来，下次再来取的时候就直接从缓存中读取了。这样就极大地提升了系统的响应速度！ Guava缓存之CallableCache所有类型的Guava Cache，不管有没有自动加载功能，都支持get(K, Callable&lt;V&gt;)方法。这个方法返回缓存中相应的值，或者用给定的Callable运算并把结果加入到缓存中。Callable只有在缓存值不存在或者为空时，才会调用。 在整个加载方法完成前，缓存项相关的可观察状态都不会更改。这个方法简便地实现了模式”如果有缓存则返回；否则进行相关逻辑运、缓存、然后返回” 1234567891011121314151617181920212223@Testpublic void testCallableCache() throws ExecutionException &#123; Cache&lt;String, String&gt; cache = CacheBuilder .newBuilder() .maximumSize(1000) .build(); //Callable只有在缓存值不存在或者为空时，才会调用 String retriValue = cache.get(\"name\", new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"name ==&gt; qinjiangbo\"; &#125; &#125;); System.out.println(retriValue); cache.put(\"whu\", \"WuHan University\"); String retriValue2 = cache.get(\"whu\", new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"name ==&gt; whu\"; &#125; &#125;); System.out.println(retriValue2);&#125; 注意到上面的get方法，当缓存去调用这个get方法的时候，必须指定一个Callable方法，以防止未命中时可以进行相应的逻辑处理。 可以这么来理解，就是说我们想通过缓存区读取业务系统的业务信息，然后未命中，说明不在缓存对吧，这个时候就需要有一个逻辑去处理未命中的事件，其实就是我们需要去写一个函数拿着这个未命中的key取数据库读取相应的业务信息，然后缓存并返回给用户。 或者我们说这个地方也可以设置成缓存用户的在线信息ticket，当这个用户的ticket有效时，我们可以直接读取，当这个用户信息无效时，可以通过这个Callable调用另一个方法比如MD5加密方法对用户信息加密并生成新的ticket。 总结上面只是写了Guava缓存中两个最常见的缓存实现方式，并且也只是简单地做了一个测试，具体的缓存设置需要大家根据自己业务情况进行相应的设置。在CacheBuilder实例后面通过.号可以触发方法，读者可以很清楚地根据设置自己的缓存。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Cache","slug":"Cache","permalink":"http://qinjiangbo.com/tags/Cache/"}]},{"title":"VIM文件头设置","slug":"vim-header-settings","date":"2016-10-30T03:07:15.000Z","updated":"2016-10-30T03:16:39.000Z","comments":true,"path":"vim-header-settings.html","link":"","permalink":"http://qinjiangbo.com/vim-header-settings.html","excerpt":"","text":"很多编辑器都支持在源代码中自动添加作者信息的功能，据我所知Eclipse就支持，虽然我们的Vim(gvim)默认没有这个功能，但是只需要几行代码自己配置一下，我们一样可以让Vim(gvim)支持自动添加作者信息！ 这里面需要使用VIM LANGUAGE的语法，不过不知道也没关系，看我的配置然后对应改一下就OK了！ 1234567891011121314151617181920212223242526272829\" SET COMMENT STARTautocmd BufNewFile *.py,*.sh,*.c exec \":call SetComment()\"let $author_name = \"Richard\"let $author_email = \"qinjiangbo1994@163.com\"func SetComment() if expand(\"%:e\") == 'py' call setline(1, '#coding=utf-8') elseif expand(\"%:e\") == 'c' call setline(1, '// Linux C file') elseif expand(\"%:e\") == 'sh' call setline(1, '#!/bin/bash') endif call append(1, '#*************************************************') call append(2, '#') call append(3, '# Filename: '.expand(\"%\")) call append(4, '# Author: '.$author_name) call append(5, '# Email: '.$author_email) call append(6, '# Create: '.strftime(\"%Y-%m-%d %H:%M:%S\")) call append(7, '# Description: -') call append(8, '#') call append(9, '#*************************************************') normal G normal oendfunc\" SET COMMENT END 大家对应上面的去改就行了，一般是在家目录~/.vimrc文件里面添加就行了。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qinjiangbo.com/tags/Linux/"},{"name":"VIM","slug":"VIM","permalink":"http://qinjiangbo.com/tags/VIM/"}]},{"title":"Guava优美代码-10-CollectionUtils","slug":"guava-collection-utils-10","date":"2016-10-29T14:08:52.000Z","updated":"2018-04-02T09:02:03.000Z","comments":true,"path":"guava-collection-utils-10.html","link":"","permalink":"http://qinjiangbo.com/guava-collection-utils-10.html","excerpt":"","text":"集合工具类 Collection Utils ClassGuava的魅力在处理集合的方面可以说是展现的淋漓尽致，相比JDK的实现，使用Guava可以使我们的代码变得更加“优美”，尤其是在集合接口的声明或者是创建上面。下面我们通过一些简单的例子来领略一下Guava的魅力！ 静态工厂方法在JDK 7之前，构造新的泛型集合时要讨厌地重复声明泛型： 1List&lt;TypeThatsTooLongForItsOwnGood&gt; list = new ArrayList&lt;TypeThatsTooLongForItsOwnGood&gt;(); 我想我们都认为这很讨厌。因此Guava提供了能够推断泛型的静态工厂方法： 12List&lt;TypeThatsTooLongForItsOwnGood&gt; list = Lists.newArrayList();Map&lt;KeyType, LongishValueType&gt; map = Maps.newLinkedHashMap(); 可以肯定的是，JDK7版本的钻石操作符(&lt;&gt;)没有这样的麻烦： 1List&lt;TypeThatsTooLongForItsOwnGood&gt; list = new ArrayList&lt;&gt;(); 但Guava的静态工厂方法远不止这么简单。使用工厂方法模式，我们可以方便地在初始化时就指定起始的元素。 12Set&lt;Type&gt; copySet = Sets.newHashSet(elements);List&lt;String&gt; theseElements = Lists.newArrayList(\"alpha\", \"beta\", \"gamma\"); 另外，通过为工厂方法命名，我们可以提高集合初始化大小的可读性： 123List&lt;Type&gt; exactly100 = Lists.newArrayListWithCapacity(100);List&lt;Type&gt; approx100 = Lists.newArrayListWithExpectedSize(100);Set&lt;Type&gt; approx100Set = Sets.newHashSetWithExpectedSize(100); JDK vs Guava对照表 集合接口 属于JDK还是Guava 对应的Guava工具类 Collection JDK Collections2 List JDK Lists Set JDK Sets SortedSet JDK Sets Map JDK Maps SortedMap JDK Maps Queue JDK Queues Multiset Guava Multisets Multimap Guava Multimaps BiMap Guava Maps Table Guava Tables Maps 使用案例Maps类有很多非常有用的方法，比如我们前面提到的静态工厂方法，还有一些是直接对某个具体的Map集合对象的操作，都封装在了这个Maps类中，对一个Map集合的操作我们几乎可以全部依赖于这个Maps，当然，JDK提供也非常优秀！下面来看一下Guava中Maps类的具体使用方法： 12345678910111213141516171819202122232425262728@Testpublic void testMaps() &#123; // 创建Map -&gt; 方法1 ImmutableMap&lt;String, Integer&gt; left = ImmutableMap .of(\"Richard\", 88, \"Amy\", 90, \"Sarah\", 87, \"Lily\", 89); ImmutableMap&lt;String, Integer&gt; right = ImmutableMap .of(\"Tom\", 78, \"Amy\", 89, \"Richard\", 88); // 创建Map -&gt; 方法2 List&lt;String&gt; strings = Lists.newArrayList(\"Helloo\", \"World\", \"Beautiful\", \"good\"); ImmutableMap&lt;Integer, String&gt; stringsByIndex = Maps.uniqueIndex(strings, string -&gt; string.length()); System.out.println(stringsByIndex); // &#123;6=Helloo, 5=World, 9=Beautiful, 4=good&#125; MapDifference&lt;String, Integer&gt; diff = Maps.difference(left, right); // 取相同的Entry键值都相同 System.out.println(diff.entriesInCommon()); // &#123;Richard=88&#125; // 取键相同值不同的元素 System.out.println(diff.entriesDiffering()); // &#123;Amy=(90, 89)&#125; // 取左边有右边没有的元素 System.out.println(diff.entriesOnlyOnLeft()); // &#123;Sarah=87, Lily=89&#125; // 取右边有左边没有的元素 System.out.println(diff.entriesOnlyOnRight()); // &#123;Tom=78&#125;&#125; 我们可以看到Maps类对集合的创建，对一个或多个集合之间的比较等操作都有非常“高效，流畅”的方法！后面还有很多方法，大家可以自己多举几个例子去熟悉这个类的语法。 Sets 使用案例集合Set对我们来说使用的非常多，通常是在需要集合中所有的元素不能重复的情况下使用。为了让我们更好地使用Set类，Guava为我们又提供了Sets工具类，我们可以通过Sets工具类对任意一个Set集合进行相关的操作。 12345678910111213141516171819202122232425262728@Testpublic void testSets() &#123; Set&lt;String&gt; set1 = Sets.newHashSet(\"One\", \"Two\", \"Three\", \"Four\"); Set&lt;String&gt; set2 = Sets.newHashSet(\"Two\", \"Four\", \"Five\", \"Six\"); // 取交集 Sets.SetView setView = Sets.intersection(set1, set2); System.out.println(setView.size()); // 2 System.out.println(setView.toString()); // [Two, Four] // 取并集 setView = Sets.union(set1, set2); System.out.println(setView.size()); // 6 System.out.println(setView.toString()); // [Two, Three, One, Four, Five, Six] // 取差集 setView = Sets.difference(set1, set2); System.out.println(setView.size()); // 2 System.out.println(setView.toString()); // [Three, One] // 取笛卡尔积 Set&lt;List&lt;String&gt;&gt; product = Sets.cartesianProduct(set1, set2); System.out.println(product); // [[Two, Five], [Two, Six], [Two, Two], [Two, Four], [Three, Five], [Three, Six], [Three, Two], [Three, Four], [One, Five], [One, Six], [One, Two], [One, Four], [Four, Five], [Four, Six], [Four, Two], [Four, Four]] // 集合所有子集 Set&lt;Set&lt;String&gt;&gt; sets = Sets.powerSet(set1); System.out.println(sets); // powerSet(&#123;Two=0, Three=1, One=2, Four=3&#125;)&#125; 以上只是Sets集合的部分用法，是最常见最常用的一些用法，大家可以自己再去尝试其它的一些用法。 Lists 使用案例List可以说是我们在Java编程几乎最最拿手，最最“喜欢”的数据结构，因为它灵活，使用简单，尤其是ArrayList和LinkedList使用的最多，于是乎，Guava为我们锦上添花，提供了操作List集合的工具类Lists类。 1234567891011121314151617181920@Testpublic void testLists() &#123; // 创造集合类--&gt;直接newArrayList就行了 List&lt;String&gt; names = Lists.newArrayList(\"Richard\", \"Amy\", \"Lily\", \"Sarah\"); List&lt;Integer&gt; numbers = Lists.newArrayList(11, 78, 89, 45, 30); System.out.println(names); // [Richard, Amy, Lily, Sarah] System.out.println(numbers); // [11, 78, 89, 45, 30] // 操作集合类--&gt;反转 List&lt;String&gt; reverseNames = Lists.reverse(names); List&lt;Integer&gt; reverseNumbers = Lists.reverse(numbers); System.out.println(reverseNames); // [Sarah, Lily, Amy, Richard] System.out.println(reverseNumbers); // [30, 45, 89, 78, 11] // 分割集合类 List&lt;List&lt;String&gt;&gt; nameParts = Lists.partition(names, 2); List&lt;List&lt;Integer&gt;&gt; numberParts = Lists.partition(numbers, 2); System.out.println(nameParts); // [[Richard, Amy], [Lily, Sarah]] System.out.println(numberParts); // [[11, 78], [89, 45], [30]]&#125; 关于Lists集合的使用还有很多，这里列举了最常用的用法，结果通过注释给出来了。 Iterables 使用案例Iterable还有Iterator在刚学Java的时候一直是我傻傻分不清的两个东西，Iterable是啥？Iterator又是啥？蒙圈了！后来随着不断的系统训练，已经很明晰了，Iterable是java.lang包下的一个接口，而Iterator是java.util包下面的一个具体实现类。好了，我们都知道，JDK的集合框架类由于采用了迭代器模式，所以都实现Iterable接口，而Guava正好利用这个为我们提供了一个通用的集合工具类Iterables。通过这个类我们可以对任何类型的集合类进行一些相关的操作，非常方便！ 1234567891011121314151617181920212223@Testpublic void testIterables() &#123; List&lt;Integer&gt; ints1 = Lists.newArrayList(1, 2, 1, 4, 6, 9); List&lt;Integer&gt; ints2 = Lists.newArrayList(3, 7, 4, 6, 2, 1); // 融合两个列表 Iterable&lt;Integer&gt; iterable = Iterables.concat(ints1, ints2); Iterator iterator = iterable.iterator(); while (iterator.hasNext()) &#123; System.out.print(iterator.next() + \",\"); &#125; // 1,2,1,4,6,9,3,7,4,6,2,1, // 获取列表中第一个和最后一个元素 int last = Iterables.getLast(ints1); System.out.println(last); // 9 int first = Iterables.getFirst(ints1, 10000); System.out.println(first); // 1 // 出现频率统计 int count = Iterables.frequency(ints1, 1); System.out.println(count); // 2&#125; 总结以上就是Guava中关于集合框架的一些操作工具类的使用情况，Guava的集合框架工具类现在正在进一步完善，我们可以持续保持关注，使用这些框架真的能改善我们代码的可读性和易用性。Guava完全符合《高效Java》中的软件工程的代码规范，对我来讲，Guava就是一件难得的艺术品，好好研究，大有裨益！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Collection Utils","slug":"Collection-Utils","permalink":"http://qinjiangbo.com/tags/Collection-Utils/"}]},{"title":"聊一聊民谣","slug":"talk-of-folks","date":"2016-10-28T15:55:51.000Z","updated":"2017-11-27T06:16:40.000Z","comments":true,"path":"talk-of-folks.html","link":"","permalink":"http://qinjiangbo.com/talk-of-folks.html","excerpt":"","text":"聊了好长时间的技术了，咱今天不聊技术，换一下别的主题，给大伙儿聊一聊我最喜欢的民谣！ 突然发现，人真的是会变化的。十年前，2006年，我12岁，想一想那个时候抱着复读机反复听着刀郎的《冲动的惩罚》还有《2002年的第一场雪》，以及说不清道不明的《老鼠爱大米》，《香水有毒》。现在回想起来，当时学那些歌儿时候的认真劲儿还挺有意思的。 转眼小升初，2006年到2009年，我能回忆起来可能就是许嵩的《断桥残雪》了吧，还有王强的《秋天不回来》，说起这首歌，我真的有一种体会，那就是音乐能唤醒你内心最深处的回忆，毫无保留，呼之即出！因为初一的一场期中考试，班主任是将我作为班上的第一名在培养的，并且在学校教职工大会上多次赞扬我，仿佛我就是那个得意门生，这让我在许多老师眼里已然不同，也让我感到很不适（因为压力大啊！！！）。然而结果就是我的考试成绩直接啪啪啪打了班主任一个响亮的耳光，我能想到当时他在办公室会有多尴尬？！出成绩的那个傍晚，也就是上晚自习之前的那个傍晚，星期天，天灰蒙蒙的，突然听到了有同学播放了这首《秋天不回来》！然后，大伙儿都明白了，这首歌就与这一天绑定了，只要每每一听到《秋天不回来》，就立马能唤醒初一的回忆，天空是灰色的，还很冷！QAQ~ 好了，到了中考结束以后，去了荆州中学上高中，那个时候一开始喜欢随大流，喜欢听一些网络歌曲，当时觉得最好听的莫属徐良的《红装》了，真是好听到爆！天天躲在被子里面单曲循环，至于为什么躲在被子里面，大伙都懂~（班主任走路来查寝的时候都没声音的有木有！！！）然后在同桌彭泽栋（大神，现在在浙大读硕博）的影响下，喜欢了王力宏的《好心分手》，还有张栋梁的《北极星的眼泪》，我还记得我同桌每次刷理综试卷的时候都会不自觉的哼起来，至于好不好听嘛！必须给赞！后来我又迷上了轻音乐，喜欢《卡农》，喜欢《梦中的婚礼》，喜欢《紫禁城》，喜欢《克罗地亚狂想曲》等等。 好了！2012年9月我来了武大，品味也慢慢发生了变化~不知不觉中，发现自己慢慢爱上了民谣！慢慢地，歌单里面民谣渐渐多了起来，首先是《董小姐》，接着是《南山南》，再就是《南方姑娘》等等。一开始说不上民谣有什么吸引人的地方，旋律也没有那么美，歌词也没有那么华丽。但后面渐渐发现，正是这些“平淡”的旋律，还有这些“没那没华丽”的歌词让我慢慢沦陷在民谣中。为什么会这样？我想喜欢听民谣的人大抵是因为民谣的旋律很朴实，歌词很真实，淳朴，这一些很能唤起听众的某种共鸣。 尤其是最近两年，我几乎天天都需要音乐，不管有事没事，打开音乐听听自己喜欢的民谣，就觉得生活真的很美好，即使现在天天那么忙，那又如何，生活中总还是有亮点的嘛！很多次我在思考，为什么自己会有这些变化？从非主流的音乐，到流行的音乐，再到轻音乐，最后到民谣。其实这一切能够解释的通，不管是小的时候还是初中或者高中的时候，身边总是会有一群小伙伴，心里面没有曾真正的感觉孤单过。所以，可能那个时候的心境比较活泼，继而喜欢一些比较欢快活泼的流行音乐或者让人心旷神怡的轻音乐。到了大学你才知道，“孤独”的人，耐得住寂寞的人才能静下心来潜心学习，潜心钻研。很开心，我属于后者。很多时候会发现比较孤寂，虽然有女朋友，但是这个孤寂是不一样的，那是一种来自于心灵底部的空虚或者说一种焦虑，总觉得自己现在不能过得太安逸，于是现在每天就像打了鸡血一样学习新技术，抓紧时间读书，写代码，搞研究。 时间很长，长大的过程当中小时候爸爸妈妈讲过的道理好像在某一天突然变成了理所当然的事情，长大的过程当中好像很多愿意的或者不愿意的事情都经历过。也曾经历过长夜痛哭的艰难成长期。是的，我们长大了，慢慢地，发现自己的想法好像被别人给表达出来了，自己的担忧，自己的迷茫，自己的经历。是的，那就是民谣。民谣的确能唱出你心中的声音，那是民谣的歌手真正经历过的人生啊！我喜欢民谣，就是喜欢它的“真实”、“朴实”！ 我喜欢的民谣歌手，许巍，赵雷，宋冬野，小舟与旅行者，郝云。虽然现在宋同学因为吸毒被抓（这个必须谴责，大伙儿要引以为戒），但是他留下的歌曲还是挺不错的。最喜欢他的《董小姐》和《莉莉安》。 喜欢许巍，从《曾经的你》开始！ 曾梦想仗剑走天涯 看一看世界的繁华 年少的心总有些轻狂 如今你四海为家 曾让你心疼的姑娘 如今已悄然无踪影 爱情总让你渴望又感到烦恼 曾让你遍体鳞伤 许巍，一个潇洒脱俗的浪子！在现在繁华浮躁的社会中依然保持着一颗炽热的向往自由和追求自然的心！每次听这首歌都会幻想自己某一天能够去大理，选择一个晴朗微风的午后，踏着一辆单车，后座载着自己心爱的女孩，在洱海边骑上一下午，感受大理的温婉宁静！ 喜欢赵雷，从《南方姑娘》开始，看了《南方姑娘》的MV，原来是一个小女孩啊！哈哈！觉得好有爱啊！那个MV反复看了十几次，每次都会被暖到。后来听到了《成都》，一直都不以为然的我在最近突然被歌里面的某些场景触动了，知道赵雷在成名之前在成都带过很长一段时间，包括里面的小酒馆等地名都是他之前创作或者消遣的地方。因为他，成都被越来越多的人所心而往之，包括我。 让我掉下眼泪的 不止昨夜的酒 让我依依不舍的 不止你的温柔 余路还要走多久 你攥着我的手 让我感到为难的 是挣扎的自由 分别总是在九月 回忆是思念的愁 深秋嫩绿的垂柳 亲吻着我额头 在那座阴雨的小城里 我从未忘记你 成都 带不走的 只有你 和我在成都的街头走一走 直到所有的灯都熄灭了也不停留 你会挽着我的衣袖 我会把手揣进裤兜 走到玉林路的尽头 坐在(走过)小酒馆的门口 赵雷现在火了，火遍了大江南北，还记得一年前，看到网易云音乐下面的一条评论，雷子的歌不火没道理啊！短短一年，他火了，真替他高兴！推荐大家去听听他的《吉姆餐厅》，《家乡》，还有《妈妈》，《三十岁的女人》，这些都是我的Favorite！ 喜欢宋冬野，从《莉莉安》开始，宋冬野的歌声很有磁性（原谅我无法用合适的语言描述这种感觉），《莉莉安》给了你很多想象的空间，听着这首歌，反复是宋冬野在给你讲述一段故事，很宁静，闭上眼睛，静静地想象其中的情景，太美了！ 她发现孤独的人 准备动身 于是就祷告着黄昏 直到夜里 她转头听见 悲伤的呜咽 一个善良的女子 长发垂肩 她已跟随黄昏 来临 翠绿的衣裳在炉火中 化为灰烬 升起火焰 一直烧到黎明 一直到 那女子推开门离去 宋冬野可能为大众所知的就是《董小姐》，这首歌可以说是宋冬野的成名曲，在都市里，充斥着欲望，但是董小姐仿佛安河桥下的清水一样。我们都渴望遇到一个自己的董小姐，但是正如一个听友的一句评论对一个男人来说最无能为力的事儿就是在最没有能力的年纪，碰见了，最想照顾一生的姑娘，一句话对应了歌里面的爱上一匹野马，可我的家里没有草原，这让我感到绝望，董小姐，这种无奈恐怕经历过的人才有感触吧！与这首歌曲风类似的还有他的《斑马，斑马》，非常好听的一首歌。还有我非常喜欢听的《安河桥》，这个也是宋冬野的一个专辑名。大家可以去听一听。 喜欢小舟与旅行者，从《流浪者》开始，引用一个听友的评论作为我的感触。我是一个背包客， 天亮出发， 日落到达。 我只是朝着大海的方向前行， 虽然， 路上， 遇見你， 可我还将一个人到达终点， 因为我知你的路上你也是那背包客， 我也是你短暂的陪同。很Nice的一首歌！ 喜欢郝云，从《活着》开始！郝云的《活着》讲述了都市中人们生活的节奏，压力，以及生活的无奈。对此很有感触！尤其是其中的一个比如让我印象极为深刻，地上的小蚂蚁，它们拿着苹果手机。郝云的曲风很潇洒，他本人带着一点“痞性”，估计很多女生会很喜欢！哈哈！ 民谣，无止境！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"http://qinjiangbo.com/tags/音乐/"},{"name":"民谣","slug":"民谣","permalink":"http://qinjiangbo.com/tags/民谣/"}]},{"title":"Guava优美代码-9-MultiMap","slug":"guava-multimap-9","date":"2016-10-24T15:44:12.000Z","updated":"2018-04-02T09:02:40.000Z","comments":true,"path":"guava-multimap-9.html","link":"","permalink":"http://qinjiangbo.com/guava-multimap-9.html","excerpt":"","text":"多值映射MultiMapMap大概是我们在生产过程中使用最多的容器之一了。Map是一种典型的K-V（键-值）结构。即可以通过一个Key（键）查找到对应的V（值）。正是由于此，JDK规定了Map中不能有重复的键，因为重复会导致无法查询准确的值。但是我们也要注意到这么一个需求：经常地，我们会需要一个键对应多个值，如果用JDK表示，就是这种结构Map&lt;String, List&lt;String&gt;&gt;但是这种结构非常的麻烦而且相对来讲过于复杂。因此Guava为了解决这个问题为我们带来了多值映射MultiMap。 可以用两种方式思考Multimap的概念：”键-单个值映射”的集合：a -&gt; 1 a -&gt; 2 a -&gt;4 b -&gt; 3 c -&gt; 5或者”键-值集合映射”的映射：a -&gt; [1, 2, 4] b -&gt; 3 c -&gt; 5 一般来说，Multimap接口应该用第一种方式看待，但asMap()视图返回Map","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"MultiMap","slug":"MultiMap","permalink":"http://qinjiangbo.com/tags/MultiMap/"}]},{"title":"Guava优美代码-8-MultiSet","slug":"guava-multiset-8","date":"2016-10-24T04:42:01.000Z","updated":"2018-04-02T09:02:44.000Z","comments":true,"path":"guava-multiset-8.html","link":"","permalink":"http://qinjiangbo.com/guava-multiset-8.html","excerpt":"","text":"多值集合MultiSet使用过JDK的同学都知道，在Java中集合Set是不允许重复的，也就是说在同一个集合中不允许出现两个相同的元素。但是如果我们需要计算一个集合中一个元素出现的次数，采用JDK的方式去完成的话会非常的麻烦，但是Guava为我们解决了这个问题—-MultiSet。 实现一个Word Count程序我们需要统计一段文字中各个单词出现的次数，下面给出JDK和Guava两种实现方式。 JDK实现123456789101112131415161718@Testpublic void testJDK_WordCount() &#123; String string = \"I have a dream ! I dream one day I can go everywhere I wish !\"; String[] words = string.split(\" \"); Map&lt;String, Integer&gt; countMap = new HashMap&lt;&gt;(); for (String word : words) &#123; Integer count = countMap.get(word); if (count == null) &#123; countMap.put(word, 1); &#125; else &#123; countMap.put(word, count + 1); &#125; &#125; Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = countMap.entrySet(); for (Map.Entry&lt;String, Integer&gt; entry : entrySet) &#123; System.out.println(entry.getKey() + \":\" + entry.getValue()); &#125;&#125; Guava实现1234567891011@Testpublic void testGuava_WordCount() &#123; String string = \"I have a dream ! I dream one day I can go everywhere I wish !\"; String[] words = string.split(\" \"); List&lt;String&gt; wordList = Arrays.asList(words); Multiset&lt;String&gt; multiset = HashMultiset.create(); multiset.addAll(wordList); for (String word : multiset.elementSet()) &#123; // 返回不重复元素集合 System.out.println(word + \":\" + multiset.count(word)); &#125;&#125; MultiSet使用语法 方法名称 方法描述 add(E element) 向其中添加单个元素 add(E element,int occurrences) 向其中添加指定个数的元素 count(Object element) 返回给定参数元素的个数 remove(E element) 移除一个元素，其count值 会响应减少 remove(E element,int occurrences) 移除相应个数的元素 elementSet() 将不同的元素放入一个Set中 entrySet() 类似与Map.entrySet 返回Set。包含的Entry支持使用getElement()和getCount() setCount(E element ,int count) 设定某一个元素的重复次数 setCount(E element,int oldCount,int newCount) 将符合原有重复个数的元素修改为新的重复次数 retainAll(Collection c) 保留出现在给定集合参数的所有的元素 removeAll(Collectionc) 去除出现给给定集合参数的所有的元素 MultiSet使用示例同一集合添加元素两次1234567@Testpublic void testAddElementsTwoTimes() &#123; Multiset&lt;String&gt; multiset = HashMultiset.create(); multiset.add(\"one\"); multiset.add(\"one\"); System.out.println(multiset.count(\"one\")); // 2&#125; 自定义删除添加修改元素数量12345678910111213@Testpublic void testUserCustomAddRemoveAndSetCount() &#123; Multiset&lt;String&gt; multiset = HashMultiset.create(); multiset.add(\"ball\"); multiset.add(\"ball\", 10); System.out.println(multiset.count(\"ball\")); // 11 multiset.remove(\"ball\", 5); System.out.println(multiset.count(\"ball\")); // 6 multiset.setCount(\"ball\", 8); System.out.println(multiset.count(\"ball\")); // 8&#125; 保留集合中被选中的元素（其余废弃）12345678910111213@Testpublic void testRetainOnlySelectedKeys() &#123; Multiset&lt;String&gt; multiset = HashMultiset.create(); multiset.add(\"ball\"); multiset.add(\"ball\"); multiset.add(\"cow\"); multiset.setCount(\"twelve\", 12); multiset.retainAll(Arrays.asList(\"ball\", \"horse\")); System.out.println(\"cow \" + multiset.count(\"cow\")); // cow 0 System.out.println(\"ball \" + multiset.count(\"ball\")); // ball 2&#125; 总结需要注意的是Multiset不是一个Map,尽管Multiset提供一部分类似的功能实现。其它值得关注的差别有: Multiset中的元素的重复个数只会是正数，且最大不会超过Integer.MAX_VALUE。设定计数为0的元素将不会出现multiset中，也不会出现elementSet()和entrySet()的返回结果中。 multiset.iterator() 会循环迭代每一个出现的元素，迭代的次数与multiset.size()相同。 如果想要知道每个元素的个数，需要使用multiSet.elementSet()方法去遍历整个集合。 Practice! Practice! Practice!","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"MultiSet","slug":"MultiSet","permalink":"http://qinjiangbo.com/tags/MultiSet/"}]},{"title":"Guava优美代码-7-ImmutCollections","slug":"guava-immute-collections-7","date":"2016-10-22T13:33:49.000Z","updated":"2018-04-02T09:02:24.000Z","comments":true,"path":"guava-immute-collections-7.html","link":"","permalink":"http://qinjiangbo.com/guava-immute-collections-7.html","excerpt":"","text":"不可变集合Immutable Collections为什么要使用不可变集合不可变对象有很多优点，包括： 当对象被不可信的库调用时，不可变形式是安全的； 不可变对象被多个线程调用时，不存在竞态条件问题 不可变集合不需要考虑变化，因此可以节省时间和空间。所有不可变的集合都比它们的可变形式有更好的内存利用率（比如分析和测试细节）； 不可变对象因为固定不变，所以可以作为常量来安全使用。 创建对象的不可变拷贝是一项很好的防御性编程技巧。Guava为所有JDK标准集合类型和Guava新集合类型都提供了简单易用的不可变版本。 JDK也提供了Collections.unmodifiableXXX方法把集合包装为不可变形式，但我们认为不够好： 笨重而且累赘：不能合适地用在所有想做防御性拷贝的场景； 不安全：要保证没人通过原集合的引用进行修改，返回的集合才是事实上不可变的； 低效：包装过的集合仍然保有可变集合的开销，比如并发修改的检查、散列表的额外空间，等等。 如果你没有修改某个集合的需求，或者希望某个集合保持不变时，把它防御性地拷贝到不可变集合是个很好的实践。 重要提示 所有Guava不可变集合的实现都不接受null值。我们对Google内部的代码库做过详细研究，发现只有5%的情况需要在集合中允许null元素，剩下的95%场景都是遇到null值就快速失败。如果你需要在不可变集合中使用null，请使用JDK中的Collections.unmodifiableXXX方法。更多细节建议请参考“使用和避免null”。 不可变集合具体用例创建不可变集合Builder()12345678910111213141516171819202122232425@Testpublic void testImmutableMapBuilder() &#123; ImmutableMap&lt;String, Integer&gt; numbersMap = new ImmutableMap.Builder&lt;String, Integer&gt;() .put(\"one\", 1) .put(\"two\", 2) .put(\"three\", 3) .build(); System.out.println(numbersMap.get(\"two\")); // 2&#125;@Testpublic void testImmutableSetBuilder() &#123; ImmutableSet&lt;String&gt; nameSet = new ImmutableSet.Builder&lt;String&gt;() .add(\"hello\", \"I\", \"am\", \"Richard\") .build(); System.out.println(nameSet.toString()); // [hello, I, am, Richard]&#125;@Testpublic void testImmutableListBuilder() &#123; ImmutableList&lt;String&gt; nameList = new ImmutableList.Builder&lt;String&gt;() .add(\"Hello\", \"World\", \"Guava\", \"Google\") .build(); System.out.println(nameList.toString()); // [Hello, World, Guava, Google]&#125; 创建不可变集合Creator()123456789101112131415161718@Testpublic void testImmutableMapCreator() &#123; ImmutableMap&lt;String, Integer&gt; numbersMap = ImmutableMap.of(\"one\", 1, \"two\", 2, \"three\", 3, \"four\", 4); System.out.println(numbersMap.get(\"one\")); // 1&#125;@Testpublic void testImmutableSetCreator() &#123; ImmutableSet&lt;String&gt; nameSet = ImmutableSet.of(\"Hello\", \"name\", \"Henry\"); System.out.println(nameSet.toString()); // [Hello, name, Henry]&#125;@Testpublic void testImmutableListCreator() &#123; ImmutableList&lt;String&gt; nameList = ImmutableList.of(\"Hello\", \"World\", \"Guava\", \"Google\"); System.out.println(nameList); // [Hello, World, Guava, Google]&#125; 神奇的copyOf方法为什么说copyOf方法很神奇呢？因为ImmutableXXX.copyOf方法会尝试在安全的时候避免做拷贝。在以下几种情况下copyOf方法会智能地判断从而避免线性时间拷贝： 在常量时间内使用底层数据结构是可能的——例如，ImmutableSet.copyOf(ImmutableList)就不能在常量时间内完成。 不会造成内存泄露——例如，你有个很大的不可变集合ImmutableListhugeList， ImmutableList.copyOf(hugeList.subList(0, 10))就会显式地拷贝，以免不必要地持有hugeList的引用。 不改变语义——所以ImmutableSet.copyOf(myImmutableSortedSet)会显式地拷贝，因为和基于比较器的ImmutableSortedSet相比，ImmutableSet对hashCode()和equals有不同语义。 在可能的情况下避免线性拷贝，可以最大限度地减少防御性编程风格所带来的性能开销。 12345678@Testpublic void testImmutableCollectionCopyOf() &#123; ArrayList&lt;String&gt; nameList = Lists.newArrayList(\"Hello\", \"I\", \"like\", \"you\", \"OK\"); ImmutableList&lt;String&gt; nameList2 = ImmutableList.copyOf(nameList); ImmutableList&lt;String&gt; nameList3 = ImmutableList.copyOf(nameList.subList(1, 4)); System.out.println(nameList2); // [Hello, I, like, you, OK] System.out.println(nameList3); // [I, like, you]&#125; asList视图所有不可变集合都有一个asList()方法提供ImmutableList视图（View），来帮助你用列表形式方便地读取集合元素。例如，你可以使用sortedSet.asList().get(k)从ImmutableSortedSet中读取第k个最小元素。 asList()返回的ImmutableList通常是开销稳定的视图实现，而不是简单地把元素拷贝进List。也就是说，asList返回的列表视图通常比一般的列表平均性能更好，比如，在底层集合支持的情况下，它总是使用高效的contains方法。 123456@Testpublic void testImmutableCollectionAsList() &#123; ImmutableSet&lt;String&gt; nameSet = ImmutableSet.of(\"Hello\", \"Guava\", \"ISS\", \"WHU\"); System.out.println(nameSet.asList().get(1)); // Guava System.out.println(nameSet.asList()); // [Hello, Guava, ISS, WHU]&#125;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"不可变集合","slug":"不可变集合","permalink":"http://qinjiangbo.com/tags/不可变集合/"}]},{"title":"Linux集群管理脚本","slug":"linux-cluster-management-scripts","date":"2016-10-22T09:07:11.000Z","updated":"2016-10-22T09:27:21.000Z","comments":true,"path":"linux-cluster-management-scripts.html","link":"","permalink":"http://qinjiangbo.com/linux-cluster-management-scripts.html","excerpt":"","text":"不知道你是否遇到下面这种经历，当你面对多台机器需要维护的时候，可能会觉得不知所措，一台机器，两台机器这都还好说，但是如果需要管理的是一个集群（超过50台）呢？一台机器一台机器去管理是不太现实的，那样的话累死了。下面分享一个简单的脚本有助于解决这种管理急群中多台服务器的情况。 前提是你首先得设置主机和各台从机之间的SSH免密码登录。如果不知道的可以去看一下我的另一篇博客设置SSH免登录。补充说明的是需要将主机里面的rsa公钥拷贝到各个从机的相同位置里面。这样主机对从机就可以不用密码登录啦。 集群管理脚本12345678910111213141516171819202122232425#!/bin/bash if [ \"$#\" -ne 2 ]; then echo \"USAGE: $0 [scp|remote] cmd [file]\" exit -1 fi cmd_type=$1 slaves_array=(\"slave1\" \"slave2\" \"slave3\") for ip in $&#123;slaves_array[*]&#125; do if [ \"$cmd_type\" = \"remote\" ]; then cmd=$2 ssh root@$ip \"$cmd\" elif [ \"$cmd_type\" = \"scp\" ]; then file=$2 if [ -d $file ]; then scp -r $file root@$ip:$file else scp $file root@$ip:$file fi fi done echo \"Commands Executed!\" 脚本说明这个里面大家需要更改的是这个slave1,slave2,slave3为对应的从机的地址，或者是写入一个文件直接读取。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://qinjiangbo.com/tags/CentOS/"},{"name":"集群管理","slug":"集群管理","permalink":"http://qinjiangbo.com/tags/集群管理/"}]},{"title":"Guava优美代码-6-Throwables","slug":"guava-throwables-6","date":"2016-10-21T11:15:26.000Z","updated":"2018-04-02T09:03:25.000Z","comments":true,"path":"guava-throwables-6.html","link":"","permalink":"http://qinjiangbo.com/guava-throwables-6.html","excerpt":"","text":"简化异常处理的ThrowablesGuava提供了一个异常处理工具类, 可以简单地捕获和重新抛出多个异常。这个工具就是Throwables。借助Throwables工具类，我们可以很轻松地完成以下一些事情： 获取异常链 获取最底层的异常 过滤异常，只抛出我们感兴趣的异常 把受检查的异常转换为运行时异常 下面直接给出上述几种用例场景的示例代码分析。 获取异常链(getCausalChain)12345678910111213141516@Testpublic void testThrowablesGetCausalChain() &#123; try &#123; try &#123; try &#123; throw new RuntimeException(\"Inner Most exception\"); &#125; catch (Exception e) &#123; throw new SQLException(\"Middle tier exception\", e); &#125; &#125; catch (Exception e) &#123; throw new IllegalStateException(\"Last exception\", e); &#125; &#125; catch (Exception e) &#123; System.out.println(Throwables.getCausalChain(e)); &#125;&#125; 上述代码会打印出三个try语句的抛出异常集合。 获取最底层的异常(getRootCause)12345678910111213141516@Testpublic void testThrowablesGetRootCause() &#123; try &#123; try &#123; try &#123; throw new RuntimeException(\"Inner Most exception\"); &#125; catch (Exception e) &#123; throw new SQLException(\"Middle tier exception\", e); &#125; &#125; catch (Exception e) &#123; throw new IllegalStateException(\"Last exception\", e); &#125; &#125; catch (Exception e) &#123; System.out.println(Throwables.getRootCause(e).getMessage()); &#125;&#125; 这段代码会打印出Inner Most exception，因为它是嵌套在最里面的异常，是所有异常抛出的最根本的原因。 过滤异常(propagrateIfInstanceOf)123456789@Testpublic void testPropagrateIfInstanceOf() throws IOException &#123; try &#123; throw new IOException(); &#125; catch (Throwable t) &#123; Throwables.propagateIfInstanceOf(t, NullPointerException.class); System.out.println(\"Hello World!\"); &#125;&#125; 这段代码会直接打印Hello World!，因为抛出的异常是IOException，而我们感兴趣的是空指针异常NullPointerException。 把受检查的异常转换为运行时异常(propagate)12345678910@Testpublic void testThrowablesPropagate() &#123; try &#123; throw new Exception(); &#125; catch (Throwable t) &#123; String messages = Throwables.getStackTraceAsString(t); System.out.println(\"messages: \" + messages); Throwables.propagate(t); // RuntimeException &#125;&#125; 这个方法将以这个普通的类转化为了运行时异常。 总结以上就是关于Guava的几种常见的用法，当然了，关于Guava的使用也需要仔细斟酌，如果使用了Guava的这个Throwables工具类之后，导致整体的代码变得很复杂难以理解，那么博主劝你赶紧放弃使用这个工具类，因为对于服务器而言，安全和稳定优先！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Throwables","slug":"Throwables","permalink":"http://qinjiangbo.com/tags/Throwables/"}]},{"title":"Guava优美代码-5-Ordering","slug":"guava-ordering-5","date":"2016-10-20T02:02:42.000Z","updated":"2018-04-02T09:02:56.000Z","comments":true,"path":"guava-ordering-5.html","link":"","permalink":"http://qinjiangbo.com/guava-ordering-5.html","excerpt":"","text":"优雅的Guava排序器在开发中经常会对一些数据进行排序或者搜索操作，以前基本上都是先实现Comparator比较器，然后根据这个比较器去比较具体对象之间的顺序。这个过程一直都为开发者所诟病，现在Guava为我们带来了全新的一种比较的方式，那就是Ordering排序器！ 排序器[Ordering]是Guava链式风格比较器[Comparator]的实现，它可以用来为构建复杂的比较器，以完成集合排序的功能。 从实现上说，Ordering实例就是一个特殊的Comparator实例。Ordering把很多基于Comparator的静态方法（如Collections.max）包装为自己的实例方法（非静态方法），并且提供了链式调用方法，来定制和增强现有的比较器。 Ordering使用语法创建方法：常见的排序器可以由下面的静态方法创建 方法 描述 natural() 对可排序类型做自然排序，如数字按大小，日期按先后排序 usingToString() 按对象的字符串形式做字典排序[lexicographical ordering] from(Comparator) 把给定的Comparator转化为排序器 allEqual() 将所比较的所有对象视为一样的，没有顺序 链式调用方法：通过链式调用，可以由给定的排序器衍生出其它排序器 方法 描述 reverse() 获取语义相反的排序器 nullsFirst() 使用当前排序器，但额外把null值排到最前面。 nullsLast() 使用当前排序器，但额外把null值排到最后面。 compound(Comparator) 合成另一个比较器，以处理当前排序器中的相等情况。 lexicographical() 基于处理类型T的排序器，返回该类型的可迭代对象Iterable的排序器。 onResultOf(Function) 对集合中元素调用Function，再按返回值用当前排序器排序。 常规使用方法：下面是一些常规的使用方法 方法 描述 另请参见 greatestOf(Iterable iterable, int k) 获取可迭代对象中最大的k个元素。 leastOf isOrdered(Iterable) 判断可迭代对象是否已按排序器排序：允许有排序值相等的元素。 isStrictlyOrdered sortedCopy(Iterable) 判断可迭代对象是否已严格按排序器排序：不允许排序值相等的元素。 immutableSortedCopy min(E, E) 返回两个参数中最小的那个。如果相等，则返回第一个参数。 max(E, E) min(E, E, E, E…) 返回多个参数中最小的那个。如果有超过一个参数都最小，则返回第一个最小的参数。 max(E, E, E, E…) min(Iterable) 返回迭代器中最小的元素。如果可迭代对象中没有元素，则抛出NoSuchElementException。 max(Iterable), min(Iterator), max(Iterator) Ordering具体用例Natural Ordering1234567891011121314 @Test public void testNaturalOrdering() &#123; Ordering ordering = Ordering.natural(); //自然顺序排序 int result1 = ordering.compare(\"cd\", \"ys\"); System.out.println(result1); // -22, 字符串首字母字典相对顺序 int result2 = ordering.compare(11, 2); System.out.println(result2); // 1// int result3 = ordering.compare(1, \"hello\");// System.out.println(result3); // class cast exception int result4 = ordering.compare('d', 'a'); System.out.println(result4); // 3, 字符在字典中的相对顺序 int result5 = ordering.compare(1.5, 6.8); System.out.println(result5); // -1 &#125; ToString Ordering123456@Testpublic void testToStringOrdering() &#123; Ordering ordering = Ordering.usingToString(); int result = ordering.compare(578, \"hello world\"); System.out.println(result);// 将所有比较元素转化为字符串再比较&#125; Comparator Ordering1234567@Testpublic void testFromComparatorOrdering() &#123; Comparator&lt;Worker&gt; comparator = (o1, o2) -&gt; o1.age - o2.age; Ordering ordering = Ordering.from(comparator); int result = ordering.compare(new Worker(\"Zhangsan\", 23), new Worker(\"Lisi\", 26)); System.out.println(result); // -3,比较两人的年龄之差&#125; Chain Invocation链式调用以及其他具体使用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Testpublic void testOrderingDetails() &#123; Ordering ordering = Ordering.natural(); // min System.out.println(ordering.min(1, 5)); // 1 // min System.out.println(ordering.min(5, 4, 7, 8)); // 4 // min Iterable iterable = Iterables.concat(Lists.newArrayList(31, 5, 8, 49, 24)); System.out.println(ordering.min(iterable)); // 5 // max System.out.println(ordering.max(iterable)); // 49 // binary search System.out.println(ordering.binarySearch( Lists.newArrayList(14, 18, 19, 45, 76, 78), 45)); // 3, 表示第四个元素 //加上链式调用 ordering = ordering.nullsFirst().onResultOf(new Function&lt;Worker, String&gt;() &#123; @Override public String apply(Worker input) &#123; return input.name; &#125; &#125;); List originList = Lists.newArrayList( new Worker(\"zl\", 4), new Worker(\"sl\", 34), new Worker(\"hp\", 24), new Worker(null, 15), new Worker(\"app\", 46), new Worker(\"lyh\", 26)); List sortedList = ordering.sortedCopy(originList); System.out.println(sortedList); // [Worker&#123;name=null, age=15&#125;, Worker&#123;name=app, age=46&#125;, -&gt; // Worker&#123;name=hp, age=24&#125;, Worker&#123;name=lyh, age=26&#125;, -&gt; // Worker&#123;name=sl, age=34&#125;, Worker&#123;name=zl, age=4&#125;]&#125;class Worker &#123; String name; int age; public Worker(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return MoreObjects.toStringHelper(this) .add(\"name\", name) .add(\"age\", age) .toString(); &#125;&#125; 总结关于Ordering的使用方法还有很多，你可以根据自己的实际情况去应用其他的一些优美用法。本文列举出来的全部都是生产中比较常见的而且很重要的一些用法。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Ordering","slug":"Ordering","permalink":"http://qinjiangbo.com/tags/Ordering/"}]},{"title":"Guava优美代码-4-Objects","slug":"guava-objects-4","date":"2016-10-19T17:36:21.000Z","updated":"2018-04-02T09:02:48.000Z","comments":true,"path":"guava-objects-4.html","link":"","permalink":"http://qinjiangbo.com/guava-objects-4.html","excerpt":"","text":"对象操作类ObjectsJava语言中Object类是所有类的父类，其中有几个需要override的方法比如equals,hashCode和toString等方法。每次写这几个方法都要做很多重复性的判断, 很多类库提供了覆写这几个方法的工具类, Guava也提供了类似的方式。 关于equals方法需要多说几句，就是我们在写equals判断的时候很容易忘掉很多判断条件，往往容易导致结果不正确，以下的几条性质是在重写equals方法的时候必须遵守的： 自反性reflexive：任何非空引用x，x.equals(x)返回为true； 对称性symmetric：任何非空引用x和y，x.equals(y)返回true当且仅当y.equals(x)返回true； 传递性transitive：任何非空引用x和y，如果x.equals(y)返回true，并且y.equals(z)返回true，那么x.equals(z)返回true； 一致性consistent：两个非空引用x和y，x.equals(y)的多次调用应该保持一致的结果，（前提条件是在多次比较之间没有修改x和y用于比较的相关信息）； 对于所有非null的值x， x.equals(null)都要返回false。 (如果你要用null.equals(x)也可以，会报NullPointerException)。 Objects使用语法 方法修饰符和类型 方法描述 static boolean equal(Object a, Object b) 判断两个对象是否完全一样。 static T firstNonNull(T first, T second) 已经过时，请使用MoreObjects.firstNonNull(T, T)，这个方法计划在Guava21.0中移除。 static int hashCode(Object… objects) 批量的为一系列对象生成Hash值。 static Objects.ToStringHelper toStringHelper(Class&lt;?&gt; clazz) 已经过时，请使用 MoreObjects.toStringHelper(Class) 。这个方法计划在Guava21.0中移除。 static Objects.ToStringHelper toStringHelper(Object self) 已经过时，请使用 MoreObjects.toStringHelper(Object) 。这个方法计划在Guava21.0中移除。 static Objects.ToStringHelper toStringHelper(String className) 已经过时，请使用 MoreObjects.toStringHelper(String) 。这个方法计划在Guava21.0中移除。 Objects具体用例下面是Objects源码片段中实现equals方法的片段： 1234@CheckReturnValuepublic static boolean equal(@Nullable Object a, @Nullable Object b) &#123; return a == b || (a != null &amp;&amp; a.equals(b));&#125; 说明Objects方法在调用的时候还是会使用方法体中的Object的equals方法。所以，用户在创建数据的同时，必须得重载equals。除非不需要比较两个模型。否则会得到一个错误的结果。 代码示例Objects.equal(a, b)123456789101112131415161718@Test public void testObjectsEquals() &#123; Country country = new Country(\"CHINA\", 2000, \"BEIJING\"); Country country2 = new Country(\"CHINA\", 2000, \"BEIJING\"); System.out.println(country.equals(country2)); // true &#125; @Test public void testObjectsEquals2() &#123; System.out.println(Objects.equal(\"a\", \"b\")); // false &#125; @Test public void testObjectsEquals3() &#123; Country country = new Country(\"CHINA\", 2000, \"BEIJING\"); Country country2 = new Country(\"CHINA\", 2000, \"BEIJING\"); System.out.println(Objects.equal(country, country2)); // true前提是对象要重写equals方法，一般这个Objects.equal方法主要用在重写的equal方法中 &#125; Country.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Country &#123; private String name; private int time; private String capital; public Country() &#123; &#125; public Country(String name, int time, String capital) &#123; this.name = name; this.time = time; this.capital = capital; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getTime() &#123; return time; &#125; public void setTime(int time) &#123; this.time = time; &#125; public String getCapital() &#123; return capital; &#125; public void setCapital(String capital) &#123; this.capital = capital; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null) return false; if (!(o instanceof Country)) return false; Country country = (Country) o; return Objects.equal(name, country.getName()) &amp;&amp; Objects.equal(time, country.getTime()) &amp;&amp; Objects.equal(capital, country.getCapital()); &#125; @Override public int hashCode() &#123; return Objects.hashCode(name, time, capital); &#125; @Override public String toString() &#123; return Objects.toStringHelper(this).add(\"name\", name) .add(\"time\", time) .add(\"capital\", capital).toString(); &#125;&#125; Objects.hashCode(Object… objects)12345@Testpublic void testObjectsHash() &#123; Country country = new Country(\"CHINA\", 2000, \"BEIJING\"); System.out.println(Objects.hashCode(country)); // 1955204803&#125; MoreObject.toStringHelper(Object obj)12345678910111213@Overridepublic String toString() &#123; return Objects.toStringHelper(this).add(\"name\", name) .add(\"time\", time) .add(\"capital\", capital).toString();&#125;@Testpublic void testObjectsToString() &#123; Country country = new Country(\"CHINA\", 2000, \"BEIJING\"); /* 这个方法目前在MoreObjects类中 */ System.out.println(country.toString()); // Country&#123;name=CHINA, time=2000, capital=BEIJING&#125;&#125; MoreObjects.firstNonNull(Object… objects)这个方法主要是获取一系列值中第一个非空的值。 123456@Testpublic void testObjectsFirstNonNull() &#123; String name = null; String nickName = \"Richard\"; System.out.println(MoreObjects.firstNonNull(nickName, name)); // Richard&#125; 总结Objects工具类在JDK类库的基础上扩展了许多实用的方法，这些都是在平时的工作生产中令我们产生痛点的地方，希望大家好好掌握Objects的用法。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Objects","slug":"Objects","permalink":"http://qinjiangbo.com/tags/Objects/"}]},{"title":"Guava优美代码-3-Preconditions","slug":"guava-preconditions-3","date":"2016-10-19T17:17:02.000Z","updated":"2018-04-02T09:03:00.000Z","comments":true,"path":"guava-preconditions-3.html","link":"","permalink":"http://qinjiangbo.com/guava-preconditions-3.html","excerpt":"","text":"前置条件Preconditions 前置条件：让方法调用的前置条件判断更简单。 在日常开发中，我们经常会对方法的输入参数做一些数据格式上的验证，以便保证方法能够按照正常流程执行下去。对于可预知的一些数据上的错误，我们一定要做事前检测和判断，来避免程序流程出错，而不是完全通过错误处理来保证流程正确执行，毕竟错误处理是比较消耗资源的方式。在平常情况下我们对参数的判断都需要自己来逐个写方法判断，代码量不少并且复用性不高。 Guava在Preconditions类中提供了若干前置条件判断的实用方法，强烈建议在Eclipse或者是Intellij IDEA中静态导入这些方法。每个方法都有三个变种： 没有额外参数：抛出的异常中没有错误消息； 有一个Object对象作为额外参数：抛出的异常使用Object.toString() 作为错误消息； 有一个String对象作为额外参数，并且有一组任意数量的附加Object对象：这个变种处理异常消息的方式有点类似printf，但考虑GWT的兼容性和效率，只支持%s指示符。 Preconditions使用语法 方法声明（不包括额外参数） 描述 检查失败时抛出的异常 checkArgument(boolean) 检查boolean是否为true，用来检查传递给方法的参数。 IllegalArgumentException checkNotNull(T) 检查value是否为null，该方法直接返回value，因此可以内嵌使用 checkNotNull。 NullPointerException checkState(boolean) 用来检查对象的某些状态。 IllegalStateException checkElementIndex(int index, int size) 检查index作为索引值对某个列表、字符串或数组是否有效。index&gt;=0 &amp;&amp; index&lt;size * IndexOutOfBoundsException checkPositionIndex(int index, int size) 检查index作为位置值对某个列表、字符串或数组是否有效。index&gt;=0 &amp;&amp; index&lt;=size * IndexOutOfBoundsException checkPositionIndexes(int start, int end, int size) 检查[start, end]表示的位置范围对某个列表、字符串或数组是否有效* IndexOutOfBoundsException 代码示例123456789101112131415public class PreConditionsTest &#123; @Test public void testPreConditionCheckState() &#123; Weather weather = Weather.SHINNY; Preconditions.checkState(weather.equals(Weather.SHINNY), \"Weather is not the best for a sunbath!\"); &#125; @Test public void testPreConditionCheckNotNull() &#123; List&lt;String&gt; members = Lists.newArrayList(); Preconditions.checkNotNull(members, \"members can not be null!\"); Preconditions.checkArgument(members.size() == 0, \"members can not be null!\"); &#125;&#125; 注意在编码时，如果某个值有多重的前置条件，建议你把它们放到不同的行，这样有助于在调试时定位。关于前置条件更多的使用方式，读者朋友们可以根据接口文档去尝试不同的方法，活学活用！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Preconditions","slug":"Preconditions","permalink":"http://qinjiangbo.com/tags/Preconditions/"}]},{"title":"Guava优美代码-2-Optional","slug":"guava-optional-2","date":"2016-10-19T15:47:48.000Z","updated":"2018-04-02T09:02:52.000Z","comments":true,"path":"guava-optional-2.html","link":"","permalink":"http://qinjiangbo.com/guava-optional-2.html","excerpt":"","text":"尽量不要使用NULL轻率地使用null可能会导致很多令人吃惊的问题。通过学习Google底层代码库，我们发现95%的集合类不接受null值作为元素。我们认为， 相比默默地接受null，使用快速失败操作拒绝null值对开发者更有帮助。 此外，Null的含糊语义让人很不舒服。Null很少可以明确地表示某种语义，例如，Map.get(key)返回Null时，可能表示map中的值是null，亦或map中没有key对应的值。Null可以表示失败、成功或几乎任何情况。使用Null以外的特定值，会让你的逻辑描述变得更清晰。 Null确实也有合适和正确的使用场景，如在性能和速度方面Null是廉价的，而且在对象数组中，出现Null也是无法避免的。但相对于底层库来说，在应用级别的代码中，Null往往是导致混乱，疑难问题和模糊语义的元凶，就如同我们举过的Map.get(key)的例子。最关键的是，Null本身没有定义它表达的意思。 鉴于这些原因，很多Guava工具类对Null值都采用快速失败操作，除非工具类本身提供了针对Null值的因变措施。此外，Guava还提供了很多工具类，让你更方便地用特定值替换Null值。 NULL在Java中的使用 常见使用场景: 有时候，我们定义一个引用类型变量，在刚开始的时候，无法给出一个确定的值，但是不指定值，程序可能会在try语句块中初始化值。这时候，我们下面使用变量的时候就会报错。这时候，可以先给变量指定一个null值，问题就解决了。 容器类型与null: List：允许重复元素，可以加入任意多个null。 Set：不允许重复元素，最多可以加入一个null。 Map：Map的key最多可以加入一个null，value字段没有限制。 数组：基本类型数组，定义后，如果不给定初始值，则java运行时会自动给定值。引用类型数组，不给定初始值，则所有的元素值为null。 null的其他作用 判断一个引用类型数据是否null。 用==来判断。 释放内存，让一个非null的引用类型变量指向null。这样这个对象就不再被任何对象应用了。等待JVM垃圾回收机制去回收。 Guava中的Optional大多数情况下，开发人员使用null表明的是某种缺失情形：可能是已经有一个默认值，或没有值，或找不到值。例如，Map.get返回null就表示找不到给定键对应的值。 Guava用Optional表示可能为null的T类型引用。一个Optional实例可能包含非null的引用（我们称之为引用存在），也可能什么也不包括（称之为引用缺失）。它从不说包含的是null值，而是用存在或缺失来表示。但Optional从不会包含null值引用。 Optional使用语法静态方法： 方法 说明 Optional.of(T) 创建指定引用的Optional实例，若引用为null则快速失败 Optional.absent() 创建引用缺失的Optional实例 Optional.fromNullable(T) 创建指定引用的Optional实例，若引用为null则表示缺失 非静态方法： 方法 说明 boolean isPresent() 如果Optional包含非null的引用（引用存在），返回true T get() 返回Optional所包含的引用，若引用缺失，则抛出java.lang.IllegalStateException T or(T) 返回Optional所包含的引用，若引用缺失，返回指定的值 T orNull() 返回Optional所包含的引用，若引用缺失，返回null Set asSet() 返回Optional所包含引用的单例不可变集，如果引用存在，返回一个只有单一元素的集合，如果引用缺失，返回一个空集合。 使用Optional的意义使用Optional除了赋予null语义，增加了可读性，最大的优点在于它是一种傻瓜式的防护。Optional迫使你积极思考引用缺失的情况，因为你必须显式地从Optional获取引用。直接使用null很容易让人忘掉某些情形，尽管FindBugs可以帮助查找null相关的问题，但是我们还是认为它并不能准确地定位问题根源。 如同输入参数，方法的返回值也可能是null。和其他人一样，你绝对很可能会忘记别人写的方法method(a,b)会返回一个null，就好像当你实现method(a,b)时，也很可能忘记输入参数a可以为null。将方法的返回类型指定为Optional，也可以迫使调用者思考返回的引用缺失的情形。 代码用例OptionalTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class OptionalTest &#123; @Test public void testOptional() &#123; Optional&lt;String&gt; optional = Optional.of(\"Hello World!\"); if (optional.isPresent()) &#123; System.out.println(optional.get()); &#125; &#125; @Test public void testOptional2() &#123; Optional&lt;Integer&gt; optional1 = Optional.of(6); Optional&lt;Integer&gt; optional2 = Optional.absent(); Optional&lt;Integer&gt; optional3 = Optional.fromNullable(null); Optional&lt;Integer&gt; optional4 = Optional.fromNullable(10); if (optional1.isPresent()) &#123; System.out.println(\"Optional1 is \" + optional1.get()); &#125; if (optional2.isPresent()) &#123; System.out.println(\"Optional2 is \" + optional2.get()); &#125; if (optional3.isPresent()) &#123; System.out.println(\"Optional3 is \" + optional3.get()); &#125; if (optional4.isPresent()) &#123; System.out.println(\"Optional4 is \" + optional4.get()); &#125; &#125; @Test public void testOptional3() &#123; Optional&lt;String&gt; name = getNameListFromDB(null); if (name.isPresent()) &#123; System.out.println(\"name: \" + name.get()); &#125; System.out.println(\"orNull: \" + name.orNull()); Optional&lt;String&gt; address = getNameListFromDB(\"Wuhan Bayi Road\"); Set&lt;String&gt; set = address.asSet(); System.out.println(\"toString: \" + set.toString()); System.out.println(\"size: \" + set.size()); &#125; /** * 获得这个Optional返回类型 * * @param DB * @return */ private Optional&lt;String&gt; getNameListFromDB(String DB) &#123; return Optional.fromNullable(DB); &#125;&#125; testOptional2的结果：（使用IDE-Jetbrains IDEA） 1234Optional1 is 6Optional4 is 10Process finished with exit code 0 可以很轻易的避免这个NULL的问题，大家以后再开发中要经常使用Optional来避免这样的问题。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Optional","slug":"Optional","permalink":"http://qinjiangbo.com/tags/Optional/"},{"name":"Not null","slug":"Not-null","permalink":"http://qinjiangbo.com/tags/Not-null/"}]},{"title":"Github Pages自定义域名+CDN加速解决方案","slug":"github-page-customed-domain-and-cdn","date":"2016-10-17T14:55:24.000Z","updated":"2016-11-04T01:24:59.000Z","comments":true,"path":"github-page-customed-domain-and-cdn.html","link":"","permalink":"http://qinjiangbo.com/github-page-customed-domain-and-cdn.html","excerpt":"","text":"先说说烦恼自CSDN搬家到Github Pages以来，倍感欣喜！原因很简单，省了我每个月一两百的服务器费用。但是随之而来的也存在一个问题，那就是Github Pages的托管服务器是在美国本土的，没有一个在海外。所以，大家平时访问我的网站都是通过浏览器直接访问美国的github服务器实现的，路程远不说，还有天朝的大墙时不时封一些服务器，其结果可想而知。面对博客的访问速度超过12s，患有严重强迫症的博主只能表示需要哭一会先。 没有长夜痛哭过的经历不足以谈人生哈哈，好吧！这句话是我跟室友聊天的时候突然想到的，就做这里的一个标题吧。现在面临两个选择，一个是坚持使用Github提供的服务，继续使用它的二级域名qinjiangbo.github.io，使用https加密；另一个是自己搞一个域名，在国内解析速度会快很多，但是没有https协议加密了。思考再三，觉得好像也没有多少人觉得一个https协议会比网页的加载速度更重要，所以，博主决定采用自己购买的顶级域名qinjiangbo.com。下面就来说一说如何将github.io映射到自己的域名当中去。 映射自定义域名一、 进入你的github主页，找到你的用户名username.github.io的项目，如果没有，赶紧自己创建一个，至于如何创建，这不在本文的论述的范围之内，所以不做解释了。二、 在更改设置之前你需要先ping一下username.github.io，记住这个ping得到的IP地址，后面会使用到。三、 在username.github.io项目中找到Settings设置，点击进入设置。 四、找到自定义域名这一项，Custom Domains，输入你的域名，注意，是不带www或者blog的。直接就是xxx.com。 添加自定义域名的解析一、进入控制台，找到域名这一项服务。 二、进入域名解析，使用前面得到的IP地址添加一条A记录。 使用CDN加速前提你需要开通两项服务： OSS对象存储服务 CDN加速服务 具体步骤如下一、切入阿里云的总控制台，选择对象存储服务，没有开通的先开通这项服务，进入这项服务，然后创建一个桶（bucket），用于后面装在静态资源文件。 二、进入CDN服务，没有开通的也要先开通，添加一个新的域名。 三、解析的时候选择图片小文件，基本上可以说网页文件（5M一下）都是小文件，然后选择之前创建的OSS桶。 四、点击下一步，大功告成！ 总结经过这次的“折腾”，终于是将网站的速度提升了，现在打开速度2s以内，嗖嗖的！希望本教程对你有所帮助！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://qinjiangbo.com/tags/Git/"},{"name":"Github Pages","slug":"Github-Pages","permalink":"http://qinjiangbo.com/tags/Github-Pages/"}]},{"title":"Guava优美代码-1-简介","slug":"guava-introduction-1","date":"2016-10-16T07:51:28.000Z","updated":"2018-04-02T09:02:27.000Z","comments":true,"path":"guava-introduction-1.html","link":"","permalink":"http://qinjiangbo.com/guava-introduction-1.html","excerpt":"","text":"Google Guava简介Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中。 项目相关信息：官方首页：http://code.google.com/p/guava-libraries 官方下载：http://code.google.com/p/guava-libraries/downloads/list 官方文档：http://docs.guava-libraries.googlecode.com/git/javadoc http://www.ostools.net/apidocs/apidoc?api=guava 源码包的简单说明： com.google.common.annotations：普通注解类型。 com.google.common.base：基本工具类库和接口。 com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。 com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类，这里你会发现很多好玩的集合。 com.google.common.eventbus：发布订阅风格的事件总线。 com.google.common.hash： 哈希工具包。 com.google.common.io：I/O工具包。 com.google.common.math：原始算术类型和超大数的运算工具包。 com.google.common.net：网络工具包。 com.google.common.primitives：八种原始类型和无符号类型的静态工具包。 com.google.common.reflect：反射工具包。 com.google.common.util.concurrent：多线程工具包。 开发者指南一、基本工具类：让使用Java语言更令人愉悦。 使用和避免 null：null 有语言歧义， 会产生令人费解的错误， 反正他总是让人不爽。很多 Guava 的工具类在遇到 null 时会直接拒绝或出错，而不是默默地接受他们。 前提条件：更容易的对你的方法进行前提条件的测试。 常见的对象方法： 简化了Object常用方法的实现， 如 hashCode() 和 toString()。 排序： Guava 强大的 “fluent Comparator”比较器， 提供多关键字排序。 Throwable类： 简化了异常检查和错误传播。 二、集合类：集合类库是 Guava 对 JDK 集合类的扩展， 这是 Guava 项目最完善和为人所知的部分。 Immutable collections（不变的集合）： 防御性编程， 不可修改的集合，并且提高了效率。 New collection types(新集合类型)：JDK collections 没有的一些集合类型，主要有：multisets，multimaps，tables， bidirectional maps等等 Powerful collection utilities（强大的集合工具类）： java.util.Collections 中未包含的常用操作工具类 Extension utilities（扩展工具类）: 给 Collection 对象添加一个装饰器? 实现迭代器? 我们可以更容易使用这些方法。 三、缓存: 本地缓存，可以很方便的操作缓存对象，并且支持各种缓存失效行为模式。四、Functional idioms（函数式）: 简洁, Guava实现了Java的函数式编程，可以显著简化代码。五、Concurrency（并发）：强大,简单的抽象,让我们更容易实现简单正确的并发性代码。 ListenableFuture（可监听的Future）: Futures,用于异步完成的回调。 Service: 控制事件的启动和关闭，为你管理复杂的状态逻辑。 六、Strings: 一个非常非常有用的字符串工具类: 提供 splitting，joining， padding 等操作。七、Primitives: 扩展 JDK 中未提供的对原生类型（如int、char等）的操作， 包括某些类型的无符号的变量。八、Ranges: Guava 一个强大的 API，提供 Comparable 类型的范围处理， 包括连续和离散的情况。九、I/O: 简化 I/O 操作, 特别是对 I/O 流和文件的操作, for Java 5 and 6.十、 Hashing: 提供比 Object.hashCode() 更复杂的 hash 方法, 提供 Bloom filters.十一、EventBus: 基于发布-订阅模式的组件通信，但是不需要明确地注册在委托对象中。十二、Math: 优化的 math 工具类，经过完整测试。十三、Reflection: Guava 的 Java 反射机制工具类。Guava使用心得其实一开始我只是听说过Google的Guava框架，但是由于工作和学习太忙的原因，一直没时间来研究这个。直到后面公司里面来了一个阿里的同时，他的代码写的非常让人赏心悦目。最后交流后得知这个就是Guava。我被Guava的语法简洁性所惊艳到了！决定下班以后抽时间学习Guava的使用，经过系统的主动训练以后，发现以前对于集合框架的声明和操作竟然可以变的如此简洁优美！所以，决定写一个系列的使用教程与大家交流交流，这个系列结束以后可能会推出Guava的源码分析相关的文章，敬请关注！ [更新]所有的代码都可以在我的Github找到。地址https://github.com/QinJiangbo/Guava","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Guava","slug":"Guava","permalink":"http://qinjiangbo.com/tags/Guava/"},{"name":"Google","slug":"Google","permalink":"http://qinjiangbo.com/tags/Google/"}]},{"title":"OpenClassroom of Stanford University","slug":"open-classroom-of-stanford-university","date":"2016-10-06T14:02:22.000Z","updated":"2016-10-06T14:15:58.000Z","comments":true,"path":"open-classroom-of-stanford-university.html","link":"","permalink":"http://qinjiangbo.com/open-classroom-of-stanford-university.html","excerpt":"","text":"Full courses. Short Videos. Free for everyone.Introduction to Human-Computer Interaction DesignLearn the fundamentals of human-computer interaction and design thinking, with an emphasis on mobile web applications. Practical UnixA practical introduction to Unix and command line utilities with a focus on Linux. Design and Analysis of AlgorithmsIntroduction to fundamental techniques for designing and analyzing algorithms, including asymptotic analysis; divide-and-conquer algorithms and recurrences; greedy algorithms; data structures; dynamic programming; graph algorithms; and randomized algorithms. Introduction to DatabasesDatabase design and the use of database management systems (DBMS) for applications. Unsupervised Feature Learning and Deep LearningMachine learning algorithms that learn feature representations from unlabeled data, including sparse coding, autoencoders, RBMs, DBNs. Discrete ProbabilityIntroduction to discrete probability, including probability mass functions, and standard distributions such as the Bernoulli, Binomial, Poisson distributions. Machine LearningIntroduction to applied machine learning. In this course, you’ll learn about machine learning techniques such as linear regression, logistic regression, naive Bayes, SVMs, clustering, and more. In addition, you’ll also learn the practical, hands-on, skills and techniques needed to get learning techniques to work well in practice.","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"}],"tags":[{"name":"公开课","slug":"公开课","permalink":"http://qinjiangbo.com/tags/公开课/"},{"name":"斯坦福","slug":"斯坦福","permalink":"http://qinjiangbo.com/tags/斯坦福/"}]},{"title":"[转]机器学习相关视频","slug":"machine-learning-videoes","date":"2016-10-06T13:42:02.000Z","updated":"2018-01-06T06:55:04.000Z","comments":true,"path":"machine-learning-videoes.html","link":"","permalink":"http://qinjiangbo.com/machine-learning-videoes.html","excerpt":"","text":"原文地址： http://liliphd.iteye.com/blog/1929358 近日，在网易公开课视频网站上看完了《机器学习》课程视频，现做个学后感，也叫观后感吧。 学习时间从2013年7月26日星期五开始，在网易公开课视频网站上，观看由斯坦福大学Andrew Ng教授主讲的计算机系课程（编号CS229）《机器学习》（网址http://v.163.com/special/opencourse/machinelearning.html）（注：最早是在新浪公开课上发现的这门课，看了前几集没有字幕的视频。后来经由技术群网友的指引才找到网易，看到了全部翻译完的视频）。我基本上每天看1-2集，不熟悉的内容会在第二天复习一遍。到2013年8月17日全部视频看完，前后用了23天，中间有几天有事或者脑子不在状态就没看。全部看完之后，又找自己感兴趣的重看，我翻看了第11集的内容，“对开发机器学习应用的建议”，老师根据自己的实际项目经验提出了很好的建议，对我们的实战有很大的帮助。 课程设置和内容视频课程分为20集，每集72-85分钟。实体课程大概一周2次，中间还穿插助教上的习题课，大概一个学期的课程。 内容涉及四大部分，分别是：监督学习（2-8集）、学习理论（9集-11集）、无监督学习（12-15集）、强化学习（16-20集）。监督学习和无监督学习，基本上是机器学习的二分法；强化学习位于两者之间；而学习理论则从总体上介绍了如何选择、使用机器学习来解决实际问题，以及调试（比如：误差分析、销蚀分析）、调优（比如：模型选择、特征选择）的各种方法和要注意的事项（比如，避免过早优化）。 监督学习，介绍了回归、朴素贝叶斯、神经网络、SVM（支持向量机）、SMO（顺序最小优化）算法等；无监督学习讲了聚类、K-means、GMM（混合高斯模型）、EM算法 、PCA（主成分分析）、LSI（潜在语义索引）、SVD（奇异值分解）、ICA（独立成分分析）等；强化学习主要讲了这类连续决策学习（马尔科夫决策过程，MDP）中的值迭代（VI）和策略迭代（PI），以及如何定义回报函数，如何找到最佳策略等问题。 授课方式网上有老师的讲义，可以在网易这门课的主页面上打包下载（网址http://v.163.com/special/opencourse/machinelearning.html）。老师基本上是写板书的，PPT是辅助。在黑板上用粉笔边讲解边书写，有助于带动学生的思考，使师生之间有交流有互动。个人以为，比直接显示PPT效果好。数学公式的推导很费时间，课堂上也不可能大多数的时间用来推导公式，所以大量的推导老师要求学生在课下看讲义，或者通过习题课听助教讲解。 授课语言因为是美国的课堂，当然的教学语言是英语。网易做的不错，除了把老师说的话全部转写下来，还做了中文翻译，前14集翻译得不错，除了偶有错别字之外，专业术语翻译的很好，语句也很流畅。第15集以后一直到最后一堂课，翻译的不是太准确，一些专业术语都翻译错了，很让观者感到不适。但是，无论如何，还是感谢网易这些转写和翻译的无名网友无私的付出。这些小的瑕疵不会让真正热爱这门课程的学习者放弃学习，反而想加入翻译者的队伍，为传播科学知识而贡献力量呢。 观后感总体感觉，老师讲的不错，是个真正懂机器学习的人。老师在课上也说过，很容易区分那些真正懂机器学习的人，和那些只会纸上谈兵的人。我希望成为第一类，并为此努力着。 老师是华裔，中文名字叫吴恩达，生于伦敦，看上去很亲切。课堂很活跃，老师注重和学生交流，每讲完一个主题，会问学生有问题吗，然后一一作答。 视频大概录制于2007年（个人推测，未经考证），内容上，与现在的机器学习技术比，稍微显得不够多。近年来，机器学习领域有了长足的发展，学术界和工业界齐发力，二者相互促进，达到了前所未有的高度。即便是曾经沉寂的神经网络，近年来也改头换面成了深度学习。不过，从专家的角度看，这不是一种新的机器学习技术，它只是涉及到其中的一个环节——特征选择，并不构成一个独立的学习方法。 老师没有涉及实战。受限于课堂讲授的方式和时间上的限制，课上只能做必要知识点的讲解。 数学公式比较多，似懂非懂的。如果不满足于“知其然”，还要“知其所以然”，以后的方向是搞模型、算法研究的话，那还要补习一下数学知识，必须的。如果仅是为了解决实际问题，对算法要求不高的话，那知道如何运用就够了。剩下的，随着应用系统的不断进展，对整个系统各方面要求的提高，那时会倒逼你进阶的。 遗憾的是，因为没有完全掌握，所以再回看已经看过的视频，还是似懂非懂，但是比第一次要好很多。建议大家多看几遍，加强练习，跟自己的项目相结合，动手实现会加深理解。“精通的目的全在于应用”（毛语），机器学习只是工具，应用到解决实际问题上才能真正体现它的价值。 跟这个课程最接近的，是加州理工学院的《机器学习与数据挖掘》（18集）（网址http://v.163.com/special/opencourse/learningfromdata.html），主讲老师有口音，很重，如果没有中文字幕的帮助，很难快速掌握。目前网易的进展是，翻译完了前4集。 顺便说一句，以后想练专业口语的话，可以多看Andrew Ng这个，跟着说，以后在国际会议上就能充分表达了。听加州理工的这个，也能听懂那些非英语母语国家讲的英语了。不同的地方有不同的英语口音，我们还不算难听的，应该算是好听的，呵呵。 又及，自己心里暗想，土鳖也能“准”“海归”一回。网络带来了革命，网络也给我们这些爱学习的人带来了真正“免费的午餐”。其实，话说回来，就像免费的搜索引擎一样，他们收获的是更大的名声上的胜利，扩大了影响，传播了美誉。像耶鲁大学的一个教授的一句玩笑话，其目的是争取“世界学术霸权”。 Andrew Ng教授的《机器学习》公开课视频（30集）http://openclassroom.stanford.edu/MainFolder/CoursePage.php?course=MachineLearning Andrew Ng教授的Deep Learning维基，有中文翻译http://deeplearning.stanford.edu/wiki/index.php/UFLDL_Tutorial 其他教学资源韩家炜教授在北大的《数据挖掘》暑期班视频，英文PPT，中文讲解（22集）http://v.youku.com/v_show/id_XMzA3NDI5MzI=.html（视频：01数据挖掘概念，课程简介，数据库技术发展史，数据挖掘应用） 韩家炜教授（UIUC大学）的《数据挖掘》在线课程https://wiki.engr.illinois.edu/display/cs412/Home;jsessionid=6BF0A2C36A95A31D2DA754A017756F4B 卡内基•梅隆大学（CMU）的《机器学习》在线课程http://www.cs.cmu.edu/~epxing/Class/10701/lecture.html 麻省理工学院（MIT）的《机器学习》在线课程http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-867-machine-learning-fall-2006/index.htm 加州理工学院（Caltech）的《机器学习与数据挖掘》在线课程http://work.caltech.edu/telecourse.html（同上述网易公开课)http://v.163.com/special/opencourse/learningfromdata.html UC Irvine的《机器学习与数据挖掘》在线课程http://sli.ics.uci.edu/Classes/2011W-178 斯坦福大学的《数据挖掘》在线课程http://www.stanford.edu/class/stats202/ 其他资源北京机器学习读书会http://q.weibo.com/1644133 机器学习相关电子书http://t.cn/zjtPuCS（打开artificial intelligence找子目录machine learning） 附：主讲教师介绍：（新浪公开课：机器学习http://open.sina.com.cn/course/id_280/）讲师：Andrew Ng学校：斯坦福斯坦福大学计算机系副教授，人工智能实验室主任，致力于人工智能、机器学习，神经信息科学以及机器人学等研究方向。他和他的学生成功开发出新的机器视觉算法，大大简化了机器人的传感器系统。","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"机器学习","slug":"数据科学/机器学习","permalink":"http://qinjiangbo.com/categories/数据科学/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://qinjiangbo.com/tags/机器学习/"},{"name":"Mechine Learning","slug":"Mechine-Learning","permalink":"http://qinjiangbo.com/tags/Mechine-Learning/"}]},{"title":"MyBatis实战-8-代码生成工具MBG","slug":"mybatis-practice-mbg-8","date":"2016-10-01T13:35:55.000Z","updated":"2018-04-02T09:00:34.000Z","comments":true,"path":"mybatis-practice-mbg-8.html","link":"","permalink":"http://qinjiangbo.com/mybatis-practice-mbg-8.html","excerpt":"","text":"MyBatis代码生成工具MyBatis GeneratorMyBatis Generator简介MyBatis Generator (MBG) 是一个Mybatis的代码生成器 MyBatis 和 iBATIS. 它可以生成Mybatis各个版本的代码，和iBATIS 2.2.0版本以后的代码。 它可以内省数据库的表（或多个表）然后生成可以用来访问（多个）表的基础对象。 这样和数据库表进行交互时不需要创建对象和配置文件。 MBG的解决了对数据库操作有最大影响的一些简单的CRUD（插入，查询，更新，删除）操作。 你仍然需要对联合查询和存储过程手写SQL和对象。 MBG生成对象说明MyBatis Generator 会生成: 匹配表结构的Java POJO，可能包括: 一个和表主键匹配的类(如果存在主键[注:只有联合主键会有]) 一个包含了非主键字段的类(BLOB字段除外[注:单字段做主键时这里会包含]) 一个包含了BLOB字段的类 (如果表包含了BLOB字段) 一个允许动态查询、更新和删除的类[注:指的是Example查询] 这些类之间会有适当的继承关系。 请注意可以配置生成器来生成不同类型的 POJO 的层次结构。 例如，如果你愿意你可能会选择针对每个表生成一个单独的实体对象。 MBG映射文件说明MyBatis/iBATIS 兼容 SQL 映射 XML 文件。MBG 在配置中为每个表简单的 CRUD 操作生成 SQL。 生成的 SQL 语句包括： insert (插入) update by primary key (根据主键更新记录) update by example (根据条件更新记录) delete by primary key (根据主键删除记录) delete by example (根据条件删除记录) select by primary key (根据主键查询记录) select by example (根据条件查询记录集) count by example (根据条件查询记录总数) 根据表的结构，生成的这些语句会有不同的变化（例如，如果表中没有主键，那么 MBG 将不会生成update by primary key方法）。 项目依赖管理当前MySQL的JDBC连接的jar包已经出到了6.0.3版本，但很遗憾的是，这个版本还存在很多问题，比如jdbc连接的方式的改变，原来的声明需要做大量的修改，此外，最新版的mybatis-generator-core也无法正常的工作，因为生成的映射文件不包含primary key选项，估计是最新的MySQL连接包作了限制。现在当前环境建议大家还是使用5.x版本比较靠谱。以下是相关依赖： dom4j-1.6.1.jar hamcrest-core-1.3.jar junit-4.12.jar mybatis-3.4.1.jar mybatis-generator-core-1.3.5.jar mysql-connector-java-5.1.39.jar Maven地址（关于Maven相关的教程后续会陆续推出，这里提供给使用Maven的读者） 123456789101112131415161718192021222324252627282930&lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt;&lt;/dependency&gt; （一）生成模板映射XML文件CreateGenConfigXML.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182package com.qinjiangbo.gen.util;import org.dom4j.Document;import org.dom4j.DocumentHelper;import org.dom4j.Element;import org.dom4j.dom.DOMDocumentType;import org.dom4j.io.OutputFormat;import org.dom4j.io.XMLWriter;import org.dom4j.tree.DefaultDocumentType;import java.io.File;import java.io.FileOutputStream;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * Date: 9/26/16 * Author: qinjiangbo@github.io */public class CreateGenConfigXML &#123; /** * 获得数据库连接 * * @return */ public static Connection getConnection() &#123; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mybatis\", \"Richard\", \"123456\"); return connection; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 获取全部的表名 * @return * @throws SQLException */ public static List&lt;String&gt; getTableNames() throws SQLException &#123; List&lt;String&gt; names = new ArrayList&lt;String&gt;(); Connection connection = getConnection(); DatabaseMetaData databaseMetaData = connection.getMetaData(); String[] types = &#123;\"TABLE\"&#125;; ResultSet resultSet = databaseMetaData.getTables(null, null, \"%\", types); while (resultSet.next()) &#123; String name = (String) resultSet.getObject(\"TABLE_NAME\"); if (name.contains(\"（\") || name.contains(\"）\")) &#123; continue; &#125; names.add(name); &#125; connection.close(); return names; &#125; /** * 生成DOM文件 * @return * @throws SQLException */ private static Document createDom() throws SQLException &#123; Document doc = DocumentHelper.createDocument(); //创建DOCTYPE申明 doc.setDocType(new DOMDocumentType(\"generatorConfiguration\", \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\", \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\")); //创建根结点 Element root = doc.addElement(\"generatorConfiguration\"); //创建上下文结点 Element context = root.addElement(\"context\"); context.addAttribute(\"id\", \"MBG\"); context.addAttribute(\"targetRuntime\", \"Mybatis3\"); context.addAttribute(\"defaultModelType\", \"conditional\"); //创建插件结点(这里默认每个类序列化) Element plugin = context.addElement(\"plugin\"); plugin.addAttribute(\"type\", \"org.mybatis.generator.plugins.SerializablePlugin\"); //创建注释结点,判断是否生成注释 Element commentGenerator = context.addElement(\"commentGenerator\"); Element property = commentGenerator.addElement(\"property\"); property.addAttribute(\"name\", \"suppressAllComments\"); property.addAttribute(\"value\", \"false\"); //创建jdbc连接结点 Element jdbcConnection = context.addElement(\"jdbcConnection\"); jdbcConnection.addAttribute(\"driverClass\", \"com.mysql.jdbc.Driver\"); jdbcConnection.addAttribute(\"connectionURL\", \"jdbc:mysql://localhost:3306/mybatis\"); jdbcConnection.addAttribute(\"userId\", \"Richard\"); jdbcConnection.addAttribute(\"password\", \"123456\"); //创建java类型处理类结点 Element javaTypeResolver = context.addElement(\"javaTypeResolver\"); Element property2 = javaTypeResolver.addElement(\"property\"); property2.addAttribute(\"name\", \"forceBigDecimals\"); property2.addAttribute(\"value\", \"false\"); //创建java模型结点 Element javaModelGenerator = context.addElement(\"javaModelGenerator\"); javaModelGenerator.addAttribute(\"targetPackage\", \"com.qinjiangbo.gen.model\"); javaModelGenerator.addAttribute(\"targetProject\", \"src\"); Element property3 = javaModelGenerator.addElement(\"property\"); property3.addAttribute(\"name\", \"enableSubPackages\"); property3.addAttribute(\"value\", \"true\"); //创建sql映射文件结点 Element sqlMapGenerator = context.addElement(\"sqlMapGenerator\"); sqlMapGenerator.addAttribute(\"targetPackage\", \"com.qinjiangbo.gen.mapper\"); sqlMapGenerator.addAttribute(\"targetProject\", \"src\"); Element property4 = sqlMapGenerator.addElement(\"property\"); property4.addAttribute(\"name\", \"enableSubPackages\"); property4.addAttribute(\"value\", \"true\"); //创建java客户端结点,这里声明了dao层的位置 Element javaClientGenerator = context.addElement(\"javaClientGenerator\"); javaClientGenerator.addAttribute(\"type\", \"XMLMAPPER\"); javaClientGenerator.addAttribute(\"targetPackage\", \"com.qinjiangbo.gen.mapper\"); javaClientGenerator.addAttribute(\"targetProject\", \"src\"); Element property5 = javaClientGenerator.addElement(\"property\"); property5.addAttribute(\"name\", \"enableSubPackages\"); property5.addAttribute(\"value\", \"true\"); //创建表(table)结点 List&lt;String&gt; names = getTableNames(); for (String name : names) &#123; String[] words = name.split(\"_\"); String entityName = \"\"; for (String word : words) &#123; word = word.substring(0, 1).toUpperCase() + word.substring(1); if (entityName == null || entityName.equals(\"\")) &#123; entityName = word; &#125; else &#123; entityName = entityName + word; &#125; &#125; Element tableNode = context.addElement(\"table\"); tableNode.addAttribute(\"tableName\", name); tableNode.addAttribute(\"domainObjectName\", entityName); tableNode.addAttribute(\"enableCountByExample\", \"true\"); tableNode.addAttribute(\"enableUpdateByExample\", \"true\"); tableNode.addAttribute(\"enableDeleteByExample\", \"true\"); tableNode.addAttribute(\"enableSelectByExample\", \"true\"); tableNode.addAttribute(\"selectByExampleQueryId\", \"true\"); tableNode.addAttribute(\"enableDeleteByPrimaryKey\", \"true\"); tableNode.addAttribute(\"enableSelectByPrimaryKey\", \"true\"); tableNode.addAttribute(\"enableUpdateByPrimaryKey\", \"true\"); tableNode.addAttribute(\"enableInsert\", \"true\"); &#125; return doc; &#125; /** * 写入到XML文件中 * @throws Exception */ public static void writeXML() throws Exception &#123; XMLWriter xmlWriter = null; String userDir = System.getProperty(\"user.dir\"); String fileName = userDir + \"/src/com/qinjiangbo/gen/util/generatorConfiguration.xml\"; OutputFormat format = OutputFormat.createPrettyPrint(); FileOutputStream fos = new FileOutputStream(new File(fileName)); format.setEncoding(\"utf-8\"); xmlWriter = new XMLWriter(fos, format); xmlWriter.write(createDom()); xmlWriter.close(); &#125; public static void main(String[] args) throws Exception &#123; writeXML(); System.out.println(\"Completed!\"); &#125;&#125; （二）生成的GeneratorConfiguration.xml文件由前一步生成的GeneratorConfiguration.xml文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;context id=\"MBG\" targetRuntime=\"Mybatis3\" defaultModelType=\"conditional\"&gt; &lt;plugin type=\"org.mybatis.generator.plugins.SerializablePlugin\"/&gt; &lt;commentGenerator&gt; &lt;property name=\"suppressAllComments\" value=\"false\"/&gt; &lt;/commentGenerator&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/mybatis\" userId=\"Richard\" password=\"123456\"/&gt; &lt;javaTypeResolver&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage=\"com.qinjiangbo.gen.model\" targetProject=\"src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage=\"com.qinjiangbo.gen.mapper\" targetProject=\"src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.qinjiangbo.gen.mapper\" targetProject=\"src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/javaClientGenerator&gt; &lt;table tableName=\"class\" domainObjectName=\"Class\" enableCountByExample=\"true\" enableUpdateByExample=\"true\" enableDeleteByExample=\"true\" enableSelectByExample=\"true\" selectByExampleQueryId=\"true\" enableDeleteByPrimaryKey=\"true\" enableSelectByPrimaryKey=\"true\" enableUpdateByPrimaryKey=\"true\" enableInsert=\"true\"/&gt; &lt;table tableName=\"orders\" domainObjectName=\"Orders\" enableCountByExample=\"true\" enableUpdateByExample=\"true\" enableDeleteByExample=\"true\" enableSelectByExample=\"true\" selectByExampleQueryId=\"true\" enableDeleteByPrimaryKey=\"true\" enableSelectByPrimaryKey=\"true\" enableUpdateByPrimaryKey=\"true\" enableInsert=\"true\"/&gt; &lt;table tableName=\"student\" domainObjectName=\"Student\" enableCountByExample=\"true\" enableUpdateByExample=\"true\" enableDeleteByExample=\"true\" enableSelectByExample=\"true\" selectByExampleQueryId=\"true\" enableDeleteByPrimaryKey=\"true\" enableSelectByPrimaryKey=\"true\" enableUpdateByPrimaryKey=\"true\" enableInsert=\"true\"/&gt; &lt;table tableName=\"teacher\" domainObjectName=\"Teacher\" enableCountByExample=\"true\" enableUpdateByExample=\"true\" enableDeleteByExample=\"true\" enableSelectByExample=\"true\" selectByExampleQueryId=\"true\" enableDeleteByPrimaryKey=\"true\" enableSelectByPrimaryKey=\"true\" enableUpdateByPrimaryKey=\"true\" enableInsert=\"true\"/&gt; &lt;table tableName=\"users\" domainObjectName=\"Users\" enableCountByExample=\"true\" enableUpdateByExample=\"true\" enableDeleteByExample=\"true\" enableSelectByExample=\"true\" selectByExampleQueryId=\"true\" enableDeleteByPrimaryKey=\"true\" enableSelectByPrimaryKey=\"true\" enableUpdateByPrimaryKey=\"true\" enableInsert=\"true\"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 关于这个文件的具体说明请移步MyBatis-Generator的官方说明，这里读者可以通过阅读XML获得相关属性的含义和作用。 （三）生成DAO层的SQL映射文件123456789101112131415161718192021222324252627282930package com.qinjiangbo.gen.util;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;/** * Date: 9/26/16 * Author: qinjiangbo@github.io */public class Generator &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; String userDir = System.getProperty(\"user.dir\"); File configFile = new File(userDir + \"/src/com/qinjiangbo/gen/util/generatorConfiguration.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); System.out.println(\"Completed!\"); &#125;&#125; 针对上面这个文件需要说明的是需要指明配置文件的所在位置，然后回调函数设置为空，表示不做任何操作。就是静态地生成这些DAO层的SQL映射文件即可。 项目结构图项目的结构会发生很大的变化，新生成的SQL映射文件包括Java文件和XML文件都在同一个包，在企业开发中通常这两个也是一直被放在一个包，便于管理，然后模型Model放在另一个包。结构图如下： 上面util包是前面生成映射文件所需要的工具包。读者可以根据自身的实际情况更改所在包。 项目测试下面选择两个映射文件中的随机两个方法进行抽样测试（这个完全是为了节省版面，正规的还是需要做路径覆盖测试的，请读者自行在下面测试）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.qinjiangbo.test;import com.qinjiangbo.gen.mapper.StudentMapper;import com.qinjiangbo.gen.mapper.TeacherMapper;import com.qinjiangbo.gen.model.Student;import com.qinjiangbo.gen.model.StudentExample;import com.qinjiangbo.gen.model.Teacher;import com.qinjiangbo.gen.model.TeacherExample;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.List;/** * Date: 27/09/2016 * Author: qinjiangbo@github.io */public class MyBatisTest7 &#123; private SqlSession sqlSession = null; @Before public void init() &#123; String config = \"com/qinjiangbo/conf/configure.xml\"; InputStream inputStream = MyBatisTest2.class.getClassLoader().getResourceAsStream(config); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); sqlSession = sqlSessionFactory.openSession(); &#125; @Test public void testFindTeachers() &#123; TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class); TeacherExample example = new TeacherExample(); example.createCriteria().andTGenderIsNotNull(); List&lt;Teacher&gt; teacherList = mapper.selectByExample(example); for (Teacher teacher : teacherList) &#123; System.out.println(teacher.gettName() + \" \" + teacher.gettGender()); &#125; &#125; @Test public void testFindStudents() &#123; StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); StudentExample example = new StudentExample(); example.createCriteria().andCIdEqualTo(3); List&lt;Student&gt; studentList = mapper.selectByExample(example); for (Student student : studentList) &#123; System.out.println(student.getsName() + \" \" + student.getsAge()); &#125; &#125; @After public void commit() &#123; sqlSession.commit(); &#125;&#125; 测试结果testFindTeachers(): 1234567Loris MaleLily FemaleQinJiangbo FemaleSony MaleSarah FemaleToffy MaleJeserf Male testFindStudents(): 12QinJiangbo 21YuYing 21 以上测试全部通过！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://qinjiangbo.com/tags/MyBatis/"},{"name":"实战","slug":"实战","permalink":"http://qinjiangbo.com/tags/实战/"}]},{"title":"MyBatis实战-7-XML标签动态 SQL","slug":"mybatis-practice-dynamic-xml-sql-7","date":"2016-09-25T13:04:08.000Z","updated":"2018-04-02T09:00:09.000Z","comments":true,"path":"mybatis-practice-dynamic-xml-sql-7.html","link":"","permalink":"http://qinjiangbo.com/mybatis-practice-dynamic-xml-sql-7.html","excerpt":"","text":"MyBatis的XML标签MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其他类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句有多么痛苦。拼接的时候要确保不能忘了必要的空格，还要注意省掉列名列表最后的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 代码示例这里就不做过多讲解啦，需要说的都在代码中进行了注释，希望大家仔细阅读。 TeacherMapper.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.qinjiangbo.dao;import com.qinjiangbo.pojo.Teacher;import java.util.List;import java.util.Map;/** * Date: 24/09/2016 * Author: qinjiangbo@github.io */public interface TeacherMapper &#123; /** * 调用存储过程 * * @param map * @return */ public void countTeacherNumber(Map map); /** * 根据编号列表查找教师信息 * * @param ids List * @return */ public List&lt;Teacher&gt; findTeachersByIds(List&lt;Integer&gt; ids); /** * 根据编号列表查找教师信息 * * @param ids Array * @return */ public List&lt;Teacher&gt; findTeachersByIds2(int[] ids); /** * 根据名称前缀获取教师信息 * * @param prefix * @return */ public List&lt;Teacher&gt; findTeacherByNamePrefix(String prefix); /** * 更新教师信息 * * @param teacher * @return */ public int updateTeacherInfo(Teacher teacher);&#125; TeacherMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.qinjiangbo.dao.TeacherMapper\"&gt; &lt;select id=\"countTeacherNumber\" parameterMap=\"countTeacherNumberMap\" statementType=\"CALLABLE\"&gt; CALL mybatis.count_teacher_procedure(?, ?) &lt;/select&gt; &lt;parameterMap type=\"java.util.Map\" id=\"countTeacherNumberMap\"&gt; &lt;parameter property=\"t_sex\" jdbcType=\"INTEGER\" mode=\"IN\"/&gt; &lt;parameter property=\"user_count\" jdbcType=\"INTEGER\" mode=\"OUT\"/&gt; &lt;/parameterMap&gt; &lt;select id=\"findTeachersByIds\" resultMap=\"teacherInfoMap\"&gt; SELECT * FROM teacher WHERE t_id in &lt;!-- collection这里指定参数的集合类型 list, array等--&gt; &lt;foreach collection=\"list\" item=\"ids\" index=\"index\" open=\"(\" close=\")\" separator=\",\"&gt; #&#123;ids&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;select id=\"findTeachersByIds2\" resultMap=\"teacherInfoMap\"&gt; SELECT * FROM teacher WHERE t_id in &lt;!-- collection这里指定参数的集合类型 list, array等--&gt; &lt;foreach collection=\"array\" item=\"ids\" index=\"index\" open=\"(\" close=\")\" separator=\",\"&gt; #&#123;ids&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;!-- !!注意!! 这个地方特别容易出错!当使用if标签的时候,需要注意这个问题, 就是单个参数进来判断为空,必须使用_parameter来进行判断,否则 会报错。如果是多个参数的话建议使用一个参数对象封装起来,然后直接使用 #&#123;参数名&#125;来判断!切记! --&gt; &lt;select id=\"findTeacherByNamePrefix\" parameterType=\"java.lang.String\" resultMap=\"teacherInfoMap\"&gt; SELECT * FROM teacher &lt;if test=\"_parameter != null and _parameter != ''\"&gt; WHERE t_name LIKE CONCAT(#&#123;prefix&#125;, '%') &lt;/if&gt; &lt;/select&gt; &lt;update id=\"updateTeacherInfo\" parameterType=\"com.qinjiangbo.pojo.Teacher\"&gt; UPDATE teacher &lt;set&gt; &lt;if test=\"name != null and name != ''\"&gt; t_name = #&#123;name&#125; &lt;/if&gt; &lt;if test=\"office != null and office != ''\"&gt; t_office = #&#123;office&#125; &lt;/if&gt; &lt;if test=\"gender != null and gender != ''\"&gt; t_gender = #&#123;gender&#125; &lt;/if&gt; &lt;/set&gt; WHERE t_id = #&#123;id&#125; &lt;/update&gt; &lt;resultMap id=\"teacherInfoMap\" type=\"com.qinjiangbo.pojo.Teacher\"&gt; &lt;id column=\"t_id\" property=\"id\"/&gt; &lt;result column=\"t_name\" property=\"name\"/&gt; &lt;result column=\"t_office\" property=\"office\"/&gt; &lt;result column=\"t_gender\" property=\"gender\"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 测试用例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.qinjiangbo.test;import com.qinjiangbo.dao.TeacherMapper;import com.qinjiangbo.pojo.Teacher;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * Date: 25/09/2016 * Author: qinjiangbo@github.io */public class MyBatisTest6 &#123; private SqlSession sqlSession = null; @Before public void init() &#123; String config = \"com/qinjiangbo/conf/configure.xml\"; InputStream inputStream = MyBatisTest2.class.getClassLoader().getResourceAsStream(config); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); sqlSession = sqlSessionFactory.openSession(); &#125; @Test public void testFindTeacherByIds() &#123; TeacherMapper teacherMapper = sqlSession.getMapper(TeacherMapper.class); List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(1002); ids.add(1003); ids.add(1006); List&lt;Teacher&gt; teachers = teacherMapper.findTeachersByIds(ids); Iterator&lt;Teacher&gt; iterator = teachers.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125; @Test public void testFindTeacherByIds2() &#123; TeacherMapper teacherMapper = sqlSession.getMapper(TeacherMapper.class); int[] ids = new int[]&#123;1002, 1004, 1005&#125;; List&lt;Teacher&gt; teachers = teacherMapper.findTeachersByIds2(ids); Iterator&lt;Teacher&gt; iterator = teachers.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125; @Test public void testFindTeacherByNamePrefix() &#123; TeacherMapper teacherMapper = sqlSession.getMapper(TeacherMapper.class); List&lt;Teacher&gt; teachers = teacherMapper.findTeacherByNamePrefix(\"s\"); Iterator&lt;Teacher&gt; iterator = teachers.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125; @Test public void testUpdateTeacherInfo() &#123; TeacherMapper teacherMapper = sqlSession.getMapper(TeacherMapper.class); Teacher teacher = new Teacher(); teacher.setId(1003); teacher.setName(\"QinJiangbo\"); int result = teacherMapper.updateTeacherInfo(teacher); System.out.println(result); &#125; @After public void commit() &#123; sqlSession.commit(); &#125;&#125; 以上代码均通过严格的测试，大家可以根据自己的代码再跑一遍。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://qinjiangbo.com/tags/MyBatis/"},{"name":"实战","slug":"实战","permalink":"http://qinjiangbo.com/tags/实战/"}]},{"title":"MyBatis实战-6-调用存储过程","slug":"mybatis-practice-calling-procedure-5","date":"2016-09-24T15:12:08.000Z","updated":"2018-04-02T09:00:38.000Z","comments":true,"path":"mybatis-practice-calling-procedure-5.html","link":"","permalink":"http://qinjiangbo.com/mybatis-practice-calling-procedure-5.html","excerpt":"","text":"MyBatis调用存储过程在业务逻辑非常复杂的时候，使用一般的代码编程会使得代码的效率变得非常的低，这个时候使用数据库中的存储过程将会是一个不错的选择。下面我们通过教师表这个例子为大家讲述如何使用MyBatis来调用数据库中的存储过程。 新建存储过程在前面的教程中我们建立了Teacher表，我们现在有一个需求，需要知道男女老师的数量分别是多少？这个时候我们编写一个简单的存储过程。博主的环境是在MySQL5.5的环境下测试的，所有的语法都是基于这个版本。 1234567BEGINIF t_sex = 0 THENSELECT COUNT(*) FROM teacher WHERE t_gender = \"Male\" INTO user_count;ELSESELECT COUNT(*) FROM teacher WHERE t_gender = \"Female\" INTO user_count;END IF;END 以上代码是在Navicat工具里面完成的，还需要设置输入输出参数，IN t_sex INT, OUT user_count INT，见下图。 新建教师表映射关系1.新建TeachMapper.java和TeacherMapper.xml两个文件，如下： TeacherMapper.java 123456789101112131415161718package com.qinjiangbo.dao;import java.util.Map;/** * Date: 24/09/2016 * Author: qinjiangbo@github.io */public interface TeacherMapper &#123; /** * 调用存储过程 * * @param map * @return */ public void countTeacherNumber(Map map);&#125; TeacherMapper.xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.qinjiangbo.dao.TeacherMapper\"&gt; &lt;select id=\"countTeacherNumber\" parameterMap=\"countTeacherNumberMap\" statementType=\"CALLABLE\"&gt; CALL mybatis.count_teacher_procedure(?, ?) &lt;/select&gt; &lt;parameterMap type=\"java.util.Map\" id=\"countTeacherNumberMap\"&gt; &lt;parameter property=\"t_sex\" jdbcType=\"INTEGER\" mode=\"IN\"/&gt; &lt;parameter property=\"user_count\" jdbcType=\"INTEGER\" mode=\"OUT\"/&gt; &lt;/parameterMap&gt;&lt;/mapper&gt; 2.注册Mapper，这个千万不能忘记，具体操作见面教程，这里不再赘述。 测试实例当编写完毕之后，我们还需要对整体进行一个测试，以便于测试我们编写代码是否有误。在编写之前我需要给大家确认数据表中的数据。如下图： 通过这个数据表我们可以知道女教师有三位，男教师有四位。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.qinjiangbo.test;import com.qinjiangbo.dao.TeacherMapper;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.HashMap;import java.util.Map;/** * Date: 24/09/2016 * Author: qinjiangbo@github.io */public class MyBatisTest5 &#123; private SqlSession sqlSession = null; @Before public void init() &#123; String config = \"com/qinjiangbo/conf/configure.xml\"; InputStream inputStream = MyBatisTest2.class.getClassLoader().getResourceAsStream(config); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); sqlSession = sqlSessionFactory.openSession(); &#125; @Test public void testInvokeProcedure() &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"t_sex\", 1); map.put(\"user_count\", 0); TeacherMapper teacherMapper = sqlSession.getMapper(TeacherMapper.class); teacherMapper.countTeacherNumber(map); System.out.println(map.get(\"user_count\")); &#125; @After public void commit() &#123; sqlSession.commit(); &#125;&#125; 最后结果确认，执行完毕之后控制台打印了3。说明我们之前的测试结果和业务需求的！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://qinjiangbo.com/tags/MyBatis/"},{"name":"实战","slug":"实战","permalink":"http://qinjiangbo.com/tags/实战/"}]},{"title":"Unix下搭建SVN服务器(CentOS)","slug":"build-svn-server-in-centos","date":"2016-09-23T15:59:47.000Z","updated":"2016-09-23T17:50:26.000Z","comments":true,"path":"build-svn-server-in-centos.html","link":"","permalink":"http://qinjiangbo.com/build-svn-server-in-centos.html","excerpt":"","text":"说起SVN，每个人或多或少都会接触过一些，目前主流的两种版本控制工具就是SVN和Git，在Git诞生之前，整个天下就是SVN的。即使是现在，仍然有相当的一部分企业采用SVN进行版本的控制。说到这里，有的人可能会问到，为什么要使用版本控制呢？这个问题啊，最简单地回答就是可以在需要的时候快速回溯到之前的版本，保护自己所做的工作，复杂的定义请自行百度。 安装SVN在CentOS里面，安装软件非常的方便，使用yum install *的命令就可以了，所以我们使用yum install subversion来安装这个版本控制工具。 1234567891011121314151617181920212223242526272829303132333435363738[root@richard Documents]# yum install subversionLoading mirror speeds from cached hostfile * base: ftp.sjtu.edu.cn * extras: mirrors.cn99.com * updates: ftp.sjtu.edu.cnResolving Dependencies--&gt; Running transaction check---&gt; Package subversion.x86_64 0:1.6.11-15.el6_7 will be installed--&gt; Finished Dependency ResolutionDependencies Resolved======================================================================================================================== Package Arch Version Repository Size========================================================================================================================Installing: subversion x86_64 1.6.11-15.el6_7 base 2.3 MTransaction Summary========================================================================================================================Install 1 Package(s)Total download size: 2.3 MInstalled size: 12 MIs this ok [y/N]: yDownloading Packages:subversion-1.6.11-15.el6_7.x86_64.rpm | 2.3 MB 00:16Running rpm_check_debugRunning Transaction TestTransaction Test SucceededRunning Transaction Installing : subversion-1.6.11-15.el6_7.x86_64 1/1 Verifying : subversion-1.6.11-15.el6_7.x86_64 1/1Installed: subversion.x86_64 0:1.6.11-15.el6_7Complete! 安装完毕可以使用svn --version的命令来查看版本，以确保安装成功。 123456789101112131415161718[root@richard Documents]# svn --versionsvn, version 1.6.11 (r934486) compiled Aug 17 2015, 08:37:43Copyright (C) 2000-2009 CollabNet.Subversion is open source software, see http://subversion.tigris.org/This product includes software developed by CollabNet (http://www.Collab.Net/).The following repository access (RA) modules are available:* ra_neon : Module for accessing a repository via WebDAV protocol using Neon. - handles 'http' scheme - handles 'https' scheme* ra_svn : Module for accessing a repository using the svn network protocol. - with Cyrus SASL authentication - handles 'svn' scheme* ra_local : Module for accessing a repository on local disk. - handles 'file' scheme 配置SVN服务端这里需要使用svnadmin的命令，我们先创建一个SVN的服务包存放地址。 12345678910[root@richard Documents]# mkdir -pv repomkdir: created directory `repo'[root@richard Documents]# lsrepo[root@richard Documents]# cd repo/[root@richard repo]# pwd/root/Documents/repo[root@richard repo]# svnadmin create /root/Documents/repo/[root@richard repo]# lsconf db format hooks locks README.txt 配置conf目录下的三个文件 authz 123456789101112131415161718192021222324252627# harry = rw# &amp;joe = r# * =# [repository:/baz/fuz]# @harry_and_sally = rw*# = radmin = richard[/]richard = rw@admin = rw[/svn]richard = rw@admin = rw* =[/documents]richard = rw@admin = rw* =[/code]richard = rw@admin = rw* = passwd 123456789### This file is an example password file for svnserve.### Its format is similar to that of svnserve.conf. As shown in the### example below it contains one section labelled [users].### The name and password for each user follow, one account per line.[users]# harry = harryssecret# sally = sallyssecretrichard = 123456 svnserver.conf 123456789101112131415161718192021222324### These options control access to the repository for unauthenticated### and authenticated users. Valid values are &quot;write&quot;, &quot;read&quot;,### and &quot;none&quot;. The sample settings below are the defaults.anon-access = readauth-access = write### The password-db option controls the location of the password### database file. Unless you specify a path starting with a /,### the file&apos;s location is relative to the directory containing### this configuration file.### If SASL is enabled (see below), this file will NOT be used.### Uncomment the line below to use the default password file.password-db = passwd### The authz-db option controls the location of the authorization### rules for path-based access control. Unless you specify a path### starting with a /, the file&apos;s location is relative to the the### directory containing this file. If you don&apos;t specify an### authz-db, no path-based access control is done.### Uncomment the line below to use the default authorization file.authz-db = authz### This option specifies the authentication realm of the repository.### If two repositories have the same authentication realm, they should### have the same password database, and vice versa. The default realm### is repository&apos;s uuid.# realm = /root/Documents/repo/ 启动SVN服务器： 1svnserve -d -r /root/Documents/repo/ 客户端连接测试客户端有很多形式，最常用的几种客户端分别是TortoiseSVN和SmartSVN，不过博主在这儿想介绍的是SVN命令的客户端。 1svn checkout svn://*.*.*.* . #这个点表示在当前目录下检出 注意 博主注意到，如果是连不上失败的话，有两种原因，第一种，SVN服务器没启动，第二种，服务器的防火墙策略。你需要修改防火墙的设置，这里博主给出一份iptables的清单，供大家参考。 1234567891011121314151617181920[root@richard conf]# more /etc/sysconfig/iptables# Firewall configuration written by system-config-firewall# Manual customization of this file is not recommended.*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8081 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8009 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 3690 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT 如果自己想添加新的端口，直接按照上面的格式就OK了。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"http://qinjiangbo.com/tags/SVN/"},{"name":"版本控制","slug":"版本控制","permalink":"http://qinjiangbo.com/tags/版本控制/"}]},{"title":"MyBatis实战-5-多表联合查询","slug":"mybatis-practice-union-query-5","date":"2016-09-21T09:52:03.000Z","updated":"2018-04-02T09:00:28.000Z","comments":true,"path":"mybatis-practice-union-query-5.html","link":"","permalink":"http://qinjiangbo.com/mybatis-practice-union-query-5.html","excerpt":"","text":"多表联合查询在MyBatis中，时常会需要联合多张表进行联合查询，那么如果处理多张表联合查询的结果呢？下面将会讲述如何在MyBatis中进行多张表的联合查询。 一对一查询1.添加实体类Classes, Teacher Classes.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.qinjiangbo.pojo;import java.util.List;/** * Date: 9/16/16 * Author: qinjiangbo@github.io */public class Classes &#123; private int id; private String name; private Teacher teacher; private List&lt;Student&gt; students; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Teacher getTeacher() &#123; return teacher; &#125; public void setTeacher(Teacher teacher) &#123; this.teacher = teacher; &#125; public List&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(List&lt;Student&gt; students) &#123; this.students = students; &#125; @Override public String toString() &#123; return \"Classes&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", teacher=\" + teacher + \", students=\" + students + '&#125;'; &#125;&#125; Teacher.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.qinjiangbo.pojo;/** * Date: 9/16/16 * Author: qinjiangbo@github.io */public class Teacher &#123; private int id; private String name; private String office; private String gender; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getOffice() &#123; return office; &#125; public void setOffice(String office) &#123; this.office = office; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return \"Teacher&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", office='\" + office + '\\'' + \", gender='\" + gender + '\\'' + '&#125;'; &#125;&#125; 2.在数据库中插入实体类的数据 123456789101112131415161718192021222324SET NAMES utf8;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for `class`-- ----------------------------DROP TABLE IF EXISTS `class`;CREATE TABLE `class` ( `c_id` int(11) NOT NULL AUTO_INCREMENT, `c_name` varchar(45) NOT NULL, `t_id` int(11) NOT NULL, PRIMARY KEY (`c_id`), KEY `fk_tid` (`t_id`), CONSTRAINT `fk_tid` FOREIGN KEY (`t_id`) REFERENCES `teacher` (`t_id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of `class`-- ----------------------------BEGIN;INSERT INTO `class` VALUES ('1', 'International Class', '1001'), ('2', 'International Class', '1002'), ('3', 'International Class', '1003');COMMIT;SET FOREIGN_KEY_CHECKS = 1; 1234567891011121314151617181920212223SET NAMES utf8;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for `teacher`-- ----------------------------DROP TABLE IF EXISTS `teacher`;CREATE TABLE `teacher` ( `t_id` int(11) NOT NULL AUTO_INCREMENT, `t_name` varchar(45) NOT NULL, `t_office` varchar(45) NOT NULL, `t_gender` varchar(45) NOT NULL DEFAULT 'female', PRIMARY KEY (`t_id`)) ENGINE=InnoDB AUTO_INCREMENT=1008 DEFAULT CHARSET=utf8;-- ------------------------------ Records of `teacher`-- ----------------------------BEGIN;INSERT INTO `teacher` VALUES ('1001', 'Loris', 'B4056', 'Male'), ('1002', 'Lily', 'B3032', 'Female'), ('1003', 'Sarah', 'B4012', 'Female'), ('1004', 'Sony', 'B4013', 'Male'), ('1005', 'Sarah', 'B4015', 'Female'), ('1006', 'Toffy', 'B1012', 'Male'), ('1007', 'Jeserf', 'B2018', 'Male');COMMIT;SET FOREIGN_KEY_CHECKS = 1; 3.创建Mapper映射文件 ClassesMapper.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.qinjiangbo.dao.ClassesMapper\"&gt; &lt;!-- 根据班级编号查找班级、教师信息 --&gt; &lt;!-- 以下为第一种方式,执行一次查询 SELECT * FROM class c, teacher t WHERE c.c_id = #&#123;id&#125; AND c.t_id = t.t_id; --&gt; &lt;resultMap id=\"classInfoMap\" type=\"com.qinjiangbo.pojo.Classes\"&gt; &lt;id column=\"c_id\" property=\"id\"/&gt; &lt;result column=\"c_name\" property=\"name\"/&gt; &lt;association property=\"teacher\" javaType=\"com.qinjiangbo.pojo.Teacher\"&gt; &lt;id column=\"t_id\" property=\"id\"/&gt; &lt;result column=\"t_name\" property=\"name\"/&gt; &lt;result column=\"t_office\" property=\"office\"/&gt; &lt;result column=\"t_gender\" property=\"gender\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"findClassById\" parameterType=\"int\" resultMap=\"classInfoMap\"&gt; SELECT * FROM class c, teacher t WHERE c.c_id = #&#123;id&#125; AND c.t_id = t.t_id; &lt;/select&gt; &lt;!-- 以下为第二种方式,执行两次查询 1. SELECT * FROM class WHERE c_id = #&#123;id&#125;; 2. SELECT * FROM teacher WHERE t_id = #&#123;id&#125;; 第二次查询依赖于第一次查询所得的结果 --&gt; &lt;resultMap id=\"classInfoMap2\" type=\"com.qinjiangbo.pojo.Classes\"&gt; &lt;id column=\"c_id\" property=\"id\"/&gt; &lt;result column=\"c_name\" property=\"name\"/&gt; &lt;association column=\"t_id\" property=\"teacher\" select=\"findTeacherById\"/&gt; &lt;/resultMap&gt; &lt;resultMap id=\"teacherInfoMap\" type=\"com.qinjiangbo.pojo.Teacher\"&gt; &lt;id column=\"t_id\" property=\"id\"/&gt; &lt;result column=\"t_name\" property=\"name\"/&gt; &lt;result column=\"t_office\" property=\"office\"/&gt; &lt;result column=\"t_gender\" property=\"gender\"/&gt; &lt;/resultMap&gt; &lt;select id=\"findClassById2\" parameterType=\"int\" resultMap=\"classInfoMap2\"&gt; SELECT * FROM class WHERE c_id = #&#123;id&#125;; &lt;/select&gt; &lt;select id=\"findTeacherById\" parameterType=\"int\" resultMap=\"teacherInfoMap\"&gt; SELECT * FROM teacher WHERE t_id = #&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt; ClassesMapper.java 1234567891011121314151617181920212223package com.qinjiangbo.dao;import com.qinjiangbo.pojo.Classes;import java.util.List;/** * Date: 9/16/16 * Author: qinjiangbo@github.io */public interface ClassesMapper &#123; /** * 根据编号查找班级信息 * * @param id * @return */ public Classes findClassById(int id); public Classes findClassById2(int id); &#125; 注意 这里需要在MyBatis的配置文件中注册这个Mapper映射文件，千万别忘记了，否则会报错！ 4.测试实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.qinjiangbo.test;import com.qinjiangbo.dao.ClassesMapper;import com.qinjiangbo.pojo.Classes;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;/** * Date: 9/17/16 * Author: qinjiangbo@github.io */public class MyBatisTest4 &#123; private SqlSession sqlSession = null; @Before public void init() &#123; String config = \"com/qinjiangbo/conf/configure.xml\"; InputStream inputStream = MyBatisTest2.class.getClassLoader().getResourceAsStream(config); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); sqlSession = sqlSessionFactory.openSession(); &#125; @Test public void testFindClassById() &#123; ClassesMapper classesMapper = sqlSession.getMapper(ClassesMapper.class); Classes classes = classesMapper.findClassById(1); System.out.println(classes); &#125; @Test public void testFindClassById2() &#123; ClassesMapper classesMapper = sqlSession.getMapper(ClassesMapper.class); Classes classes = classesMapper.findClassById2(1); System.out.println(classes); &#125; @After public void commit() &#123; sqlSession.commit(); &#125;&#125; 一对多查询1.修改Mapper映射文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.qinjiangbo.dao.ClassesMapper\"&gt; &lt;!-- 根据班级编号查找班级、教师信息 --&gt; &lt;!-- 以下为第一种方式,执行一次查询 SELECT * FROM class c, teacher t WHERE c.c_id = #&#123;id&#125; AND c.t_id = t.t_id; --&gt; &lt;resultMap id=\"classInfoMap\" type=\"com.qinjiangbo.pojo.Classes\"&gt; &lt;id column=\"c_id\" property=\"id\"/&gt; &lt;result column=\"c_name\" property=\"name\"/&gt; &lt;association property=\"teacher\" javaType=\"com.qinjiangbo.pojo.Teacher\"&gt; &lt;id column=\"t_id\" property=\"id\"/&gt; &lt;result column=\"t_name\" property=\"name\"/&gt; &lt;result column=\"t_office\" property=\"office\"/&gt; &lt;result column=\"t_gender\" property=\"gender\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"findClassById\" parameterType=\"int\" resultMap=\"classInfoMap\"&gt; SELECT * FROM class c, teacher t WHERE c.c_id = #&#123;id&#125; AND c.t_id = t.t_id; &lt;/select&gt; &lt;!-- 以下为第二种方式,执行两次查询 1. SELECT * FROM class WHERE c_id = #&#123;id&#125;; 2. SELECT * FROM teacher WHERE t_id = #&#123;id&#125;; 第二次查询依赖于第一次查询所得的结果 --&gt; &lt;resultMap id=\"classInfoMap2\" type=\"com.qinjiangbo.pojo.Classes\"&gt; &lt;id column=\"c_id\" property=\"id\"/&gt; &lt;result column=\"c_name\" property=\"name\"/&gt; &lt;association column=\"t_id\" property=\"teacher\" select=\"findTeacherById\"/&gt; &lt;/resultMap&gt; &lt;resultMap id=\"teacherInfoMap\" type=\"com.qinjiangbo.pojo.Teacher\"&gt; &lt;id column=\"t_id\" property=\"id\"/&gt; &lt;result column=\"t_name\" property=\"name\"/&gt; &lt;result column=\"t_office\" property=\"office\"/&gt; &lt;result column=\"t_gender\" property=\"gender\"/&gt; &lt;/resultMap&gt; &lt;select id=\"findClassById2\" parameterType=\"int\" resultMap=\"classInfoMap2\"&gt; SELECT * FROM class WHERE c_id = #&#123;id&#125;; &lt;/select&gt; &lt;select id=\"findTeacherById\" parameterType=\"int\" resultMap=\"teacherInfoMap\"&gt; SELECT * FROM teacher WHERE t_id = #&#123;id&#125;; &lt;/select&gt; &lt;!-- 根据班级编号查找班级、教师、学生信息 --&gt; &lt;!-- 方式一: 嵌套结果: 使用嵌套结果映射来处理重复的联合结果的子集 --&gt; &lt;resultMap id=\"classInfoMap3\" type=\"com.qinjiangbo.pojo.Classes\"&gt; &lt;id column=\"c_id\" property=\"id\"/&gt; &lt;result column=\"c_name\" property=\"name\"/&gt; &lt;association property=\"teacher\" javaType=\"com.qinjiangbo.pojo.Teacher\"&gt; &lt;id column=\"t_id\" property=\"id\"/&gt; &lt;result column=\"t_name\" property=\"name\"/&gt; &lt;result column=\"t_office\" property=\"office\"/&gt; &lt;result column=\"t_gender\" property=\"gender\"/&gt; &lt;/association&gt; &lt;collection property=\"students\" ofType=\"com.qinjiangbo.pojo.Student\"&gt; &lt;id column=\"s_id\" property=\"id\"/&gt; &lt;result column=\"s_name\" property=\"name\"/&gt; &lt;result column=\"s_password\" property=\"password\"/&gt; &lt;result column=\"s_age\" property=\"age\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findClassById3\" parameterType=\"int\" resultMap=\"classInfoMap3\"&gt; SELECT * FROM class c, teacher t, student s WHERE c.t_id = t.t_id AND s.c_id = c.c_id AND c.c_id = #&#123;id&#125;; &lt;/select&gt; &lt;!-- 方式二：嵌套查询：通过执行另外一个SQL映射语句来返回预期的复杂类型 --&gt; &lt;resultMap id=\"classInfoMap4\" type=\"com.qinjiangbo.pojo.Classes\"&gt; &lt;id column=\"c_id\" property=\"id\"/&gt; &lt;result column=\"c_name\" property=\"name\"/&gt; &lt;association column=\"t_id\" property=\"teacher\" javaType=\"com.qinjiangbo.pojo.Teacher\" select=\"findTeacherById2\"/&gt; &lt;collection property=\"students\" ofType=\"com.qinjiangbo.pojo.Student\" column=\"c_id\" select=\"findStudentsByCid\"/&gt; &lt;/resultMap&gt; &lt;select id=\"findClassById4\" parameterType=\"int\" resultMap=\"classInfoMap4\"&gt; SELECT * FROM class WHERE c_id = #&#123;id&#125;; &lt;/select&gt; &lt;select id=\"findTeacherById2\" parameterType=\"int\" resultMap=\"teacherInfoMap\"&gt; SELECT * FROM teacher WHERE t_id = #&#123;id&#125;; &lt;/select&gt; &lt;resultMap id=\"studentInfoMap\" type=\"com.qinjiangbo.pojo.Student\"&gt; &lt;id column=\"s_id\" property=\"id\"/&gt; &lt;result column=\"s_name\" property=\"name\"/&gt; &lt;result column=\"s_password\" property=\"password\"/&gt; &lt;result column=\"s_age\" property=\"age\"/&gt; &lt;/resultMap&gt; &lt;select id=\"findStudentsByCid\" parameterType=\"int\" resultMap=\"studentInfoMap\"&gt; SELECT * FROM student WHERE c_id = #&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt; 2.测试实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.qinjiangbo.test;import com.qinjiangbo.dao.ClassesMapper;import com.qinjiangbo.pojo.Classes;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;/** * Date: 9/17/16 * Author: qinjiangbo@github.io */public class MyBatisTest4 &#123; private SqlSession sqlSession = null; @Before public void init() &#123; String config = \"com/qinjiangbo/conf/configure.xml\"; InputStream inputStream = MyBatisTest2.class.getClassLoader().getResourceAsStream(config); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); sqlSession = sqlSessionFactory.openSession(); &#125; @Test public void testFindClassById() &#123; ClassesMapper classesMapper = sqlSession.getMapper(ClassesMapper.class); Classes classes = classesMapper.findClassById(1); System.out.println(classes); &#125; @Test public void testFindClassById2() &#123; ClassesMapper classesMapper = sqlSession.getMapper(ClassesMapper.class); Classes classes = classesMapper.findClassById2(1); System.out.println(classes); &#125; @Test public void testFindClassById3() &#123; ClassesMapper classesMapper = sqlSession.getMapper(ClassesMapper.class); Classes classes = classesMapper.findClassById3(1); System.out.println(classes); &#125; @Test public void testFindClassById4() &#123; ClassesMapper classesMapper = sqlSession.getMapper(ClassesMapper.class); Classes classes = classesMapper.findClassById4(1); System.out.println(classes); &#125; @After public void commit() &#123; sqlSession.commit(); &#125;&#125; 以上结果均通过严格的测试！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://qinjiangbo.com/tags/MyBatis/"},{"name":"实战","slug":"实战","permalink":"http://qinjiangbo.com/tags/实战/"}]},{"title":"MyBatis实战-4-映射表字段名与实体属性名","slug":"mybatis-practice-mapping-entity-and-model-4","date":"2016-09-16T08:07:14.000Z","updated":"2018-04-02T09:00:42.000Z","comments":true,"path":"mybatis-practice-mapping-entity-and-model-4.html","link":"","permalink":"http://qinjiangbo.com/mybatis-practice-mapping-entity-and-model-4.html","excerpt":"","text":"映射表字段名与实体属性名并自定义返回类型很多时候我们需要自定义一些字段的名称或者是结果的返回类型，这个时候就需要将数据表中的字段名称与实体的属性名称相对应，并且添加自定义的结果返回类型。 添加实体对象添加的对象为Student学生对象，属性名称有学生编号，学生姓名，学生密码，以及学生年龄。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.qinjiangbo.pojo;/** * Date: 9/16/16 * Author: qinjiangbo@github.io */public class Student &#123; private int id; private String name; private String password; private int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", password='\" + password + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 添加对应表数据在数据库中新建一张表，并向其中插入测试数据。 1234567891011121314151617181920212223242526272829-- ------------------------------ Table structure for `student`-- ----------------------------DROP TABLE IF EXISTS `student`;CREATE TABLE `student` ( `s_id` int(11) NOT NULL AUTO_INCREMENT, `s_name` varchar(45) NOT NULL, `s_password` varchar(45) NOT NULL, `s_age` int(11) NOT NULL, `c_id` int(11) NOT NULL, PRIMARY KEY (`s_id`), KEY `fk_cid` (`c_id`), CONSTRAINT `fk_cid` FOREIGN KEY (`c_id`) REFERENCES `class` (`c_id`)) ENGINE=InnoDB AUTO_INCREMENT=580320 DEFAULT CHARSET=utf8;-- ------------------------------ Records of `student`-- ----------------------------BEGIN;INSERT INTO `student` VALUES ('580314', 'QinJiangbo', '234562', '21', '3'), ('580315', 'YuYing', '123245', '21', '3'), ('580316', 'LiuBiqin', '123456', '22', '2'), ('580317', 'ZhouChongyi', '222333', '21', '2'), ('580318', 'XuYouying', 'whuiss', '22', '1'), ('580319', 'YeZetao', 'isswhu', '21', '1');COMMIT;SET FOREIGN_KEY_CHECKS = 1; 映射表字段名称与实体属性名称新建一个映射XML文件StudentMapper.xml和接口StudentMapper.java，在MyBatis配置文件configure.xml中注册这个接口。 12345&lt;mappers&gt; &lt;mapper resource=\"com/qinjiangbo/dao/UserMapper.xml\"/&gt; &lt;mapper class=\"com.qinjiangbo.dao.UserMapperC\"/&gt; &lt;mapper class=\"com.qinjiangbo.dao.StudentMapper\"/&gt;&lt;/mappers&gt; 并在其中加入一个ResultMap，关于ResultMap的定义可以在我的MyBatis框架系列教程里面学习。 StudentMapper.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.qinjiangbo.dao.StudentMapper\"&gt; &lt;resultMap id=\"StudentInfoMap\" type=\"com.qinjiangbo.pojo.Student\"&gt; &lt;id column=\"s_id\" property=\"id\"/&gt; &lt;result column=\"s_name\" property=\"name\"/&gt; &lt;result column=\"s_password\" property=\"password\"/&gt; &lt;result column=\"s_age\" property=\"age\"/&gt; &lt;/resultMap&gt; &lt;resultMap id=\"StudentBasicInfoMap\" type=\"java.util.Map\"&gt; &lt;result column=\"s_name\" property=\"name\"/&gt; &lt;result column=\"s_password\" property=\"password\"/&gt; &lt;/resultMap&gt; &lt;select id=\"findStudentInfo\" resultMap=\"StudentInfoMap\" parameterType=\"int\"&gt; SELECT * FROM student WHERE s_id = #&#123;id&#125;; &lt;/select&gt; &lt;select id=\"findStudentBasicInfo\" resultMap=\"StudentBasicInfoMap\" parameterType=\"int\"&gt; SELECT s_name, s_password FROM student WHERE s_id = #&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt; StudentMapper.java 123456789101112131415161718192021222324252627package com.qinjiangbo.dao;import com.qinjiangbo.pojo.Student;import java.util.Map;/** * Date: 9/16/16 * Author: qinjiangbo@github.io */public interface StudentMapper &#123; /** * 查找学生信息 * * @param id * @return */ public Student findStudentInfo(Integer id); /** * 查找学生基本信息 * * @param id * @return */ public Map findStudentBasicInfo(Integer id);&#125; 测试实例1.获取学生信息 123456@Testpublic void testFindStudentInfo() &#123; StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Student student = studentMapper.findStudentInfo(580314); System.out.println(student);&#125; 结果: Student{id=580314, name=&#39;QinJiangbo&#39;, password=&#39;234562&#39;, age=21} 2.获取学生基本信息 123456@Testpublic void testFindStudentBasicInfo() &#123; StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); Map map = studentMapper.findStudentBasicInfo(580314); System.out.println(map.get(\"name\") + \":\" + map.get(\"password\"));&#125; 结果： QinJiangbo:234562 以上就是将表中的字段名和实体的属性名对应起来并且自定义返回类型的使用方式。以上代码均通过测试。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://qinjiangbo.com/tags/MyBatis/"},{"name":"实战","slug":"实战","permalink":"http://qinjiangbo.com/tags/实战/"}]},{"title":"MyBatis实战-3-优化MyBatis配置项","slug":"mybatis-practice-optimization-of-configurations-3","date":"2016-09-14T14:45:58.000Z","updated":"2018-04-02T09:00:15.000Z","comments":true,"path":"mybatis-practice-optimization-of-configurations-3.html","link":"","permalink":"http://qinjiangbo.com/mybatis-practice-optimization-of-configurations-3.html","excerpt":"","text":"优化MyBatis配置项前面一节说了MyBatis实现CRUD等操作的具体实践，本节将要站在代码的可读性和可维护性上优化MyBatis的配置文件的代码，已达到简洁的目的。 分离数据库配置项一般来说，数据库的配置信息是需要动态变化的。在生产环境中，应用需要连接到生产数据库，在测试环境中，应用需要连接到测试数据库。如果数据库的配置不是动态配置的，则这项配置会变得非常麻烦，大大加大了工程师的工作量，而且是极易发生错误的，且发生了错误排除的成本也会非常的高，所以，我们有必要将这个数据库配置项单独分离出来。 1.在conf包下面创建一个database.properties文件 1234jdbc.driver = com.mysql.cj.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/mybatisjdbc.username = Richardjdbc.password = 123456 2.在MyBatis配置文件下面添加这个配置 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 导入数据库相关的配置信息 --&gt; &lt;properties resource=\"com/qinjiangbo/conf/database.properties\"/&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/qinjiangbo/dao/UserMapper.xml\"/&gt; &lt;mapper class=\"com.qinjiangbo.dao.UserMapperC\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.测试实例 测试实例同上一节相同，请同学们自己结合之前的代码再跑一遍。博主本地的代码均通过严格的测试。 将实体类定义一个别名通常在UserMapper.xml文件中，我们如果需要制定参数类型或者返回数据类型为一个pojo类型，那么我们需要写上它的全类名，这样在某种程度上加大了复杂度，而且不利于开发人员维护代码。这个时候我们需要将这个全类名别名化，博主是提倡使用pojo类本身的类名作为别名的。 1.在MyBatis配置文件中的configuration元素下添加一个typeAliases元素。 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 导入数据库相关的配置信息 --&gt; &lt;properties resource=\"com/qinjiangbo/conf/database.properties\"/&gt; &lt;!-- 添加别名 --&gt; &lt;typeAliases&gt; &lt;typeAlias type=\"com.qinjiangbo.pojo.User\" alias=\"User\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/qinjiangbo/dao/UserMapper.xml\"/&gt; &lt;mapper class=\"com.qinjiangbo.dao.UserMapperC\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; NOTE如果你想要所有的pojo类都自动使用类名来做别名，而不像一个一个配置很麻烦，你可以使用package这个元素，它会默认将这个包下面的所有的类别名化。 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 导入数据库相关的配置信息 --&gt; &lt;properties resource=\"com/qinjiangbo/conf/database.properties\"/&gt; &lt;!-- 添加别名 --&gt; &lt;typeAliases&gt; &lt;package name=\"com.qinjiangbo.pojo\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/qinjiangbo/dao/UserMapper.xml\"/&gt; &lt;mapper class=\"com.qinjiangbo.dao.UserMapperC\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.将UserMapper.xml配置文件中的全类名全部改为类名。 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- 当同时使用XML和注解的时候, 这个命名空间namespace的值必须是Mapper接口的全类路径 --&gt;&lt;mapper namespace=\"com.qinjiangbo.dao.UserMapper\"&gt; &lt;!-- 根据编号查找用户 --&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"User\"&gt; SELECT * FROM users WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 创建用户信息 --&gt; &lt;insert id=\"createUser\" parameterType=\"User\"&gt; INSERT INTO users VALUES (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;, #&#123;age&#125;, #&#123;email&#125;, #&#123;tel&#125;, #&#123;addr&#125;) &lt;/insert&gt; &lt;!-- 删除用户信息 --&gt; &lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; DELETE FROM users WHERE id = #&#123;id&#125; &lt;/delete&gt; &lt;!-- 更新用户信息 --&gt; &lt;update id=\"updateUser\" parameterType=\"User\"&gt; UPDATE users SET name = #&#123;name&#125;, pwd = #&#123;pwd&#125;, age = #&#123;age&#125;, email = #&#123;email&#125;, tel = #&#123;tel&#125;, addr = #&#123;addr&#125; WHERE id = #&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 3.测试实例 同上一样，这个测试实例和上一节的测试实例相同，请同学们自己结合之前的代码再跑一遍。博主本地的代码均通过严格的测试。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://qinjiangbo.com/tags/MyBatis/"},{"name":"实战","slug":"实战","permalink":"http://qinjiangbo.com/tags/实战/"}]},{"title":"MyBatis实战-2-CRUD操作","slug":"mybatis-practice-crud-2","date":"2016-09-14T02:46:58.000Z","updated":"2018-04-02T09:00:20.000Z","comments":true,"path":"mybatis-practice-crud-2.html","link":"","permalink":"http://qinjiangbo.com/mybatis-practice-crud-2.html","excerpt":"","text":"NOTE CRUD操作指的就是增(Create)删(Delete)改(Update)查(Retrieve) 使用MyBatis对数据表进行CRUD操作—XML实现1.定义Mapper映射XML文件UserMapper.xml 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.qinjiangbo.dao.UserMapper\"&gt; &lt;!-- 根据编号查找用户 --&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"com.qinjiangbo.pojo.User\"&gt; SELECT * FROM users WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 创建用户信息 --&gt; &lt;insert id=\"createUser\" parameterType=\"com.qinjiangbo.pojo.User\"&gt; INSERT INTO users VALUES (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;, #&#123;age&#125;, #&#123;email&#125;, #&#123;tel&#125;, #&#123;addr&#125;) &lt;/insert&gt; &lt;!-- 删除用户信息 --&gt; &lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; DELETE FROM users WHERE id = #&#123;id&#125; &lt;/delete&gt; &lt;!-- 更新用户信息 --&gt; &lt;update id=\"updateUser\" parameterType=\"com.qinjiangbo.pojo.User\"&gt; UPDATE users SET name = #&#123;name&#125;, pwd = #&#123;pwd&#125;, age = #&#123;age&#125;, email = #&#123;email&#125;, tel = #&#123;tel&#125;, addr = #&#123;addr&#125; WHERE id = #&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 2.在MyBatis文件中注册UserMapper.xml，这个前一个教程讲过，这里不再赘述。3.测试实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.qinjiangbo.test;import com.qinjiangbo.dao.UserMapperC;import com.qinjiangbo.pojo.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;/** * Date: 9/13/16 * Author: qinjiangbo@github.io */public class MyBatisTest2 &#123; private SqlSession sqlSession = null; @Before public void init() &#123; String config = \"com/qinjiangbo/conf/configure.xml\"; InputStream inputStream = MyBatisTest2.class.getClassLoader().getResourceAsStream(config); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); sqlSession = sqlSessionFactory.openSession(); &#125; /** * BASED ON XML */ // C @Test public void testCreateUser() &#123; // 这里需要指明是Mapper中的哪个方法 String statement = \"com.qinjiangbo.dao.UserMapper.createUser\"; User user = new User(580327, \"Xinxin\", \"123456\", 23, \"123abc@126.com\", \"13888899211\", \"Wuhan University\"); sqlSession.insert(statement, user); &#125; // D @Test public void testDeleteUser() &#123; String statement = \"com.qinjiangbo.dao.UserMapper.deleteUser\"; sqlSession.delete(statement, 580327); &#125; // U @Test public void testUpdateUser() &#123; User user = new User(580314, \"QinJiangbo\", \"123456\", 23, \"123abc@126.com\", \"13888899211\", \"Wuhan University\"); String statement = \"com.qinjiangbo.dao.UserMapper.updateUser\"; sqlSession.update(statement, user); &#125; // R @Test public void testRetrieveUser() &#123; String statement = \"com.qinjiangbo.dao.UserMapper.findUserById\"; User user = sqlSession.selectOne(statement, 580314); System.out.println(user); &#125; @After public void commit() &#123; sqlSession.commit(); &#125;&#125; 使用MyBatis对数据表进行CRUD操作—Java注解实现1.定义Mapper映射类UserMapperC.java 1234567891011121314151617181920212223242526package com.qinjiangbo.dao;import com.qinjiangbo.pojo.User;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;/** * Date: 9/14/16 * Author: qinjiangbo@github.io */public interface UserMapperC &#123; @Insert(\"INSERT INTO users VALUES (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;, #&#123;age&#125;, #&#123;email&#125;, #&#123;tel&#125;, #&#123;addr&#125;)\") public int createUser(User user); @Delete(\"DELETE FROM users WHERE id = #&#123;id&#125;\") public int deleteUser(int id); @Update(\"UPDATE users SET name = #&#123;name&#125;, pwd = #&#123;pwd&#125;, age = #&#123;age&#125;, email = #&#123;email&#125;, tel = #&#123;tel&#125;, addr = #&#123;addr&#125; WHERE id = #&#123;id&#125;\") public int updateUser(User user); @Select(\"SELECT * FROM users WHERE id = #&#123;id&#125;\") public User retrieveUser(int id);&#125; 2.在MyBatis文件中注册UserMapperC.java 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"Richard\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/qinjiangbo/dao/UserMapper.xml\"/&gt; &lt;mapper class=\"com.qinjiangbo.dao.UserMapperC\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.测试实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.qinjiangbo.test;import com.qinjiangbo.dao.UserMapperC;import com.qinjiangbo.pojo.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;/** * Date: 9/13/16 * Author: qinjiangbo@github.io */public class MyBatisTest2 &#123; private SqlSession sqlSession = null; @Before public void init() &#123; String config = \"com/qinjiangbo/conf/configure.xml\"; InputStream inputStream = MyBatisTest2.class.getClassLoader().getResourceAsStream(config); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); sqlSession = sqlSessionFactory.openSession(); &#125; /** * BASED ON ANNOTATION */ // C @Test public void testCreateUser2() &#123; UserMapperC userMapperC = sqlSession.getMapper(UserMapperC.class); User user = new User(580327, \"Xinxin\", \"123456\", 23, \"123abc@126.com\", \"13888899211\", \"Wuhan University\"); userMapperC.createUser(user); &#125; @Test public void testDeleteUser2() &#123; UserMapperC userMapperC = sqlSession.getMapper(UserMapperC.class); userMapperC.deleteUser(580327); &#125; @Test public void testUpdateUser2() &#123; UserMapperC userMapperC = sqlSession.getMapper(UserMapperC.class); User user = new User(580314, \"Handsome\", \"123456\", 23, \"123abc@126.com\", \"13888899211\", \"Wuhan University\"); userMapperC.updateUser(user); &#125; @Test public void testRetrieveUser2() &#123; UserMapperC userMapperC = sqlSession.getMapper(UserMapperC.class); User user = userMapperC.retrieveUser(580314); System.out.println(user); &#125; @After public void commit() &#123; sqlSession.commit(); &#125;&#125; 使用MyBatis对数据表进行CRUD操作—XML与注解混合实现（推荐）1.定义Mapper映射文件UserMapper.xml和UserMapper.java NOTE这里Java文件和XML文件中指定的名称必须一致。一般来说，在这里两个文件的名称一致就行了。 12345678910111213141516171819package com.qinjiangbo.dao;import com.qinjiangbo.pojo.User;/** * Date: 9/14/16 * Author: qinjiangbo@github.io */public interface UserMapper &#123; public User findUserById(int id); public int createUser(User user); public int updateUser(User user); public int deleteUser(int id);&#125; 2.在MyBatis文件中注册UserMapper.xml NOTE这个之前讲过就不再赘述，不过有一个地方需要注意，同时采用XML和注解时，需要将XML文件中的命名空间namespace设置为Mapper接口的全类路径，否则接口和XML具体实现没法对应。 3.测试实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.qinjiangbo.test;import com.qinjiangbo.dao.UserMapper;import com.qinjiangbo.dao.UserMapperC;import com.qinjiangbo.pojo.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;/** * Date: 9/13/16 * Author: qinjiangbo@github.io */public class MyBatisTest2 &#123; private SqlSession sqlSession = null; @Before public void init() &#123; String config = \"com/qinjiangbo/conf/configure.xml\"; InputStream inputStream = MyBatisTest2.class.getClassLoader().getResourceAsStream(config); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); sqlSession = sqlSessionFactory.openSession(); &#125; /** * BASED ON ANNOTATION AND XML */ // C @Test public void testCreateUser3() &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(580327, \"Xinxin\", \"123456\", 23, \"123abc@126.com\", \"13888899211\", \"Wuhan University\"); userMapper.createUser(user); &#125; @Test public void testDeleteUser3() &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); userMapper.deleteUser(580327); &#125; @Test public void testUpdateUser3() &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(580314, \"Handsome\", \"123456\", 23, \"123abc@126.com\", \"13888899211\", \"Wuhan University\"); userMapper.updateUser(user); &#125; @Test public void testRetrieveUser3() &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findUserById(580314); System.out.println(user); &#125; @After public void commit() &#123; sqlSession.commit(); &#125;&#125; 以上的相关代码是全部测试通过的，关于使用MyBatis对表执行CRUD操作的内容就这么多。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://qinjiangbo.com/tags/MyBatis/"},{"name":"实战","slug":"实战","permalink":"http://qinjiangbo.com/tags/实战/"}]},{"title":"MyBatis实战-1-开发环境搭建","slug":"mybatis-practice-development-env-build-1","date":"2016-09-13T13:05:23.000Z","updated":"2018-04-02T09:00:03.000Z","comments":true,"path":"mybatis-practice-development-env-build-1.html","link":"","permalink":"http://qinjiangbo.com/mybatis-practice-development-env-build-1.html","excerpt":"","text":"MyBatis简介MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 MyBatis快速上手开发环境准备说明，本系列教程所有的代码均是在Intellij Idea 16.02版本的IDE上编写的。 1.项目结构 2.添加依赖 mybatis-3.4.1.jar mysql-connector-java-6.0.3.jar hamcrest-core-1.3.jar junit-4.12.jar 查询数据库中的记录1.创建数据库和数据表 创建数据表 1234567891011121314151617SET NAMES utf8;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for `users`-- ----------------------------DROP TABLE IF EXISTS `users`;CREATE TABLE `users` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(45) NOT NULL, `pwd` varchar(45) NOT NULL, `age` int(11) NOT NULL , `email` varchar(45) NOT NULL , `tel` varchar(45) NOT NULL, `addr` varchar(45) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=580317 DEFAULT CHARSET=utf8; 向表中添加数据 12345INSERT INTO `users` VALUES('580314', 'Richard', '123456', '21', '1105351276@qq.com', '13627341394', 'ISS'), ('580315', 'QinJiangbo', '123456', '22', '1105351276@qq.com', '13627341394', 'Hongshan Square'), ('580316', 'Oliver', 'whuiss', '22', '2456281765@qq.com', '13627341394', 'ISS'); 2.创建用户POJO类User.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.qinjiangbo.pojo;/** * Date: 9/13/16 * Author: qinjiangbo@github.io */public class User &#123; // 实体类的属性名称和数据库中的字段名称要一一对应起来 private long id; private String name; private String pwd; private int age; private String email; private String tel; private String addr; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getTel() &#123; return tel; &#125; public void setTel(String tel) &#123; this.tel = tel; &#125; public String getAddr() &#123; return addr; &#125; public void setAddr(String addr) &#123; this.addr = addr; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + \", age=\" + age + \", email='\" + email + '\\'' + \", tel='\" + tel + '\\'' + \", addr='\" + addr + '\\'' + '&#125;'; &#125;&#125; 3.添加MyBatis的配置文件configure.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"Richard\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- 注册Mapper映射XML文件 --&gt; &lt;mapper resource=\"com/qinjiangbo/dao/UserMapper.xml\"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; NOTE 上面是数据库相关的配置，各位读者可以根据自己的实际情况进行相应的配置。 4.编写Mapper映射XML文件 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.qinjiangbo.dao.UserMapper\"&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"com.qinjiangbo.pojo.User\"&gt; SELECT * FROM users WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; NOTE 编写了Mapper映射XML文件以后一定要向MyBatis配置文件注册这个Mapper文件，否则它没办法被识别！ 5.编写测试实例 1234567891011121314151617181920212223242526272829package com.qinjiangbo.test;import com.qinjiangbo.pojo.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.InputStream;/** * Date: 9/13/16 * Author: qinjiangbo@github.io */public class MyBatisTest1 &#123; @Test public void testFindUserById() &#123; // 注意这个地方,不少人会直接写configure.xml, 这样会一直取不到值,从而报空指针, // 需要写全这个资源的全路径 String config = \"com/qinjiangbo/conf/configure.xml\"; InputStream inputStream = MyBatisTest1.class.getClassLoader().getResourceAsStream(config); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = factory.openSession(); String statement = \"com.qinjiangbo.dao.UserMapper.findUserById\"; User user = sqlSession.selectOne(statement, 580314); System.out.println(user); &#125;&#125; 6.测试结果","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://qinjiangbo.com/tags/MyBatis/"},{"name":"实战","slug":"实战","permalink":"http://qinjiangbo.com/tags/实战/"}]},{"title":"（译）HTML编程风格指南","slug":"html-style-guide","date":"2016-09-10T15:43:29.000Z","updated":"2017-01-14T07:22:32.000Z","comments":true,"path":"html-style-guide.html","link":"","permalink":"http://qinjiangbo.com/html-style-guide.html","excerpt":"","text":"这个页面简单地说明了jQuery各个项目中HTML编程的风格。 静态检测使用grunt-html来检测错误以及潜在的问题。大多数jQuery的项目都有一个Grunt构建任务以用于静态检测所有的CSS文件： grunt htmllint。 空格通常来讲，jQuery的编程风格提倡代码具有一定的空格以提高代码的可读性。 使用tab键进行缩进。 不要直接使用html, body, script, 或者style等元素的子节点进行缩进。使用其他任意的东西缩进都可。 一个空行或者一行的最后不能有空格。 通过空格来分隔元素的各个属性。 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/style.css\"&gt; &lt;style&gt; body &#123; font-size: 100em; &#125; &lt;/style&gt; &lt;script src=\"/jquery.js\"&gt;&lt;/script&gt; &lt;script&gt; $( function() &#123; $( \"p\" ).text( $.fn.jquery ); &#125; ); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;p&gt;jQuery is awesome!&lt;p&gt;&lt;/section&gt; &lt;/body&gt;&lt;/html&gt; 格式化 永远使用最小化的，最小版本号的并且是小写的doctype。 永远指定这个页面写入的自然语言类型。 永远包含html, head, 以及 body这几个标签。 永远指定编码类型。大多数的网页使用的基本上都是UTF-8。这个编码类型越早指定越好，而且必须在这个网页文档的钱1024个字节内容前。 元素的名称和属性的名字永远使用小写。 属性的值永远加上引号。使用双引号而不是单引号。 包含可选择的结束标签。 自闭合的元素不需要加上结束标签。 选择性的属性应该被省略掉。 rel, type, src, href 以及 class等属性必须在其它任何元素前声明。 永远为一个图片元素加上一个alt属性。 123456789101112131415&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Good Example&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt; &lt;script src=\"/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img class=\"sample-image\" src=\"assets/img/img.png\" alt=\"Sample Image\"&gt;&lt;p&gt;This is a sample image&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; HTML语义永远恰当地使用HTML元素。 减少封装永远需要避免多余的父元素结点。 1234567&lt;!-- Bad HTML --&gt;&lt;span class=\"avatar\"&gt; &lt;img src=\"assets/img/img.png\" alt=\"Jane Doe\"&gt;&lt;/span&gt; &lt;!-- Good HTML --&gt;&lt;img class=\"avatar\" src=\"assets/img/img.png\" alt=\"Jane Doe\"&gt; 注意分隔永远保持标记，样式文件和脚本文件独立成行分隔。 123456789101112131415161718192021222324252627282930&lt;!-- Bad Example --&gt;&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;script src=\"script.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 style=\"font-size:1em;line-height:2em;\"&gt;This is a heading.&lt;/h1&gt;&lt;p style=\"text-decoration:underline;font-size:.5em;line-height:1em;\"&gt;This is an underlined paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; &lt;!-- Good Example --&gt;&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt; &lt;script src=\"script.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;This is a heading.&lt;/h1&gt;&lt;p&gt;This is an underlined paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表单对于标记元素要加上一个for属性。在跨浏览器和及其先关辅助技术中这个比隐式地指定标记的对象更加健壮。 123456&lt;!-- Bad Example --&gt;&lt;label&gt;&lt;input type=\"radio\" name=\"input\" value=\"first\"&gt; First&lt;/label&gt; &lt;!-- Good Example --&gt;&lt;input type=\"radio\" name=\"input\" id=\"input-1\" value=\"first\"&gt;&lt;label for=\"input-1\"&gt;First&lt;/label&gt; 对于标记不要使用placeholder属性。切记使用label元素。 123456&lt;!-- Bad Example --&gt;&lt;input type=\"text\" id=\"name\" placeholder=\"Enter your name\"&gt; &lt;!-- Good Example --&gt;&lt;label for=\"name\"&gt;Name&lt;/label&gt;&lt;input id=\"name\" type=\"text\" placeholder=\"Jane Doe\"&gt; 注释注释永远紧跟着一个空白行。在注释文本和注释开始标志之间总是需要隔着一个空格。 当使用多行注释的时候，需要在每一行的开头使用&lt;!--。每一行的注释文本和这个--&gt;之间必须保持一个空格。 123456&lt;!-- Good single line comment --&gt; &lt;!--Good example of a multi-line comment.If your comment takes up multiple lines, please do this.--&gt; 译文原文地址：http://contribute.jquery.org/style-guide/html/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"前端","slug":"开发技术/前端","permalink":"http://qinjiangbo.com/categories/开发技术/前端/"}],"tags":[{"name":"code style","slug":"code-style","permalink":"http://qinjiangbo.com/tags/code-style/"},{"name":"HTML","slug":"HTML","permalink":"http://qinjiangbo.com/tags/HTML/"}]},{"title":"（译）CSS编程风格指南","slug":"css-style-guide","date":"2016-08-29T15:43:42.000Z","updated":"2017-01-14T07:22:09.000Z","comments":true,"path":"css-style-guide.html","link":"","permalink":"http://qinjiangbo.com/css-style-guide.html","excerpt":"","text":"这个页面简单地说明了jQuery各个项目中CSS编程的风格。 静态检测使用CSSLint来检测错误以及潜在的问题。大多数jQuery的项目都有一个Grunt构建任务以用于静态检测所有的CSS文件： grunt csslint。关于CSSLint的配置项保存在.csslintrc文件中。 每一个.csslintrc文件都遵循一个特定的格式。所有的配置项都必须按字母排序并且分好组： 1234567&#123; \"common1\": true, \"common2\": true, \"repo-specific1\": true, \"repo-specific2\": true&#125; 下面是所有使用css的项目一定会使用的通用配置项： 123456789101112&#123; \"adjoining-classes\": false, \"box-model\": false, \"box-sizing\": false, \"compatible-vendor-prefixes\": false, \"duplicate-background-images\": false, \"import\": false, \"important\": true, \"outline-none\": false, \"overqualified-elements\": false, \"text-indent\": false&#125; 空格通常来讲，jQuery的编程风格提倡代码具有一定的空格以提高代码的可读性。代码的最小化处理主要是为了使浏览器更加容易读取和处理而优化的。 使用tab键进行缩进。 一个空行或者一行的最后不能有空格。 在声明变量后，在变量后面的分号后面加上一个空格，但是注意一定不能在空格前面加上分号。 在声明规则的时候放置一个空格在{号前面。 规则声明完以后将结束括号放置在新的一行。 在相邻两个规则中间插入一个空白行以保证代码的可读性。 当有多个选择器共用同一个规则时候，采用逗号隔开，并且每个选择器单独起一行。 唯一需要缩进选择器的时候就是在嵌套的规则里面，比如说媒体查询(media queries)。 CSS规则的属性应该只使用一个tab键进行缩进。 URL中括号“（）”里面没有空白。 1234567891011121314151617181920212223242526272829/* Bad CSS */ .bad-spacing,.bad-example&#123;color:#222222;background:url( \"../bad.png\" );&#125; .bad-spacing&#123;font-style:italic&#125; @media only all&#123; .media-example&#123;font-weight:strong;&#125; &#125; /* Good CSS */.good-spacing,.good-example &#123; color: #222; background: url(\"../good.png\");&#125; .good-spacing &#123; font-style: italic;&#125; @media only all &#123; .media-example &#123; font-weight: strong; &#125;&#125; 格式化 使用十六进制颜色代码(#5c8fb3) 而不是使用 rgba()。 可能的话，使用十六进制值简写。 当使用十六进制值的时候采用小写字母。 使用em而不是px，除非避免不了了。 不要为0指定单位。 避免使用超过三个选择器长度的级联选择器。 避免不必要的级联选择器。 可能的话使用属性的简写。 避免使用像padding-left: 10px; padding-right: 10px; padding-top: 20px; padding-bottom: 5px;这样的表达，可以写成使用这种padding: 20px 10px 5px 10px;。但是如果你只是改变了左边距，其实更适合使用padding-left这个属性。 不要在十进制值前面加上多余的0。 使用双引号而不是单引号。 永远记住在每一个申明后面加上一个分号。 除非必用不可，否则尽量少使用!important。 1234567891011/* 好的CSS示例*/.good-table thead th &#123; color: #fff; background: #ffc0cb url(\"../images/polka-dots.png\"); font-size: 1em; padding: .5em 0;&#125; .good-table thead th.selected &#123; padding-left: 1em;&#125; 导入 不要在已发布的文件里面使用@import。因为这个更慢，他需要加载外部的文件进入这个CSS文件，而且还可能导致一些隐藏的问题。 不要在一个单独的CSS文件里面使用超过31个@imports， 否则它会使IE崩掉。 不要嵌套使用@imports，因为你无法保证他们实际的加载顺序。 注释注释永远紧跟着一个空白行。在注释文本和注释开始标志之间总是需要隔着一个空格。 当使用多行注释的时候，需要在每一行的开头使用*。每一行的注释文本和这个*之间必须保持一个空格。 123456/* 好的单行注释示例 */ /** 好的多行注释示例* 如果你需要使用多行注释，请这么做！*/ 类名 类名应该全部使用小写。 类名各个单词之间应该使用横杆-连接。 避免过度或者任意地使用类名的缩写。比如.ui-button一看就知道是用来作用于按钮，而.b没有任何意义。 选择器的使用上尽量多使用类，而不是编号ID。 123456789101112/* 坏的例子 */.uiButton,.ui_button,#uiButton,.b &#123; &#125; /* 好的例子 */.ui-button &#123; &#125; 译文原文地址：http://contribute.jquery.org/style-guide/css/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"前端","slug":"开发技术/前端","permalink":"http://qinjiangbo.com/categories/开发技术/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://qinjiangbo.com/tags/CSS/"},{"name":"code style","slug":"code-style","permalink":"http://qinjiangbo.com/tags/code-style/"}]},{"title":"（译）JavaScript编程风格指南","slug":"javascript-style-guide","date":"2016-08-29T15:43:13.000Z","updated":"2017-01-14T07:22:42.000Z","comments":true,"path":"javascript-style-guide.html","link":"","permalink":"http://qinjiangbo.com/javascript-style-guide.html","excerpt":"","text":"静态检测使用JSHint来检测错误以及潜在的问题。大多数jQuery的项目都有一个Grunt构建任务以用于静态检测所有的CSS文件： grunt jslint。关于CSSLint的配置项保存在.jslintrc文件中。 每一个.jslintrc文件都遵循一个特定的格式。所有的配置项都必须按字母排序并且分好组： 123456789101112&#123; \"common1\": true, \"common2\": true, \"repoSpecific1\": true, \"repoSpecific2\": true, \"globals\": &#123; \"repoGlobal1\": true, \"repoGlobal2\": false &#125;&#125; 下面是所有使用javascript的项目一定会使用的通用配置项： 1234567891011121314&#123; \"boss\": true, \"curly\": true, \"eqeqeq\": true, \"eqnull\": true, \"expr\": true, \"immed\": true, \"noarg\": true, \"quotmark\": \"double\", \"smarttabs\": true, \"trailing\": true, \"undef\": true, \"unused\": true&#125; 如果这个项目支持一个没有实现ES5标准的浏览器，则es3这个选项必须在repo-specific选项中被指定 空格通常来讲，jQuery的编程风格提倡代码具有一定的空格以提高代码的可读性。代码的最小化处理主要是为了使浏览器更加容易读取和处理而优化的。 使用tab键来缩进。 一个空行或者一行的最后不能有空格。 每一行最好不要超过80个字符的长度，并且一定不能超过100个字符的长度（一个tab键认定为4个空格）。有两个特殊情况，每个都允许某一行超过100个字符的长度： 如果这一行包括了一个拥有很长URL的注释。 如果这一行包括了一个正则表达式。这个时候正则表达式不得不使用正则表达式的构造器，需要的话还需要加上其它特殊字符转义字符。 if/else/for/while/try 永远要有括号包裹着并且永远保持多行。 一元特殊字符的操作符（比如 !, ++）后面必须要紧跟着一个空格。 任何,和;前面不能有空格。 任何被用作一个声明语句的终止符的;都需要在行尾。 一个对象中的任何属性名称前面的冒号:前面都不需要加上空格。 在三元表达式中?和:前后都必须加上空格。 在空的构造函数内部不能加上空格。（比如{}, [], `fn()） 每个文件末尾都需要加上新的一行。 如果整个文件都是在一个闭包里面，那么这个函数体是不需要缩进的。 坏的示例1234// Badif(condition) doSomething();while(!condition) iterating++;for(var i=0;i&lt;100;i++) object[array[i]] = someFn(i); 好的示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var i = 0; if ( condition ) &#123; doSomething();&#125; else if ( otherCondition ) &#123; somethingElse();&#125; else &#123; otherThing();&#125; while ( !condition ) &#123; iterating++;&#125; for ( ; i &lt; 100; i++ ) &#123; object[ array[ i ] ] = someFn( i );&#125; try &#123; // Expressions&#125; catch ( e ) &#123; // Expressions&#125; array = [ \"*\" ]; array = [ a, b ]; foo( arg ); foo( options, object[ property ] ); foo( [ a, b ], \"property\", &#123; c: d &#125; ); foo( &#123; a: \"alpha\", b: \"beta\" &#125; ); foo( [ a, b ] ); foo( &#123; a: \"alpha\", b: \"beta\"&#125; ); foo( function() &#123; // Do stuff&#125;, options ); foo( data, function() &#123; // Do stuff&#125; ); 对象和数组表达式如果对象和数组表达式很短，它们是可以占用一行而不是多行的（同时也记住这个每一行长度的限制）。当一个表达式太长以致于没法适应一行的时候，则每一行必须要有一个属性或者元素，在对应的行里面使用开闭括号将它们包裹起来。只有当属性的名字是关键字的时候才需要将其加上引号: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Badmap = &#123; ready: 9, when: 4, \"you are\": 15 &#125;; array = [ 9, 4, 15 ]; array = [ &#123; key: val&#125; ]; array = [ &#123; key: val&#125;, &#123; key2: val2&#125; ]; // Goodmap = &#123; ready: 9, when: 4, \"you are\": 15 &#125;; array = [ 9, 4, 15 ]; array = [ &#123; key: val &#125; ]; array = [ &#123; key: val &#125;, &#123; key2: val2 &#125; ]; array = [ &#123; key: val &#125;, &#123; key2: val2 &#125;]; // Good as wellmap = &#123; ready: 9, when: 4, \"you are\": 15&#125;; array = [ 9, 4, 15]; array = [ &#123; key: val &#125;]; array = [ &#123; key: val &#125;, &#123; key2: val2 &#125;]; 多行声明语句当一个声明语句太长以致于无法单独在一行显示的时候，换行符必须在操作符后面出现。 1234567// Badvar html = \"&lt;p&gt;The sum of \" + a + \" and \" + b + \" plus \" + c + \" is \" + ( a + b + c ); // Goodvar html = \"&lt;p&gt;The sum of \" + a + \" and \" + b + \" plus \" + c + \" is \" + ( a + b + c ); 每一行都需要根据一定的逻辑分配到某一组，比如说讲一个三元表达式的各个成分分开到单独一行可以这么做： 123var baz = firstCondition( foo ) &amp;&amp; secondCondition( bar ) ? qux( foo, bar ) : foo; 当一个判断条件语句太长以致于不能适应某一行的时候，后续的行必须多加上一个缩进以便于区分语句体和这个判断条件语句。 1234if ( firstCondition() &amp;&amp; secondCondition() &amp;&amp; thirdCondition() ) &#123; doStuff();&#125; 链式方法调用当一个方法调用链太长的时候，必须保持每一行一个调用，并且第一个调用方法和这个调用的对象在单独一行。当方法改变了上下文的时候，必须使用不同等级的缩进以区分。 123456elements .addClass( \"foo\" ) .children() .html( \"hello\" ) .end() .appendTo( \"body\" ); 全文件闭包当整个文件被包裹在一个闭包里面的时候，这个闭包体是不需要使用缩进的。 12345( function( $ ) &#123; // This doesn't get indented &#125; )( jQuery ); 12345module.exports = function( grunt ) &#123; // This doesn't get indented &#125;; 这同样也适用于AMD包裹器： 123456789define( [ \"foo\", \"bar\", \"baz\"], function( foo, bar, baz ) &#123; // This doesn't get indented &#125; ); 对于UMD，这个工厂（factory）使用缩进就是用来在视觉上区分它和这个闭包体。 1234567891011121314151617( function( factory ) &#123; if ( typeof define === \"function\" &amp;&amp; define.amd ) &#123; // AMD. Register as an anonymous module. define( [ \"jquery\" ], factory ); &#125; else &#123; // Browser globals factory( jQuery ); &#125;&#125;( function( $ ) &#123; // This doesn't get indented &#125; ) ); 构造函数构造函数永远都需要带参调用，即使参数为空。 12throw new Error();when = time || new Date(); 当一个属性或者方法立马被一个刚声明好的构造函数调用时，注意显式地加上括号。 12detachedMode = ( new TemplateFactory( settings ) ).nodeType === 11;match = ( new RegExp( pattern ) ).exec( input ); 相等性严格的相等性检查（===）必须优于抽象的相等性检查（==）。唯一的异常就是检查一个undefined对象或者是一个空对象。== null的使用在只有出现逻辑上的为空或者undefined空对象时，比如未初始化的变量。 12// Check for both undefined and null values, for some important reason.undefOrNull == null; 类型检查 String: typeof object === “string” Number: typeof object === “number” Boolean: typeof object === “boolean” Object: typeof object === “object” Plain Object: jQuery.isPlainObject( object ) Function: jQuery.isFunction( object ) Array: jQuery.isArray( object ) Element: object.nodeType null: object === null null or undefined: object == null undefined: Global Variables: typeof variable === “undefined” Local Variables: variable === undefined Properties: object.prop === undefined 注释注释永远紧跟着一个空白行。注释的第一个首字母应该大写，如果是中文就没这个要求。但是不需要你在一行就将这句话写完，可以分多行写。在这个注释符号和注释文本之间必须要加上一个空格。 单行注释通常加在它们所注释的代码上面一行： 123456// We need an explicit \"bar\", because later in the code foo is checked.var foo = \"bar\"; // Even long comments that span// multiple lines use the single// line comment form. 多行注释仅仅被用作文件的注释和函数声明开头的注释。 作为一种特殊情况，当需要注释某个参数或者需要支持一个特定的开发工具的时候内联注释是被允许的。 1234function foo( types, selector, data, fn, /* INTERNAL */ one ) &#123; // Do stuff&#125; 不要在注释中写API文档。API文档应该单独的生成一份。（译者：貌似这点Java不太赞同） 引号jQuery支持双引号。 1var double = \"I am wrapped in double quotes\"; 字符串中如果想使用内联的引号必须是外面双引号里面单引号。 1var html = \"&lt;div id='my-id'&gt;&lt;/div&gt;\"; 分号使用它们，决不依赖ASI。 命名传统变量和函数的命名应该是全名称的，采用驼峰命名法，出第一个单词小写外，其它每个单词都大写。名字应该是能够描述这个变量和函数的用途的。迭代的变量除外，因为迭代器的i没意义。 全局变量每个项目推荐最多只能暴露一个全局变量。 DOM结点规则.nodeName 永远优于 .tagName使用。 .nodeType 应该被用来指定结点的类型 (而不是 .nodeName)。 Switch语句switch语句的用法通常来讲是不提倡的。但是在分类情形很多的时候还是很有帮助的。特别是当多个情况可以被一个代码块处理的时候，或者是设定整体的默认的逻辑default。 当使用switch语句的时候： 除了default情况，其它每一个情况都需要使用break。 每个case语句都需要和switch对齐。 1234567891011switch ( event.keyCode ) &#123;case $.ui.keyCode.ENTER:case $.ui.keyCode.SPACE: x(); break;case $.ui.keyCode.ESCAPE: y(); break;default: z();&#125; 译文原文地址：http://contribute.jquery.org/style-guide/js/","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"前端","slug":"开发技术/前端","permalink":"http://qinjiangbo.com/categories/开发技术/前端/"}],"tags":[{"name":"code style","slug":"code-style","permalink":"http://qinjiangbo.com/tags/code-style/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://qinjiangbo.com/tags/JavaScript/"}]},{"title":"Prose Style Guide","slug":"prose-style-guide","date":"2016-08-29T15:24:22.000Z","updated":"2016-10-28T16:13:38.000Z","comments":true,"path":"prose-style-guide.html","link":"","permalink":"http://qinjiangbo.com/prose-style-guide.html","excerpt":"","text":"Formatting ConventionsOn many sites, prose (sites, README, docs, etc) is authored with GitHub Flavored Markdown. Some sites (e.g. api.jquery.com) use an XML-based markup system but the advice offered here for good writing still applies. Writing StyleContent should be educational and accessible to a broad audience of developers. The primary target audience is beginning to intermediate jQuery users, with advanced jQuery users as a secondary audience. When creating content, please keep one of these audiences in mind as well as the following style guidelines: Grammar Use the Oxford comma in a list of three or more items: Yes: The load, scroll, and error events (e.g. on an &lt;img&gt; element) do not bubble. No: The load, scroll and error events (e.g. on an &lt;img&gt; element) do not bubble. Numbers: Spell out numbers below 10 (e.g. one, two, three). Use numerals for numbers 10 and above (e.g. 10, 20, 100). Abbreviations: Spell out abbreviated words on first reference, followed by the abbreviation in parentheses. Use - abbreviations on second reference. Code Within Prose Always use a code tag to denote code from prose. Properties: use a dot, followed by the property name, e.g. .length. Functions: use the function name, followed by parentheses, e.g. myfunction(). Methods: use a dot, followed by the method name, followed by parentheses, e.g. The .focus() method is a - shortcut for .bind( “focus”, handler ) in the first and second variations, and .trigger( “focus” ) in the third. Article &amp; Sentence Structure Use headings to break up content into easier-to-read sections. Begin headings within an article with &lt;h2&gt;. Keep sentences short and to the point. A good rule-of-thumb is to break up any sentence longer than 21 words into two or more seperate thoughts. Lists: Use bulleted lists when necessary to share a series of five or more points. Use numbered lists only when providing step-by-step instruction – note that this should be avoided. Use a period at the end of each ordered list item, and a period or comma at the end of an unordered list item. Spelling Use standard American English spelling. Capitalization: Capitalize all proper nouns. Do not capitalize HTML elements in code examples. Capitalize all words in a heading or sub-heading with the exception of article adjectives and the prepositions like “with,” “of,” or “to.” Capitalize the first word in a list. Punctuation: Periods and commas go inside quotation marks. Avoid using semicolons. Pronoun Usage Don’t use “I,” “me,” “us,” “our,” “we,” or gender-specific pronouns such as “him” or “she.” Use the second-person pronoun “you” when addressing the reader, and the definite article “the” when addressing code or content: “You will be able to foo bar after you bar the foo.” “Insert the paragraph after the unordered list.” Voice &amp; Tone Do write in clear, easy-to-understand statements and in active voice. Do keep the audience in mind while writing. Do write conversationally. Do write in the second person to address the reader. Do use the imperative mood. Do use humor strategically. When in doubt, err on the side of formality. Do use hyperlinks to refer readers to concepts or topics that have been covered in other sections. Do attribute others. Don’t assume the reader will have prior knowledge of topics or concepts, especially when targeting beginner or intermediate audiences. Don’t use rhetorical questions. Don’t write in first or third person. Linking &amp; Referencing Content Link to relevant content within the learn.jquery.com site to refer readers to previously covered topics or concepts. Link to the jQuery blog or API documentation when necessary. Use inline hyperlinks to reference relevant content. Acceptable external resources: Mozilla Developer Network Webplatform.org htmldog.com html5doctor.com Code Examples Use examples to illustrate important concepts. Examples should indicate what the expected result will be in comments before code is presented. Break long examples up into shorter sections to aid comprehension. Favor “Right Way” examples over “Wrong Way” examples – there is more than one wrong way to do something, after all. Use good comments so that explanation within prose isn’t necessary. Test your code examples before submitting. Follow all style guides for your code examples.","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"编程经验","slug":"经验感悟/编程经验","permalink":"http://qinjiangbo.com/categories/经验感悟/编程经验/"}],"tags":[{"name":"code style","slug":"code-style","permalink":"http://qinjiangbo.com/tags/code-style/"},{"name":"clean code","slug":"clean-code","permalink":"http://qinjiangbo.com/tags/clean-code/"}]},{"title":"MyBatis框架-8-日志Logging","slug":"mybatis-framework-logging-8","date":"2016-08-28T04:04:10.000Z","updated":"2018-04-02T09:01:11.000Z","comments":true,"path":"mybatis-framework-logging-8.html","link":"","permalink":"http://qinjiangbo.com/mybatis-framework-logging-8.html","excerpt":"","text":"LoggingMybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具： SLF4J Apache Commons Logging Log4j 2 Log4j JDK logging 具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。 如果一个都未找到，日志功能就会被禁用。 不少应用服务器的classpath中已经包含Commons Logging，如Tomcat和WebShpere， 所以MyBatis会把它作为具体的日志实现。记住这点非常重要。这将意味着，在诸如 WebSphere的环境中——WebSphere提供了Commons Logging的私有实现，你的Log4J配置将被忽略。 这种做法不免让人悲催，MyBatis怎么能忽略你的配置呢？事实上，因Commons Logging已经存 在了，按照优先级顺序，Log4J自然就被忽略了！不过，如果你的应用部署在一个包含Commons Logging的环境， 而你又想用其他的日志框架，你可以根据需要调用如下的某一方法： 12345org.apache.ibatis.logging.LogFactory.useSlf4jLogging();org.apache.ibatis.logging.LogFactory.useLog4JLogging();org.apache.ibatis.logging.LogFactory.useJdkLogging();org.apache.ibatis.logging.LogFactory.useCommonsLogging();org.apache.ibatis.logging.LogFactory.useStdOutLogging(); 如果的确需要调用以上的某个方法，请在其他所有MyBatis方法之前调用它。另外，只有在相应日志实现中存在 的前提下，调用对应的方法才是有意义的，否则MyBatis一概忽略。如你环境中并不存在Log4J，你却调用了 相应的方法，MyBatis就会忽略这一调用，代之默认的查找顺序查找日志实现。 关于SLF4J、Apache Commons Logging、Apache Log4J和JDK Logging的API介绍已经超出本文档的范围。 不过，下面的例子可以作为一个快速入门。关于这些日志框架的更多信息，可以参考以下链接： Apache Commons Logging Apache Log4j JDK Logging API Logging ConfigurationMyBatis可以对包、类、命名空间和全限定的语句记录日志。 具体怎么做，视使用的日志框架而定，这里以Log4J为例。配置日志功能非常简单：添加几个配置文件， 如log4j.properties,再添加个jar包，如log4j.jar。下面是具体的例子，共两个步骤： 步骤1： 添加 Log4J 的 jar 包因为采用Log4J，要确保在应用中对应的jar包是可用的。要满足这一点，只要将jar包添加到应用的classpath中即可。 Log4J的jar包可以从上面的链接中下载。 具体而言，对于web或企业应用，需要将log4j.jar 添加到WEB-INF/lib 目录； 对于独立应用， 可以将它添加到jvm 的 -classpath启动参数中。 步骤2：配置Log4J配置Log4J比较简单， 比如需要记录这个mapper接口的日志: 12345package org.mybatis.example;public interface BlogMapper &#123; @Select(\"SELECT * FROM blog WHERE id = #&#123;id&#125;\") Blog selectBlog(int id);&#125; 只要在应用的classpath中创建一个名称为log4j.properties的文件， 文件的具体内容如下： 12345678# Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...log4j.logger.org.mybatis.example.BlogMapper=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 添加以上配置后，Log4J就会把 org.mybatis.example.BlogMapper 的详细执行日志记录下来，对于应用中的其它类则仅仅记录错误信息。 也可以将日志从整个mapper接口级别调整到到语句级别，从而实现更细粒度的控制。如下配置只记录 selectBlog 语句的日志： 1log4j.logger.org.mybatis.example.BlogMapper.selectBlog=TRACE 与此相对，可以对一组mapper接口记录日志，只要对mapper接口所在的包开启日志功能即可： 1log4j.logger.org.mybatis.example=TRACE 某些查询可能会返回大量的数据，只想记录其执行的SQL语句该怎么办？为此，Mybatis中SQL语 句的日志级别被设为DEBUG（JDK Logging中为FINE），结果日志的级别为TRACE（JDK Logging中为FINER)。所以，只要将日志级别调整为DEBUG即可达到目的： 1log4j.logger.org.mybatis.example=DEBUG 要记录日志的是类似下面的mapper文件而不是mapper接口又该怎么呢？ 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.mybatis.example.BlogMapper\"&gt; &lt;select id=\"selectBlog\" resultType=\"Blog\"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 对这个文件记录日志，只要对命名空间增加日志记录功能即可： 1log4j.logger.org.mybatis.example.BlogMapper=TRACE 进一步，要记录具体语句的日志可以这样做： 1log4j.logger.org.mybatis.example.BlogMapper.selectBlog=TRACE 看到了吧，两种配置没差别！ 配置文件log4j.properties的余下内容是针对日志格式的，这一内容已经超出本 文档范围。关于Log4J的更多内容，可以参考Log4J的网站。不过，可以简单试一下看看，不同的配置 会产生什么不一样的效果。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://qinjiangbo.com/tags/mybatis/"},{"name":"ibatis","slug":"ibatis","permalink":"http://qinjiangbo.com/tags/ibatis/"}]},{"title":"MyBatis框架-7-SQL语句构建器类","slug":"mybatis-framework-sql-builder-7","date":"2016-08-28T03:44:17.000Z","updated":"2018-04-02T09:00:52.000Z","comments":true,"path":"mybatis-framework-sql-builder-7.html","link":"","permalink":"http://qinjiangbo.com/mybatis-framework-sql-builder-7.html","excerpt":"","text":"SQL语句构建器类问题Java程序员面对的最痛苦的事情之一就是在Java代码中嵌入SQL语句。这么来做通常是由于SQL语句需要动态来生成-否则可以将它们放到外部文件或者存储过程中。正如你已经看到的那样，MyBatis在它的XML映射特性中有一个强大的动态SQL生成方案。但有时在Java代码内部创建SQL语句也是必要的。此时，MyBatis有另外一个特性可以帮到你，在减少典型的加号,引号,新行,格式化问题和嵌入条件来处理多余的逗号或 AND 连接词之前。事实上，在Java代码中来动态生成SQL代码就是一场噩梦。例如： 1234567891011String sql = \"SELECT P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME, \"\"P.LAST_NAME,P.CREATED_ON, P.UPDATED_ON \" +\"FROM PERSON P, ACCOUNT A \" +\"INNER JOIN DEPARTMENT D on D.ID = P.DEPARTMENT_ID \" +\"INNER JOIN COMPANY C on D.COMPANY_ID = C.ID \" +\"WHERE (P.ID = A.ID AND P.FIRST_NAME like ?) \" +\"OR (P.LAST_NAME like ?) \" +\"GROUP BY P.ID \" +\"HAVING (P.LAST_NAME like ?) \" +\"OR (P.FIRST_NAME like ?) \" +\"ORDER BY P.ID, P.FULL_NAME\"; The SolutionMyBatis 3提供了方便的工具类来帮助解决该问题。使用SQL类，简单地创建一个实例来调用方法生成SQL语句。上面示例中的问题就像重写SQL类那样： 1234567891011121314151617181920private String selectPersonSql() &#123; return new SQL() &#123;&#123; SELECT(\"P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME\"); SELECT(\"P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON\"); FROM(\"PERSON P\"); FROM(\"ACCOUNT A\"); INNER_JOIN(\"DEPARTMENT D on D.ID = P.DEPARTMENT_ID\"); INNER_JOIN(\"COMPANY C on D.COMPANY_ID = C.ID\"); WHERE(\"P.ID = A.ID\"); WHERE(\"P.FIRST_NAME like ?\"); OR(); WHERE(\"P.LAST_NAME like ?\"); GROUP_BY(\"P.ID\"); HAVING(\"P.LAST_NAME like ?\"); OR(); HAVING(\"P.FIRST_NAME like ?\"); ORDER_BY(\"P.ID\"); ORDER_BY(\"P.FULL_NAME\"); &#125;&#125;.toString();&#125; 该例中有什么特殊之处？当你仔细看时，那不用担心偶然间重复出现的”AND”关键字，或者在”WHERE”和”AND”之间的选择，抑或什么都不选。该SQL类非常注意”WHERE”应该出现在何处，哪里又应该使用”AND”，还有所有的字符串链接。 SQL类这里给出一些示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Anonymous inner classpublic String deletePersonSql() &#123; return new SQL() &#123;&#123; DELETE_FROM(\"PERSON\"); WHERE(\"ID = $&#123;id&#125;\"); &#125;&#125;.toString();&#125;// Builder / Fluent stylepublic String insertPersonSql() &#123; String sql = new SQL() .INSERT_INTO(\"PERSON\") .VALUES(\"ID, FIRST_NAME\", \"$&#123;id&#125;, $&#123;firstName&#125;\") .VALUES(\"LAST_NAME\", \"$&#123;lastName&#125;\") .toString(); return sql;&#125;// With conditionals (note the final parameters, required for the anonymous inner class to access them)public String selectPersonLike(final String id, final String firstName, final String lastName) &#123; return new SQL() &#123;&#123; SELECT(\"P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME\"); FROM(\"PERSON P\"); if (id != null) &#123; WHERE(\"P.ID like $&#123;id&#125;\"); &#125; if (firstName != null) &#123; WHERE(\"P.FIRST_NAME like $&#123;firstName&#125;\"); &#125; if (lastName != null) &#123; WHERE(\"P.LAST_NAME like $&#123;lastName&#125;\"); &#125; ORDER_BY(\"P.LAST_NAME\"); &#125;&#125;.toString();&#125;public String deletePersonSql() &#123; return new SQL() &#123;&#123; DELETE_FROM(\"PERSON\"); WHERE(\"ID = $&#123;id&#125;\"); &#125;&#125;.toString();&#125;public String insertPersonSql() &#123; return new SQL() &#123;&#123; INSERT_INTO(\"PERSON\"); VALUES(\"ID, FIRST_NAME\", \"$&#123;id&#125;, $&#123;firstName&#125;\"); VALUES(\"LAST_NAME\", \"$&#123;lastName&#125;\"); &#125;&#125;.toString();&#125;public String updatePersonSql() &#123; return new SQL() &#123;&#123; UPDATE(\"PERSON\"); SET(\"FIRST_NAME = $&#123;firstName&#125;\"); WHERE(\"ID = $&#123;id&#125;\"); &#125;&#125;.toString();&#125; 方法 描述 SELECT(String) 开始或插入到 SELECT子句。 可以被多次调用，参数也会添加到 SELECT子句。 参数通常使用逗号分隔的列名和别名列表，但也可以是数据库驱动程序接受的任意类型。 SELECT_DISTINCT(String) 开始或插入到 SELECT子句， 也可以插入 DISTINCT关键字到生成的查询语句中。 可以被多次调用，参数也会添加到 SELECT子句。 参数通常使用逗号分隔的列名和别名列表，但也可以是数据库驱动程序接受的任意类型。 FROM(String) 开始或插入到 FROM子句。 可以被多次调用，参数也会添加到 FROM子句。 参数通常是表名或别名，也可以是数据库驱动程序接受的任意类型。 `JOIN(String) ` `INNER_JOIN(String)` `LEFT_OUTER_JOIN(String)` `RIGHT_OUTER_JOIN(String)` 基于调用的方法，添加新的合适类型的 JOIN子句。 参数可以包含由列命和join on条件组合成标准的join。 WHERE(String) 插入新的 WHERE子句条件， 由AND链接。可以多次被调用，每次都由AND来链接新条件。使用 OR() 来分隔OR。 OR() 使用OR来分隔当前的 WHERE子句条件。 可以被多次调用，但在一行中多次调用或生成不稳定的SQL。 AND() 使用AND来分隔当前的 WHERE子句条件。 可以被多次调用，但在一行中多次调用或生成不稳定的SQL。因为WHERE 和 HAVING 二者都会自动链接 AND, 这是非常罕见的方法，只是为了完整性才被使用。 GROUP_BY(String) 插入新的 GROUP BY子句元素，由逗号连接。 可以被多次调用，每次都由逗号连接新的条件。 HAVING(String) 插入新的 HAVING子句条件。 由AND连接。可以被多次调用，每次都由AND来连接新的条件。使用 OR() 来分隔OR. ORDER_BY(String) 插入新的 ORDER BY子句元素， 由逗号连接。可以多次被调用，每次由逗号连接新的条件。 DELETE_FROM(String) 开始一个delete语句并指定需要从哪个表删除的表名。通常它后面都会跟着WHERE语句！ INSERT_INTO(String) 开始一个insert语句并指定需要插入数据的表名。后面都会跟着一个或者多个VALUES()。 SET(String) 针对update语句，插入到”set”列表中 UPDATE(String) 开始一个update语句并指定需要更新的表明。后面都会跟着一个或者多个SET()，通常也会有一个WHERE()。 VALUES(String, String) 插入到insert语句中。第一个参数是要插入的列名，第二个参数则是该列的值。 SqlBuilder 和 SelectBuilder (已经废弃)在3.2版本之前，我们使用了一点不同的做法，通过实现ThreadLocal变量来掩盖一些导致Java DSL麻烦的语言限制。但这种方式已经废弃了，现代的框架都欢迎人们使用构建器类型和匿名内部类的想法。因此，SelectBuilder 和 SqlBuilder 类都被废弃了。 下面的方法仅仅适用于废弃的SqlBuilder 和 SelectBuilder 类。 方法 描述 BEGIN() /RESET() 这些方法清空SelectBuilder类的ThreadLocal状态，并且准备一个新的构建语句。开始新的语句时， BEGIN()读取得最好。 由于一些原因（在某些条件下，也许是逻辑需要一个完全不同的语句），在执行中清理语句 RESET()读取得最好。 SQL() 返回生成的 SQL() 并重置 SelectBuilder 状态 (好像 BEGIN() 或 RESET()被调用了). 因此，该方法只能被调用一次！ SelectBuilder 和 SqlBuilder 类并不神奇，但是知道它们如何工作也是很重要的。 SelectBuilder 使用 SqlBuilder 使用了静态导入和ThreadLocal变量的组合来开启整洁语法，可以很容易地和条件交错。使用它们，静态导入类的方法即可，就像这样(一个或其它，并非两者): 1import static org.apache.ibatis.jdbc.SelectBuilder.*; 1import static org.apache.ibatis.jdbc.SqlBuilder.*; 这就允许像下面这样来创建方法： 1234567/* DEPRECATED */public String selectBlogsSql() &#123; BEGIN(); // Clears ThreadLocal variable SELECT(\"*\"); FROM(\"BLOG\"); return SQL();&#125; 123456789101112131415161718192021/* DEPRECATED */private String selectPersonSql() &#123; BEGIN(); // Clears ThreadLocal variable SELECT(\"P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME\"); SELECT(\"P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON\"); FROM(\"PERSON P\"); FROM(\"ACCOUNT A\"); INNER_JOIN(\"DEPARTMENT D on D.ID = P.DEPARTMENT_ID\"); INNER_JOIN(\"COMPANY C on D.COMPANY_ID = C.ID\"); WHERE(\"P.ID = A.ID\"); WHERE(\"P.FIRST_NAME like ?\"); OR(); WHERE(\"P.LAST_NAME like ?\"); GROUP_BY(\"P.ID\"); HAVING(\"P.LAST_NAME like ?\"); OR(); HAVING(\"P.FIRST_NAME like ?\"); ORDER_BY(\"P.ID\"); ORDER_BY(\"P.FULL_NAME\"); return SQL();&#125;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://qinjiangbo.com/tags/mybatis/"},{"name":"ibatis","slug":"ibatis","permalink":"http://qinjiangbo.com/tags/ibatis/"}]},{"title":"MyBatis框架-6-Java API","slug":"mybatis-framework-java-api-6","date":"2016-08-28T02:47:42.000Z","updated":"2018-04-02T09:01:15.000Z","comments":true,"path":"mybatis-framework-java-api-6.html","link":"","permalink":"http://qinjiangbo.com/mybatis-framework-java-api-6.html","excerpt":"","text":"Java API既然你已经知道如何配置 MyBatis 和创建映射文件,你就已经准备好来提升技能了。 MyBatis 的 Java API 就是你收获你所做的努力的地方。正如你即将看到的,和 JDBC 相比, MyBatis 很大程度简化了你的代码而且保持简洁,很容易理解和维护。MyBatis 3 已经引入 了很多重要的改进来使得 SQL 映射更加优秀。 应用目录结构在我们深入 Java API 之前,理解关于目录结构的最佳实践是很重要的。MyBatis 非常灵 活, 你可以用你自己的文件来做几乎所有的事情。 但是对于任一框架, 都有一些最佳的方式。 让我们看一下典型应用的目录结构: /my_application /bin /devlib /lib &lt;-- MyBatis \\*.jar文件在这里。 /src /org/myapp/ /action /data &lt;-- MyBatis配置文件在这里, 包括映射器类, XML配置, XML映射文件。 /mybatis-config.xml /BlogMapper.java /BlogMapper.xml /model /service /view /properties &lt;-- 在你XML中配置的属性 文件在这里。 /test /org/myapp/ /action /data /model /service /view /properties /web /WEB-INF /web.xml Remember, these are preferences, not requirements, but others will thank you for using a common directory structure. 这部分内容剩余的示例将假设你使用了这种目录结构。 SqlSessions使用 MyBatis 的主要 Java 接口就是 SqlSession。尽管你可以使用这个接口执行命令,获 取映射器和管理事务。我们会讨论 SqlSession 本身更多,但是首先我们还是要了解如果获取 一个 SqlSession 实例。SqlSessions 是由 SqlSessionFactory 实例创建的。SqlSessionFactory 对 象 包 含 创 建 SqlSession 实 例 的 所 有 方 法 。 而 SqlSessionFactory 本 身 是 由 SqlSessionFactoryBuilder 创建的,它可以从 XML 配置,注解或手动配置 Java 来创建 SqlSessionFactory。 NOTE When using MyBatis with a dependency injection framework like Spring or Guice, SqlSessions are created and injected by the DI framework so you don’t need to use the SqlSessionFactoryBuilder or SqlSessionFactory and can go directly to the SqlSession section. Please refer to the MyBatis-Spring or MyBatis-Guice manuals for further info. SqlSessionFactoryBuilderSqlSessionFactoryBuilder 有五个 build()方法,每一种都允许你从不同的资源中创建一个 SqlSession 实例。 12345SqlSessionFactory build(InputStream inputStream)SqlSessionFactory build(InputStream inputStream, String environment)SqlSessionFactory build(InputStream inputStream, Properties properties)SqlSessionFactory build(InputStream inputStream, String env, Properties props)SqlSessionFactory build(Configuration config) 第一种方法是最常用的,它使用了一个参照了 XML 文档或上面讨论过的更特定的 mybatis-config.xml 文件的 Reader 实例。 可选的参数是 environment 和 properties。 Environment 决定加载哪种环境,包括数据源和事务管理器。比如: 1234567891011121314&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; ... &lt;dataSource type=\"POOLED\"&gt; ... &lt;/environment&gt; &lt;environment id=\"production\"&gt; &lt;transactionManager type=\"MANAGED\"&gt; ... &lt;dataSource type=\"JNDI\"&gt; ... &lt;/environment&gt;&lt;/environments&gt; 如果你调用了 一个使用 environment 参数 方 式的 build 方法, 那么 MyBatis 将会使用 configuration 对象来配置这个 environment。 当然, 如果你指定了一个不合法的 environment, 你会得到错误提示。 如果你调用了其中之一没有 environment 参数的 build 方法, 那么就使用 默认的 environment(在上面的示例中就会指定为 default=”development”)。 如果你调用了使用 properties 实例的方法,那么 MyBatis 就会加载那些 properties(属性 配置文件) ,并你在你配置中可使用它们。那些属性可以用${propName}语法形式多次用在 配置文件中。 回想一下,属性可以从 mybatis-config.xml 中被引用,或者直接指定它。因此理解优先 级是很重要的。我们在文档前面已经提及它了,但是这里要再次重申: 如果一个属性存在于这些位置,那么 MyBatis 将会按找下面的顺序来加载它们: 在 properties 元素体中指定的属性首先被读取, 从 properties 元素的类路径 resource 或 url 指定的属性第二个被读取, 可以覆盖已经 指定的重复属性, 作为方法参 数传递 的属性最 后被读 取,可以 覆盖已 经从 properties 元 素体和 resource/url 属性中加载的任意重复属性。 因此,最高优先级的属性是通过方法参数传递的,之后是 resource/url 属性指定的,最 后是在 properties 元素体中指定的属性。 总结一下,前四个方法很大程度上是相同的,但是由于可以覆盖,就允许你可选地指定 environment 和/或 properties。 这里给出一个从 mybatis-config.xml 文件创建 SqlSessionFactory 的示例: 1234String resource = \"org/mybatis/builder/mybatis-config.xml\";InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();SqlSessionFactory factory = builder.build(inputStream); 注意这里我们使用了 Resources 工具类,这个类在 org.mybatis.io 包中。Resources 类正 如其名,会帮助你从类路径下,文件系统或一个 web URL 加载资源文件。看一下这个类的 源代码或者通过你的 IDE 来查看,就会看到一整套有用的方法。这里给出一个简表: 1234567891011121314URL getResourceURL(String resource)URL getResourceURL(ClassLoader loader, String resource)InputStream getResourceAsStream(String resource)InputStream getResourceAsStream(ClassLoader loader, String resource)Properties getResourceAsProperties(String resource)Properties getResourceAsProperties(ClassLoader loader, String resource)Reader getResourceAsReader(String resource)Reader getResourceAsReader(ClassLoader loader, String resource)File getResourceAsFile(String resource)File getResourceAsFile(ClassLoader loader, String resource)InputStream getUrlAsStream(String urlString)Reader getUrlAsReader(String urlString)Properties getUrlAsProperties(String urlString)Class classForName(String className) 最后一个 build 方法使用了一个 Configuration 实例。configuration 类包含你可能需要了 解 SqlSessionFactory 实例的所有内容。Configuration 类对于配置的自查很有用,包含查找和 操作 SQL 映射(不推荐使用,因为应用正接收请求) 。configuration 类有所有配置的开关, 这些你已经了解了,只在 Java API 中露出来。这里有一个简单的示例,如何手动配置 configuration 实例,然后将它传递给 build()方法来创建 SqlSessionFactory。 12345678910111213141516DataSource dataSource = BaseDataTest.createBlogDataSource();TransactionFactory transactionFactory = new JdbcTransactionFactory();Environment environment = new Environment(\"development\", transactionFactory, dataSource);Configuration configuration = new Configuration(environment);configuration.setLazyLoadingEnabled(true);configuration.setEnhancementEnabled(true);configuration.getTypeAliasRegistry().registerAlias(Blog.class);configuration.getTypeAliasRegistry().registerAlias(Post.class);configuration.getTypeAliasRegistry().registerAlias(Author.class);configuration.addMapper(BoundBlogMapper.class);configuration.addMapper(BoundAuthorMapper.class);SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();SqlSessionFactory factory = builder.build(configuration); 现在你有一个 SqlSessionFactory,可以用来创建 SqlSession 实例。 SqlSessionFactorySqlSessionFactory 有六个方法可以用来创建 SqlSession 实例。通常来说,如何决定是你 选择下面这些方法时: Transaction (事务): 你想为 session 使用事务或者使用自动提交(通常意味着很多 数据库和/或 JDBC 驱动没有事务)? Connection (连接): 你想 MyBatis 获得来自配置的数据源的连接还是提供你自己 Execution (执行): 你想 MyBatis 复用预处理语句和/或批量更新语句(包括插入和 删除)? 重载的 openSession()方法签名设置允许你选择这些可选中的任何一个组合。 123456789SqlSession openSession()SqlSession openSession(boolean autoCommit)SqlSession openSession(Connection connection)SqlSession openSession(TransactionIsolationLevel level)SqlSession openSession(ExecutorType execType,TransactionIsolationLevel level)SqlSession openSession(ExecutorType execType)SqlSession openSession(ExecutorType execType, boolean autoCommit)SqlSession openSession(ExecutorType execType, Connection connection)Configuration getConfiguration(); 默认的 openSession()方法没有参数,它会创建有如下特性的 SqlSession: 会开启一个事务(也就是不自动提交) 连接对象会从由活动环境配置的数据源实例中得到。 事务隔离级别将会使用驱动或数据源的默认设置。 预处理语句不会被复用,也不会批量处理更新。 这些方法大都可以自我解释的。 开启自动提交, “true” 传递 给可选的 autoCommit 参数。 提供自定义的连接,传递一个 Connection 实例给 connection 参数。注意没有覆盖同时设置 Connection 和 autoCommit 两者的方法,因为 MyBatis 会使用当前 connection 对象提供的设 置。 MyBatis 为事务隔离级别调用使用一个 Java 枚举包装器, 称为 TransactionIsolationLevel, 否则它们按预期的方式来工作,并有 JDBC 支持的 5 级 ( NONE,READ_UNCOMMITTED,READ_COMMITTED,REPEA TABLE_READ,SERIALIZA BLE) 还有一个可能对你来说是新见到的参数,就是 ExecutorType。这个枚举类型定义了 3 个 值: ExecutorType.SIMPLE: 这个执行器类型不做特殊的事情。它为每个语句的执行创建一个新的预处理语句。 ExecutorType.REUSE: 这个执行器类型会复用预处理语句。 ExecutorType.BATCH: 这个执行器会批量执行所有更新语句,如果 SELECT 在它们中间执行还会标定它们是 必须的,来保证一个简单并易于理解的行为。 注意 在 SqlSessionFactory 中还有一个方法我们没有提及,就是 getConfiguration()。这 个方法会返回一个 Configuration 实例,在运行时你可以使用它来自检 MyBatis 的配置。 注意 如果你已经使用之前版本 MyBatis,你要回忆那些 session,transaction 和 batch 都是分离的。现在和以往不同了,这些都包含在 session 的范围内了。你需要处理分开处理 事务或批量操作来得到它们的效果。 SqlSession如上面所提到的,SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会发现 所有执行语句的方法,提交或回滚事务,还有获取映射器实例。 在 SqlSession 类中有超过 20 个方法,所以将它们分开成易于理解的组合。 语句执行方法 这些方法被用来执行定义在 SQL 映射的 XML 文件中的 SELECT,INSERT,UPDA E T 和 DELETE 语句。它们都会自行解释,每一句都使用语句的 ID 属性和参数对象,参数可以 是原生类型(自动装箱或包装类) ,JavaBean,POJO 或 Map。 123456&lt;T&gt; T selectOne(String statement, Object parameter)&lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter)&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, Object parameter, String mapKey)int insert(String statement, Object parameter)int update(String statement, Object parameter)int delete(String statement, Object parameter) selectOne 和 selectList 的不同仅仅是 selectOne 必须返回一个对象。 如果多余一个, 或者 没有返回 (或返回了 null) 那么就会抛出异常。 , 如果你不知道需要多少对象, 使用 selectList。 如果你想检查一个对象是否存在,那么最好返回统计数(0 或 1) 。因为并不是所有语句都需 要参数,这些方法都是有不同重载版本的,它们可以不需要参数对象。 123456&lt;T&gt; T selectOne(String statement)&lt;E&gt; List&lt;E&gt; selectList(String statement)&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, String mapKey)int insert(String statement)int update(String statement)int delete(String statement) 最后,还有查询方法的三个高级版本,它们允许你限制返回行数的范围,或者提供自定 义结果控制逻辑,这通常用于大量的数据集合。 1234&lt;E&gt; List&lt;E&gt; selectList (String statement, Object parameter, RowBounds rowBounds)&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowbounds)void select (String statement, Object parameter, ResultHandler&lt;T&gt; handler)void select (String statement, Object parameter, RowBounds rowBounds, ResultHandler&lt;T&gt; handler) RowBounds 参数会告诉 MyBatis 略过指定数量的记录,还有限制返回结果的数量。 RowBounds 类有一个构造方法来接收 offset 和 limit,否则是不可改变的。 123int offset = 100;int limit = 25;RowBounds rowBounds = new RowBounds(offset, limit); 不同的驱动会实现这方面的不同级别的效率。对于最佳的表现,使用结果集类型的 SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE(或句话说:不是 FORWARD_ONLY)。 ResultHandler 参数允许你按你喜欢的方式处理每一行。你可以将它添加到 List 中,创 建 Map, 或抛出每个结果而不是只保留总计。 Set 你可以使用 ResultHandler 做很多漂亮的事, 那就是 MyBatis 内部创建结果集列表。 它的接口很简单。 1234package org.apache.ibatis.session;public interface ResultHandler&lt;T&gt; &#123; void handleResult(ResultContext&lt;? extends T&gt; context);&#125; ResultContext 参数给你访问结果对象本身的方法, 大量结果对象被创建, 你可以使用布尔返回值的 stop()方法来停止 MyBatis 加载更多的结果。 事务控制方法 控制事务范围有四个方法。 当然, 如果你已经选择了自动提交或你正在使用外部事务管 理器,这就没有任何效果了。然而,如果你正在使用 JDBC 事务管理员,由 Connection 实 例来控制,那么这四个方法就会派上用场: 1234void commit()void commit(boolean force)void rollback()void rollback(boolean force) 默认情况下 MyBatis 不会自动提交事务, 除非它侦测到有插入, 更新或删除操作改变了数据库。如果你已经做出了一些改变而没有使用这些方法,那么你可以传递 true 到 commit 和 rollback 方法来保证它会被提交(注意,你不能在自动提交模式下强制 session,或者使用 了外部事务管理器时) 。很多时候你不用调用 rollback(),因为如果你没有调用 commit 时 MyBatis 会替你完成。然而,如果你需要更多对多提交和回滚都可能的 session 的细粒度控 制,你可以使用回滚选择来使它成为可能。 NOTE MyBatis-Spring and MyBatis-Guice provide declarative transaction handling. So if you are using MyBatis with Spring or Guice please refer to their specific manuals. 清理 Session 级的缓存 1void clearCache() SqlSession 实例有一个本地缓存在执行 update,commit,rollback 和 close 时被清理。要 明确地关闭它(获取打算做更多的工作) ,你可以调用 clearCache()。 确保 SqlSession 被关闭 1void close() 你必须保证的最重要的事情是你要关闭所打开的任何 session。保证做到这点的最佳方 式是下面的工作模式: 12345678910SqlSession session = sqlSessionFactory.openSession();try &#123; // following 3 lines pseudocod for \"doing some work\" session.insert(...); session.update(...); session.delete(...); session.commit();&#125; finally &#123; session.close();&#125; Or, If you are using jdk 1.7+ and MyBatis 3.2+, you can use the try-with-resources statement: 1234567try (SqlSession session = sqlSessionFactory.openSession()) &#123; // following 3 lines pseudocode for \"doing some work\" session.insert(...); session.update(...); session.delete(...); session.commit();&#125; 注意 就像 SqlSessionFactory,你可以通过调用 getConfiguration()方法获得 SqlSession 使用的 Configuration 实例 1Configuration getConfiguration() 使用映射器 1&lt;T&gt; T getMapper(Class&lt;T&gt; type) 上述的各个 insert,update,delete 和 select 方法都很强大,但也有些繁琐,没有类型安 全,对于你的 IDE 也没有帮助,还有可能的单元测试。在上面的入门章节中我们已经看到 了一个使用映射器的示例。 因此, 一个更通用的方式来执行映射语句是使用映射器类。 一个映射器类就是一个简单 的接口,其中的方法定义匹配于 SqlSession 方法。下面的示例展示了一些方法签名和它们是 如何映射到 SqlSession 的。 123456789101112131415public interface AuthorMapper &#123; // (Author) selectOne(\"selectAuthor\",5); Author selectAuthor(int id); // (List&lt;Author&gt;) selectList(“selectAuthors”) List&lt;Author&gt; selectAuthors(); // (Map&lt;Integer,Author&gt;) selectMap(\"selectAuthors\", \"id\") @MapKey(\"id\") Map&lt;Integer, Author&gt; selectAuthors(); // insert(\"insertAuthor\", author) int insertAuthor(Author author); // updateAuthor(\"updateAuthor\", author) int updateAuthor(Author author); // delete(\"deleteAuthor\",5) int deleteAuthor(int id);&#125; 总之, 每个映射器方法签名应该匹配相关联的 SqlSession 方法, 而没有字符串参数 ID。 相反,方法名必须匹配映射语句的 ID。 此外,返回类型必须匹配期望的结果类型。所有常用的类型都是支持的,包括:原生类 型,Map,POJO 和 JavaBean。 映射器接口不需要去实现任何接口或扩展任何类。 只要方法前面可以被用来唯一标识对 应的映射语句就可以了。 映射器接口可以扩展其他接口。当使用 XML 来构建映射器接口时要保证在合适的命名 空间中有语句。 而且, 唯一的限制就是你不能在两个继承关系的接口中有相同的方法签名 (这 也是不好的想法)。 你可以传递多个参数给一个映射器方法。 如果你这样做了, 默认情况下它们将会以它们 在参数列表中的位置来命名,比如:#{param1},#{param2}等。如果你想改变参数的名称(只在多参数 情况下) ,那么你可以在参数上使用@Param(“paramName”)注解。 你也可以给方法传递一个 RowBounds 实例来限制查询结果。 映射器注解 因为最初设计时,MyBatis 是一个 XML 驱动的框架。配置信息是基于 XML 的,而且 映射语句也是定义在 XML 中的。而到了 MyBatis 3,有新的可用的选择了。MyBatis 3 构建 在基于全面而且强大的 Java 配置 API 之上。这个配置 API 是基于 XML 的 MyBatis 配置的 基础,也是新的基于注解配置的基础。注解提供了一种简单的方式来实现简单映射语句,而 不会引入大量的开销。 注意 不幸的是,Java 注解限制了它们的表现和灵活。尽管很多时间都花调查,设计和 实验上,最强大的 MyBatis 映射不能用注解来构建,那并不可笑。C#属性(做示例)就没 有这些限制,因此 MyBatis.NET 将会比 XML 有更丰富的选择。也就是说,基于 Java 注解 的配置离不开它的特性。 注解有下面这些: 注解 目标 相对应的 XML 描述 @CacheNamespace 类 &lt;cache&gt; 为给定的命名空间 (比如类) 配置缓存。 属性:implemetation,eviction, flushInterval,size 和 readWrite。 @CacheNamespaceRef 类 &lt;cacheRef&gt; 参照另外一个命名空间的缓存来使用。 属性:value,应该是一个名空间的字 符串值(也就是类的完全限定名) 。 @ConstructorArgs Method &lt;constructor&gt; 收集一组结果传递给一个劫夺对象的 构造方法。属性:value,是形式参数 的数组。 @Arg 方法 &lt;arg> &lt;idArg> 单独的构造方法参数 , 是ConstructorArgs集合的一部分。属性: id,column,javaType,typeHandler。 id 属性是布尔值, 来标识用于比较的属 性,和XML 元素相似。 @TypeDiscriminator 方法 &lt;discriminator&gt; 一组实例值被用来决定结果映射的表 现。 属性: column,javaType, jdbcType, typeHandler,cases。cases 属性就是实 例的数组。 @Case 方法 &lt;case&gt; 单独实例的值和它对应的映射。属性: value,type,results。Results 属性是结 果数组,因此这个注解和实际的 ResultMap 很相似,由下面的 Results 注解指定。 @Results 方法 &lt;resultMap&gt; 结果映射的列表, 包含了一个特别结果 列如何被映射到属性或字段的详情。 属 性:value,是 Result 注解的数组。 @Result 方法 &lt;result> &lt;id> 在列和属性或字段之间的单独结果映 射。属 性:id,column, property, javaType ,jdbcType ,type Handler, one,many。id 属性是一个布尔值,表 示了应该被用于比较(和在 XML 映射 中的相似)的属性。one 属性是单 独 的 联 系, 和 相 似 , 而 many 属 性 是 对 集 合 而 言 的 , 和 相似。 它们这样命名是为了 避免名称冲突。 @One 方法 &lt;association&gt; 复杂类型的单独属性值映射。属性: select,已映射语句(也就是映射器方 法)的完全限定名,它可以加载合适类 型的实例。注意:联合映射在注解 API 中是不支持的。这是因为 Java 注解的 限制,不允许循环引用。 fetchType, which supersedes the global configuration parameter lazyLoadingEnabled for this mapping. @Many 方法 &lt;collection&gt; A mapping to a collection property of a complex type. Attributes: select, which is the fully qualified name of a mapped statement (i.e. mapper method) that can load a collection of instances of the appropriate types, fetchType, which supersedes the global configuration parameter lazyLoadingEnabled for this mapping. NOTE You will notice that join mapping is not supported via the Annotations API. This is due to the limitation in Java Annotations that does not allow for circular references. @MapKey 方法 复杂类型的集合属性映射 。 属性 : select,是映射语句(也就是映射器方 法)的完全限定名,它可以加载合适类 型的一组实例。注意:联合映射在 Java 注解中是不支持的。这是因为 Java 注 解的限制,不允许循环引用。 @Options 方法 映射语句的属性 这个注解提供访问交换和配置选项的 宽广范围, 它们通常在映射语句上作为 属性出现。 而不是将每条语句注解变复 杂,Options 注解提供连贯清晰的方式 来访问它们。属性:useCache=true , flushCache=false , resultSetType=FORWARD_ONLY , statementType=PREPARED , fetchSize=-1 , , timeout=-1 useGeneratedKeys=false , keyProperty=”id”。 理解 Java 注解是很 重要的,因为没有办法来指定“null” 作为值。因此,一旦你使用了 Options 注解,语句就受所有默认值的支配。要 注意什么样的默认值来避免不期望的 行为。 `@Insert` `@Update` `@Delete` `@Select` 方法 &lt;insert> &lt;update> &lt;delete> &lt;select> 这些注解中的每一个代表了执行的真 实 SQL。 它们每一个都使用字符串数组 (或单独的字符串)。如果传递的是字 符串数组, 它们由每个分隔它们的单独 空间串联起来。这就当用 Java 代码构 建 SQL 时避免了“丢失空间”的问题。 然而,如果你喜欢,也欢迎你串联单独 的字符串。属性:value,这是字符串 数组用来组成单独的 SQL 语句。 `@InsertProvider` `@UpdateProvider` `@DeleteProvider` `@SelectProvider` 方法 &lt;insert> &lt;update> &lt;delete> &lt;select> 这些可选的 SQL 注解允许你指定一个 类名和一个方法在执行时来返回运行 允许创建动态 的 SQL。 基于执行的映射语句, MyBatis 会实例化这个类,然后执行由 provider 指定的方法. 这个方法可以选择性的接 受参数对象作为它的唯一参数, 但是必 须只指定该参数或者没有参数。属性: type,method。type 属性是类的完全限 定名。method 是该类中的那个方法名。 注意: 这节之后是对 SelectBuilder 类的 讨论,它可以帮助你以干净,容于阅读 的方式来构建动态 SQL。 @Param Parameter N/A 如果你的映射器的方法需要多个参数, 这个注解可以被应用于映射器的方法 参数来给每个参数一个名字。否则,多参数将会以它们的顺序位置来被命名 (不包括任何 RowBounds 参数) 比如。 #{param1} , #{param2} 等 , 这是默认的 。 使用 @Param(“person”),参数应该被命名为 #{person}。 @SelectKey Method &lt;selectKey&gt; This annotation duplicates the functionality for methods annotated with @Insert, @InsertProvider, @Update or @UpdateProvider. It is ignored for other methods. If you specify a @SelectKey annotation, then MyBatis will ignore any generated key properties set via the @Options annotation, or configuration properties. Attributes: statement an array of strings which is the SQL statement to execute, keyProperty which is the property of the parameter object that will be updated with the new value, before which must be either true or false to denote if the SQL statement should be executed before or after the insert, resultType which is the Java type of the keyProperty, and statementType=PREPARED. @ResultMap Method N/A This annotation is used to provide the id of a element in an XML mapper to a @Select or @SelectProvider annotation. This allows annotated selects to reuse resultmaps that are defined in XML. This annotation will override any @Results or @ConstructorArgs annotation if both are specified on an annotated select. @ResultType Method N/A This annotation is used when using a result handler. In that case, the return type is void so MyBatis must have a way to determine the type of object to construct for each row. If there is an XML result map, use the @ResultMap annotation. If the result type is specified in XML on the &lt;select&gt; element, then no other annotation is necessary. In other cases, use this annotation. For example, if a @Select annotated method will use a result handler, the return type must be void and this annotation (or @ResultMap) is required. This annotation is ignored unless the method return type is void. 映射申明样例 这个例子展示了如何使用 @SelectKey 注解来在插入前读取数据库序列的值： 123@Insert(\"insert into table3 (id, name) values(#&#123;nameId&#125;, #&#123;name&#125;)\")@SelectKey(statement=\"call next value for TestSequence\", keyProperty=\"nameId\", before=true, resultType=int.class)int insertTable3(Name name); 这个例子展示了如何使用 @SelectKey 注解来在插入后读取数据库识别列的值： 123@Insert(\"insert into table2 (name) values(#&#123;name&#125;)\")@SelectKey(statement=\"call identity()\", keyProperty=\"nameId\", before=false, resultType=int.class)int insertTable2(Name name);","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://qinjiangbo.com/tags/mybatis/"},{"name":"ibatis","slug":"ibatis","permalink":"http://qinjiangbo.com/tags/ibatis/"}]},{"title":"MyBatis框架-5-动态SQL","slug":"mybatis-framework-dynamic-sql-5","date":"2016-08-28T02:38:17.000Z","updated":"2018-04-02T09:01:06.000Z","comments":true,"path":"mybatis-framework-dynamic-sql-5.html","link":"","permalink":"http://qinjiangbo.com/mybatis-framework-dynamic-sql-5.html","excerpt":"","text":"动态 SQLMyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其他类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句有多么痛苦。拼接的时候要确保不能忘了必要的空格，还要注意省掉列名列表最后的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 通常使用动态 SQL 不可能是独立的一部分,MyBatis 当然使用一种强大的动态 SQL 语言来改进这种情形,这种语言可以被用在任意的 SQL 映射语句中。 动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似。在 MyBatis 之前的版本中,有很多的元素需要来了解。MyBatis 3 大大提升了它们,现在用不到原先一半的元素就可以了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。 if choose (when, otherwise) trim (where, set) foreach if动态 SQL 通常要做的事情是有条件地包含 where 子句的一部分。比如: 12345678&lt;select id=\"findActiveBlogWithTitleLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; 这条语句提供了一个可选的文本查找类型的功能。如果没有传入“title”，那么所有处于“ACTIVE”状态的BLOG都会返回；反之若传入了“title”，那么就会把模糊查找“title”内容的BLOG结果返回（就这个例子而言，细心的读者会发现其中的参数值是可以包含一些掩码或通配符的）。 如果想可选地通过“title”和“author”两个条件搜索该怎么办呢？首先，改变语句的名称让它更具实际意义；然后只要加入另一个条件即可。 12345678910&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; choose, when, otherwise有些时候，我们不想用到所有的条件语句，而只想从中择其一二。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 还是上面的例子，但是这次变为提供了“title”就按“title”查找，提供了“author”就按“author”查找，若两者都没有提供，就返回所有符合条件的BLOG（实际情况可能是由管理员按一定策略选出BLOG列表，而不是返回大量无意义的随机结果）。 123456789101112131415&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; trim, where, set前面几个例子已经合宜地解决了一个臭名昭著的动态 SQL 问题。现在考虑回到“if”示例，这次我们将“ACTIVE = 1”也设置成动态的条件，看看会发生什么。 1234567891011121314&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; 如果这些条件没有一个能匹配上将会怎样？最终这条 SQL 会变成这样： 12SELECT * FROM BLOGWHERE 这会导致查询失败。如果仅仅第二个条件匹配又会怎样？这条 SQL 最终会是这样: 123SELECT * FROM BLOGWHERE AND title like ‘someTitle’ 这个查询也会失败。这个问题不能简单的用条件句式来解决，如果你也曾经被迫这样写过，那么你很可能从此以后都不想再这样去写了。 MyBatis 有一个简单的处理，这在90%的情况下都会有用。而在不能使用的地方，你可以自定义处理方式来令其正常工作。一处简单的修改就能得到想要的效果： 123456789101112131415&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where 元素知道只有在一个以上的if条件有值的情况下才去插入“WHERE”子句。而且，若最后的内容是“AND”或“OR”开头的，where 元素也知道如何将他们去除。 如果 where 元素没有按正常套路出牌，我们还是可以通过自定义 trim 元素来定制我们想要的功能。比如，和 where 元素等价的自定义 trim 元素为： 123&lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"&gt; ...&lt;/trim&gt; prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它带来的结果就是所有在 prefixOverrides 属性中指定的内容将被移除，并且插入 prefix 属性中指定的内容。 类似的用于动态更新语句的解决方案叫做 set。set 元素可以被用于动态包含需要更新的列，而舍去其他的。比如： 12345678910&lt;update id=\"updateAuthorIfNecessary\"&gt; update Author &lt;set&gt; &lt;if test=\"username != null\"&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=\"password != null\"&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=\"email != null\"&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=\"bio != null\"&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 这里，set 元素会动态前置 SET 关键字，同时也会消除无关的逗号，因为用了条件语句之后很可能就会在生成的赋值语句的后面留下这些逗号。 若你对等价的自定义 trim 元素的样子感兴趣，那这就应该是它的真面目： 123&lt;trim prefix=\"SET\" suffixOverrides=\",\"&gt; ...&lt;/trim&gt; 注意这里我们忽略的是后缀中的值，而又一次附加了前缀中的值。 foreach动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如： 123456789&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; foreach 元素的功能是非常强大的，它允许你指定一个集合，声明可以用在元素体内的集合项和索引变量。它也允许你指定开闭匹配的字符串以及在迭代中间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。 注意 你可以将一个 List 实例或者数组作为参数对象传给 MyBatis，当你这么做的时候，MyBatis 会自动将它包装在一个 Map 中并以名称为键。List 实例将会以“list”作为键，而数组实例的键将是“array”。 到此我们已经完成了涉及 XML 配置文件和 XML 映射文件的讨论。下一部分将详细探讨 Java API，这样才能从已创建的映射中获取最大利益。 bindbind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如： 12345&lt;select id=\"selectBlogsLike\" resultType=\"Blog\"&gt; &lt;bind name=\"pattern\" value=\"'%' + _parameter.getTitle() + '%'\" /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125;&lt;/select&gt; Multi-db vendor support一个配置了“_databaseId”变量的 databaseIdProvider 对于动态代码来说是可用的，这样就可以根据不同的数据库厂商构建特定的语句。比如下面的例子： 1234567891011&lt;insert id=\"insert\"&gt; &lt;selectKey keyProperty=\"id\" resultType=\"int\" order=\"BEFORE\"&gt; &lt;if test=\"_databaseId == 'oracle'\"&gt; select seq_users.nextval from dual &lt;/if&gt; &lt;if test=\"_databaseId == 'db2'\"&gt; select nextval for seq_users from sysibm.sysdummy1\" &lt;/if&gt; &lt;/selectKey&gt; insert into users values (#&#123;id&#125;, #&#123;name&#125;)&lt;/insert&gt; 动态 SQL 中可插拔的脚本语言MyBatis 从 3.2 开始支持可插拔的脚本语言，因此你可以在插入一种语言的驱动（language driver）之后来写基于这种语言的动态 SQL 查询。 可以通过实现下面接口的方式来插入一种语言： 12345public interface LanguageDriver &#123; ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql); SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType); SqlSource createSqlSource(Configuration configuration, String script, Class&lt;?&gt; parameterType);&#125; 一旦有了自定义的语言驱动，你就可以在 mybatis-config.xml 文件中将它设置为默认语言： 123456&lt;typeAliases&gt; &lt;typeAlias type=\"org.sample.MyLanguageDriver\" alias=\"myLanguage\"/&gt;&lt;/typeAliases&gt;&lt;settings&gt; &lt;setting name=\"defaultScriptingLanguage\" value=\"myLanguage\"/&gt;&lt;/settings&gt; 除了设置默认语言，你也可以针对特殊的语句指定特定语言，这可以通过如下的 lang 属性来完成： 123&lt;select id=\"selectBlog\" lang=\"myLanguage\"&gt; SELECT * FROM BLOG&lt;/select&gt; 或者在你正在使用的映射中加上注解 @Lang 来完成： 12345public interface Mapper &#123; @Lang(MyLanguageDriver.class) @Select(\"SELECT * FROM BLOG\") List&lt;Blog&gt; selectBlog();&#125; 注意 可以将 Apache Velocity 作为动态语言来使用，更多细节请参考 MyBatis-Velocity 项目。 你前面看到的所有 xml 标签都是默认 MyBatis 语言提供的，它是由别名为 xml 语言驱动器 org.apache.ibatis.scripting.xmltags.XmlLanguageDriver 驱动的。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://qinjiangbo.com/tags/mybatis/"},{"name":"ibatis","slug":"ibatis","permalink":"http://qinjiangbo.com/tags/ibatis/"}]},{"title":"MyBatis框架-4-Mapper XML文件","slug":"mybatis-framework-mapper-xml-4","date":"2016-08-27T09:35:16.000Z","updated":"2018-04-02T09:01:19.000Z","comments":true,"path":"mybatis-framework-mapper-xml-4.html","link":"","permalink":"http://qinjiangbo.com/mybatis-framework-mapper-xml-4.html","excerpt":"","text":"Mapper XML 文件MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。 SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）： cache – 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 parameterMap – 已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句 下一部分将从语句本身开始来描述每个元素的细节。 select查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，如果还能重新取出来才有用，多数应用也都是查询比修改要频繁。对每个插入、更新或删除操作，通常对应多个查询操作。这是 MyBatis 的基本原则之一，也是将焦点和努力放到查询和结果映射的原因。简单查询的 select 元素是非常简单的。比如： 123&lt;select id=\"selectPerson\" parameterType=\"int\" resultType=\"hashmap\"&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125;&lt;/select&gt; 这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。 注意参数符号： 1#&#123;id&#125; 这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样： 1234// Similar JDBC code, NOT MyBatis…String selectPerson = \"SELECT * FROM PERSON WHERE ID=?\";PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id); 当然，这需要很多单独的 JDBC 的代码来提取结果并将它们映射到对象实例中，这就是 MyBatis 节省你时间的地方。我们需要深入了解参数和结果映射，细节部分我们下面来了解。 select 元素有很多属性允许你配置，来决定每条语句的作用细节。 123456789101112&lt;select id=\"selectPerson\" parameterType=\"int\" parameterMap=\"deprecated\" resultType=\"hashmap\" resultMap=\"personResultMap\" flushCache=\"false\" useCache=\"true\" timeout=\"10000\" fetchSize=\"256\" statementType=\"PREPARED\" resultSetType=\"FORWARD_ONLY\"&gt; Select Attributes 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。 resultType 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。 resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。 useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 fetchSize 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 resultSets 这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并给每个结果集一个名称，名称是逗号分隔的。 insert, update 和 delete数据变更语句 insert，update 和 delete 的实现非常接近： 1234567891011121314151617181920212223&lt;insert id=\"insertAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" keyProperty=\"\" keyColumn=\"\" useGeneratedKeys=\"\" timeout=\"20\"&gt;&lt;update id=\"updateAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt;&lt;delete id=\"deleteAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt; Insert, Update 和 Delete 的属性 属性 描述 id 命名空间中的唯一标识符，可被用来代表这条语句。 parameterType 将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。 statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。 下面就是 insert，update 和 delete 语句的示例： 1234567891011121314151617&lt;insert id=\"insertAuthor\"&gt; insert into Author (id,username,password,email,bio) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt;&lt;update id=\"updateAuthor\"&gt; update Author set username = #&#123;username&#125;, password = #&#123;password&#125;, email = #&#123;email&#125;, bio = #&#123;bio&#125; where id = #&#123;id&#125;&lt;/update&gt;&lt;delete id=\"deleteAuthor\"&gt; delete from Author where id = #&#123;id&#125;&lt;/delete&gt; 如前所述，插入语句的配置规则更加丰富，在插入语句里面有一些额外的属性和子元素用来处理主键的生成，而且有多种生成方式。 首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就OK了。例如，如果上面的 Author 表已经对 id 使用了自动生成的列类型，那么语句可以修改为: 12345&lt;insert id=\"insertAuthor\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into Author (username,password,email,bio) values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)&lt;/insert&gt; 对于不支持自动生成类型的数据库或可能不支持自动生成主键 JDBC 驱动来说，MyBatis 有另外一种方法来生成主键。 这里有一个简单（甚至很傻）的示例，它可以生成一个随机 ID（你最好不要这么做，但这里展示了 MyBatis 处理问题的灵活性及其所关心的广度）： 123456789&lt;insert id=\"insertAuthor\"&gt; &lt;selectKey keyProperty=\"id\" resultType=\"int\" order=\"BEFORE\"&gt; select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1 &lt;/selectKey&gt; insert into Author (id, username, password, email,bio, favourite_section) values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;, #&#123;bio&#125;, #&#123;favouriteSection,jdbcType=VARCHAR&#125;)&lt;/insert&gt; 在上面的示例中，selectKey 元素将会首先运行，Author 的 id 会被设置，然后插入语句会被调用。这给你了一个和数据库中来处理自动生成的主键类似的行为，避免了使 Java 代码变得复杂。 selectKey 元素描述如下： 12345&lt;selectKey keyProperty=\"id\" resultType=\"int\" order=\"BEFORE\" statementType=\"PREPARED\"&gt; selectKey 的属性 属性 描述 keyProperty selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 keyColumn 匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 resultType 结果的类型。MyBatis 通常可以推算出来，但是为了更加确定写上也不会有什么问题。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。 order 这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先选择主键，设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 元素 - 这和像 Oracle 的数据库相似，在插入语句内部可能有嵌入索引调用。 statementType 与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型，分别代表 PreparedStatement 和 CallableStatement 类型。 sql这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。It can be statically (during load phase) parametrized. Different property values can vary in include instances. 比如：1&lt;sql id=\"userColumns\"&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt; 这个 SQL 片段可以被包含在其他语句中，例如： 1234567&lt;select id=\"selectUsers\" resultType=\"map\"&gt; select &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t1\"/&gt;&lt;/include&gt;, &lt;include refid=\"userColumns\"&gt;&lt;property name=\"alias\" value=\"t2\"/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; Property value can be also used in include refid attribute or property values inside include clause, for example: 1234567891011121314151617&lt;sql id=\"sometable\"&gt; $&#123;prefix&#125;Table&lt;/sql&gt;&lt;sql id=\"someinclude\"&gt; from &lt;include refid=\"$&#123;include_target&#125;\"/&gt;&lt;/sql&gt;&lt;select id=\"select\" resultType=\"map\"&gt; select field1, field2, field3 &lt;include refid=\"someinclude\"&gt; &lt;property name=\"prefix\" value=\"Some\"/&gt; &lt;property name=\"include_target\" value=\"sometable\"/&gt; &lt;/include&gt;&lt;/select&gt; 参数（Parameters）前面的所有语句中你所见到的都是简单参数的例子，实际上参数是 MyBatis 非常强大的元素，对于简单的做法，大概 90% 的情况参数都很少，比如： 12345&lt;select id=\"selectUsers\" resultType=\"User\"&gt; select id, username, password from users where id = #&#123;id&#125;&lt;/select&gt; 上面的这个示例说明了一个非常简单的命名参数映射。参数类型被设置为 int，这样这个参数就可以被设置成任何内容。原生的类型或简单数据类型（比如整型和字符串）因为没有相关属性，它会完全用参数值来替代。然而，如果传入一个复杂的对象，行为就会有一点不同了。比如： 1234&lt;insert id=\"insertUser\" parameterType=\"User\"&gt; insert into users (id, username, password) values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)&lt;/insert&gt; 如果 User 类型的参数对象传递到了语句中，id、username 和 password 属性将会被查找，然后将它们的值传入预处理语句的参数中。 这点对于向语句中传参是比较好的而且又简单，不过参数映射的功能远不止于此。 首先，像 MyBatis 的其他部分一样，参数也可以指定一个特殊的数据类型。 1#&#123;property,javaType=int,jdbcType=NUMERIC&#125; 像 MyBatis 的剩余部分一样，javaType 通常可以从参数对象中来去确定，前提是只要对象不是一个 HashMap。那么 javaType 应该被确定来保证使用正确类型处理器。 NOTE 如果 null 被当作值来传递，对于所有可能为空的列，JDBC Type 是需要的。你可以自己通过阅读预处理语句的 setNull() 方法的 JavaDocs 文档来研究这种情况。 为了以后定制类型处理方式，你也可以指定一个特殊的类型处理器类（或别名），比如： 1#&#123;age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler&#125; 尽管看起来配置变得越来越繁琐，但实际上是很少去设置它们。 对于数值类型，还有一个小数保留位数的设置，来确定小数点后保留的位数。 1#&#123;height,javaType=double,jdbcType=NUMERIC,numericScale=2&#125; 最后，mode 属性允许你指定 IN，OUT 或 INOUT 参数。如果参数为 OUT 或 INOUT，参数对象属性的真实值将会被改变，就像你在获取输出参数时所期望的那样。如果 mode 为 OUT（或 INOUT），而且 jdbcType 为 CURSOR(也就是 Oracle 的 REFCURSOR)，你必须指定一个 resultMap 来映射结果集到参数类型。要注意这里的 javaType 属性是可选的，如果左边的空白是 jdbcType 的 CURSOR 类型，它会自动地被设置为结果集。 1#&#123;department, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=departmentResultMap&#125; MyBatis 也支持很多高级的数据类型，比如结构体，但是当注册 out 参数时你必须告诉它语句类型名称。比如（再次提示，在实际中要像这样不能换行）： 1#&#123;middleInitial, mode=OUT, jdbcType=STRUCT, jdbcTypeName=MY_TYPE, resultMap=departmentResultMap&#125; 尽管所有这些强大的选项很多时候你只简单指定属性名，其他的事情 MyBatis 会自己去推断，最多你需要为可能为空的列名指定 jdbcType。 123#&#123;firstName&#125;#&#123;middleInitial,jdbcType=VARCHAR&#125;#&#123;lastName&#125; 字符串替换默认情况下,使用#{}格式的语法会导致 MyBatis 创建预处理语句属性并安全地设置值（比如?）。这样做更安全，更迅速，通常也是首选做法，不过有时你只是想直接在 SQL 语句中插入一个不改变的字符串。比如，像 ORDER BY，你可以这样来使用： 1ORDER BY $&#123;columnName&#125; 这里 MyBatis 不会修改或转义字符串。 NOTE 以这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。 Result MapsresultMap 元素是 MyBatis 中最重要最强大的元素。它就是让你远离 90%的需要从结果 集中取出数据的 JDBC 代码的那个东西, 而且在一些情形下允许你做一些 JDBC 不支持的事 情。 事实上, 编写相似于对复杂语句联合映射这些等同的代码, 也许可以跨过上千行的代码。 ResultMap 的设计就是简单语句不需要明确的结果映射,而很多复杂语句确实需要描述它们 的关系。 你已经看到简单映射语句的示例了,但没有明确的 resultMap。比如: 12345&lt;select id=\"selectUsers\" resultType=\"map\"&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt; 这样一个语句简单作用于所有列被自动映射到 HashMap 的键上,这由 resultType 属性 指定。这在很多情况下是有用的,但是 HashMap 不能很好描述一个领域模型。那样你的应 用程序将会使用 JavaBeans 或 POJOs(Plain Old Java Objects,普通 Java 对象)来作为领域 模型。MyBatis 对两者都支持。看看下面这个 JavaBean: 12345678910111213141516171819202122232425package com.someapp.model;public class User &#123; private int id; private String username; private String hashedPassword; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getHashedPassword() &#123; return hashedPassword; &#125; public void setHashedPassword(String hashedPassword) &#123; this.hashedPassword = hashedPassword; &#125;&#125; 基于 JavaBean 的规范,上面这个类有 3 个属性:id,username 和 hashedPassword。这些 在 select 语句中会精确匹配到列名。 这样的一个 JavaBean 可以被映射到结果集,就像映射到 HashMap 一样简单。 12345&lt;select id=\"selectUsers\" resultType=\"com.someapp.model.User\"&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt; 要记住类型别名是你的伙伴。使用它们你可以不用输入类的全路径。比如: 123456789&lt;!-- In mybatis-config.xml file --&gt;&lt;typeAlias type=\"com.someapp.model.User\" alias=\"User\"/&gt;&lt;!-- In SQL Mapping XML file --&gt;&lt;select id=\"selectUsers\" resultType=\"User\"&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt; 这些情况下,MyBatis 会在幕后自动创建一个 ResultMap,基于属性名来映射列到 JavaBean 的属性上。如果列名没有精确匹配,你可以在列名上使用 select 字句的别名(一个 基本的 SQL 特性)来匹配标签。比如: 12345678&lt;select id=\"selectUsers\" resultType=\"User\"&gt; select user_id as \"id\", user_name as \"userName\", hashed_password as \"hashedPassword\" from some_table where id = #&#123;id&#125;&lt;/select&gt; ResultMap 最优秀的地方你已经了解了很多了,但是你还没有真正的看到一个。这些简 单的示例不需要比你看到的更多东西。 只是出于示例的原因, 让我们来看看最后一个示例中 外部的 resultMap 是什么样子的,这也是解决列名不匹配的另外一种方式。 12345&lt;resultMap id=\"userResultMap\" type=\"User\"&gt; &lt;id property=\"id\" column=\"user_id\" /&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"password\" column=\"password\"/&gt;&lt;/resultMap&gt; 引用它的语句使用 resultMap 属性就行了(注意我们去掉了 resultType 属性)。比如: 12345&lt;select id=\"selectUsers\" resultMap=\"userResultMap\"&gt; select user_id, user_name, hashed_password from some_table where id = #&#123;id&#125;&lt;/select&gt; 如果世界总是这么简单就好了。 高级结果映射MyBatis 创建的一个想法:数据库不用永远是你想要的或需要它们是什么样的。而我们 最喜欢的数据库最好是第三范式或 BCNF 模式,但它们有时不是。如果可能有一个单独的 数据库映射,所有应用程序都可以使用它,这是非常好的,但有时也不是。结果映射就是 MyBatis 提供处理这个问题的答案。 比如,我们如何映射下面这个语句? 12345678910111213141516171819202122232425262728293031323334&lt;!-- Very Complex Statement --&gt;&lt;select id=\"selectBlogDetails\" resultMap=\"detailedBlogResultMap\"&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, A.favourite_section as author_favourite_section, P.id as post_id, P.blog_id as post_blog_id, P.author_id as post_author_id, P.created_on as post_created_on, P.section as post_section, P.subject as post_subject, P.draft as draft, P.body as post_body, C.id as comment_id, C.post_id as comment_post_id, C.name as comment_name, C.comment as comment_text, T.id as tag_id, T.name as tag_name from Blog B left outer join Author A on B.author_id = A.id left outer join Post P on B.id = P.blog_id left outer join Comment C on P.id = C.post_id left outer join Post_Tag PT on PT.post_id = P.id left outer join Tag T on PT.tag_id = T.id where B.id = #&#123;id&#125;&lt;/select&gt; 你可能想把它映射到一个智能的对象模型,包含一个作者写的博客,有很多的博文,每 篇博文有零条或多条的评论和标签。 下面是一个完整的复杂结果映射例子 (假设作者, 博客, 博文, 评论和标签都是类型的别名) 我们来看看, 。 但是不用紧张, 我们会一步一步来说明。 当天最初它看起来令人生畏,但实际上非常简单。 1234567891011121314151617181920212223242526272829&lt;!-- Very Complex Result Map --&gt;&lt;resultMap id=\"detailedBlogResultMap\" type=\"Blog\"&gt; &lt;constructor&gt; &lt;idArg column=\"blog_id\" javaType=\"int\"/&gt; &lt;/constructor&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;association property=\"author\" javaType=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt; &lt;result property=\"password\" column=\"author_password\"/&gt; &lt;result property=\"email\" column=\"author_email\"/&gt; &lt;result property=\"bio\" column=\"author_bio\"/&gt; &lt;result property=\"favouriteSection\" column=\"author_favourite_section\"/&gt; &lt;/association&gt; &lt;collection property=\"posts\" ofType=\"Post\"&gt; &lt;id property=\"id\" column=\"post_id\"/&gt; &lt;result property=\"subject\" column=\"post_subject\"/&gt; &lt;association property=\"author\" javaType=\"Author\"/&gt; &lt;collection property=\"comments\" ofType=\"Comment\"&gt; &lt;id property=\"id\" column=\"comment_id\"/&gt; &lt;/collection&gt; &lt;collection property=\"tags\" ofType=\"Tag\" &gt; &lt;id property=\"id\" column=\"tag_id\"/&gt; &lt;/collection&gt; &lt;discriminator javaType=\"int\" column=\"draft\"&gt; &lt;case value=\"1\" resultType=\"DraftPost\"/&gt; &lt;/discriminator&gt; &lt;/collection&gt;&lt;/resultMap&gt; resultMap 元素有很多子元素和一个值得讨论的结构。 下面是 resultMap 元素的概念视图 resultMap constructor - 类在实例化时,用来注入结果到构造方法中 idArg - ID 参数;标记结果作为 ID 可以帮助提高整体效能 arg - 注入到构造方法的一个普通结果 id – 一个 ID 结果;标记结果作为 ID 可以帮助提高整体效能 result – 注入到字段或 JavaBean 属性的普通结果 association – 一个复杂的类型关联;许多结果将包成这种类型 嵌入结果映射 – 结果映射自身的关联,或者参考一个 collection – 复杂类型的集 嵌入结果映射 – 结果映射自身的集,或者参考一个 discriminator – 使用结果值来决定使用哪个结果映射 case – 基于某些值的结果映射 嵌入结果映射 – 这种情形结果也映射它本身,因此可以包含很多相 同的元素,或者它可以参照一个外部的结果映射。 ResultMap Attributes Attribute Description id A unique identifier in this namespace that can be used to reference this result map. type A fully qualified Java class name, or a type alias (see the table above for the list of built-in type aliases). autoMapping If present, MyBatis will enable or disable the automapping for this ResultMap. This attribute overrides the global autoMappingBehavior. Default: unset. 最佳实践 通常逐步建立结果映射。单元测试的真正帮助在这里。如果你尝试创建 一次创建一个向上面示例那样的巨大的结果映射, 那么可能会有错误而且很难去控制它 来工作。开始简单一些,一步一步的发展。而且要进行单元测试!使用该框架的缺点是 它们有时是黑盒(是否可见源代码) 。你确定你实现想要的行为的最好选择是编写单元 测试。它也可以你帮助得到提交时的错误。 下面一部分将详细说明每个元素。 id &amp; result12&lt;id property=\"id\" column=\"post_id\"/&gt;&lt;result property=\"subject\" column=\"post_subject\"/&gt; 这些是结果映射最基本内容。id 和 result 都映射一个单独列的值到简单数据类型(字符 串,整型,双精度浮点数,日期等)的单独属性或字段。 这两者之间的唯一不同是 id 表示的结果将是当比较对象实例时用到的标识属性。这帮 助来改进整体表现,特别是缓存和嵌入结果映射(也就是联合映射) 。 每个都有一些属性: Id and Result Attributes 属性 描述 property 映射到列结果的字段或属性。如果匹配的是存在的,和给定名称相同 的 JavaBeans 的属性,那么就会使用。否则 MyBatis 将会寻找给定名称 property 的字段。这两种情形你可以使用通常点式的复杂属性导航。比如,你 可以这样映射一些东西: “username” ,或者映射到一些复杂的东西: “address.street.number” 。 column 从数据库中得到的列名,或者是列名的重命名标签。这也是通常和会 传递给 resultSet.getString(columnName)方法参数中相同的字符串。 javaType 一个 Java 类的完全限定名,或一个类型别名(参考上面内建类型别名 的列表) 。如果你映射到一个 JavaBean,MyBatis 通常可以断定类型。 然而,如果你映射到的是 HashMap,那么你应该明确地指定 javaType 来保证所需的行为。 jdbcType 在这个表格之后的所支持的 JDBC 类型列表中的类型。JDBC 类型是仅 仅需要对插入,更新和删除操作可能为空的列进行处理。这是 JDBC jdbcType 的需要,而不是 MyBatis 的。如果你直接使用 JDBC 编程,你需要指定 这个类型-但仅仅对可能为空的值。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性,你可以覆盖默 认的类型处理器。这个属性值是类的完全限定名或者是一个类型处理 器的实现,或者是类型别名。 支持的 JDBC 类型为了未来的参考,MyBatis 通过包含的 jdbcType 枚举型,支持下面的 JDBC 类型。 Type Type Type Type BIT FLOAT CHAR TIMESTAMP OTHER UNDEFINED TINYINT REAL VARCHAR BINARY BLOG NVARCHAR SMALLINT DOUBLE LONGVARCHAR VARBINARY CLOB NCHAR INTEGER NUMERIC DATE LONGVARBINARY BOOLEAN NCLOB BIGINT DECIMAL TIME NULL CURSOR ARRAY 构造方法1234&lt;constructor&gt; &lt;idArg column=\"id\" javaType=\"int\"/&gt; &lt;arg column=\"username\" javaType=\"String\"/&gt;&lt;/constructor&gt; 对于大多数数据传输对象(Data Transfer Object,DTO)类型,属性可以起作用,而且像 你绝大多数的领域模型, 指令也许是你想使用一成不变的类的地方。 通常包含引用或查询数 据的表很少或基本不变的话对一成不变的类来说是合适的。 构造方法注入允许你在初始化时 为类设置属性的值,而不用暴露出公有方法。MyBatis 也支持私有属性和私有 JavaBeans 属 性来达到这个目的,但是一些人更青睐构造方法注入。构造方法元素支持这个。 看看下面这个构造方法: 1234567public class User &#123; //... public User(int id, String username) &#123; //... &#125;//...&#125; 为了向这个构造方法中注入结果,MyBatis 需要通过它的参数的类型来标识构造方法。 Java 没有自查(反射)参数名的方法。所以当创建一个构造方法元素时,保证参数是按顺序 排列的,而且数据类型也是确定的。 1234&lt;constructor&gt; &lt;idArg column=\"id\" javaType=\"int\"/&gt; &lt;arg column=\"username\" javaType=\"String\"/&gt;&lt;/constructor&gt; 剩余的属性和规则和固定的 id 和 result 元素是相同的。 属性 描述 column 来自数据库的类名,或重命名的列标签。这和通常传递给 resultSet.getString(columnName)方法的字符串是相同的。 javaType 一个 Java 类的完全限定名,或一个类型别名(参考上面内建类型别名的列表)。 如果你映射到一个 JavaBean,MyBatis 通常可以断定类型。然而,如 果你映射到的是 HashMap,那么你应该明确地指定 javaType 来保证所需的 行为。 jdbcType 在这个表格之前的所支持的 JDBC 类型列表中的类型。JDBC 类型是仅仅 需要对插入, 更新和删除操作可能为空的列进行处理。这是 JDBC 的需要, jdbcType 而不是 MyBatis 的。如果你直接使用 JDBC 编程,你需要指定这个类型-但 仅仅对可能为空的值。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性,你可以覆盖默认的 类型处理器。 这个属性值是类的完全限定名或者是一个类型处理器的实现, 或者是类型别名。 select The ID of another mapped statement that will load the complex type required by this property mapping. The values retrieved from columns specified in the column attribute will be passed to the target select statement as parameters. See the Association element for more. resultMap This is the ID of a ResultMap that can map the nested results of this argument into an appropriate object graph. This is an alternative to using a call to another select statement. It allows you to join multiple tables together into a single ResultSet. Such a ResultSet will contain duplicated, repeating groups of data that needs to be decomposed and mapped properly to a nested object graph. To facilitate this, MyBatis lets you “chain” result maps together, to deal with the nested results. See the Association element below for more. 关联 1234&lt;association property=\"author\" column=\"blog_author_id\" javaType=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt;&lt;/association&gt; 关联元素处理“有一个”类型的关系。比如,在我们的示例中,一个博客有一个用户。 关联映射就工作于这种结果之上。你指定了目标属性,来获取值的列,属性的 java 类型(很 多情况下 MyBatis 可以自己算出来) ,如果需要的话还有 jdbc 类型,如果你想覆盖或获取的 结果值还需要类型控制器。 关联中不同的是你需要告诉 MyBatis 如何加载关联。MyBatis 在这方面会有两种不同的 方式: 嵌套查询:通过执行另外一个 SQL 映射语句来返回预期的复杂类型。 嵌套结果:使用嵌套结果映射来处理重复的联合结果的子集。首先,然让我们来查看这个元素的属性。所有的你都会看到,它和普通的只由 select 和 resultMap 属性的结果映射不同。 属性 描述 property 映射到列结果的字段或属性。如果匹配的是存在的,和给定名称相同的 property JavaBeans 的属性, 那么就会使用。 否则 MyBatis 将会寻找给定名称的字段。 这两种情形你可以使用通常点式的复杂属性导航。比如,你可以这样映射 一 些 东 西 :“ username ”, 或 者 映 射 到 一 些 复 杂 的 东 西 : “address.street.number” 。 javaType 一个 Java 类的完全限定名,或一个类型别名(参考上面内建类型别名的列 表) 。如果你映射到一个 JavaBean,MyBatis 通常可以断定类型。然而,如 javaType 果你映射到的是 HashMap,那么你应该明确地指定 javaType 来保证所需的 行为。 jdbcType 在这个表格之前的所支持的 JDBC 类型列表中的类型。JDBC 类型是仅仅 需要对插入, 更新和删除操作可能为空的列进行处理。这是 JDBC 的需要, jdbcType 而不是 MyBatis 的。如果你直接使用 JDBC 编程,你需要指定这个类型-但 仅仅对可能为空的值。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性,你可以覆盖默认的 typeHandler 类型处理器。 这个属性值是类的完全限定名或者是一个类型处理器的实现, 或者是类型别名。 关联的嵌套查询 属性 描述 column 来自数据库的类名,或重命名的列标签。这和通常传递给 resultSet.getString(columnName)方法的字符串是相同的。 column 注 意 : 要 处 理 复 合 主 键 , 你 可 以 指 定 多 个 列 名 通 过 column= ” {prop1=col1,prop2=col2} ” 这种语法来传递给嵌套查询语 句。这会引起 prop1 和 prop2 以参数对象形式来设置给目标嵌套查询语句。 select 另外一个映射语句的 ID,可以加载这个属性映射需要的复杂类型。获取的 在列属性中指定的列的值将被传递给目标 select 语句作为参数。表格后面 有一个详细的示例。 select 注 意 : 要 处 理 复 合 主 键 , 你 可 以 指 定 多 个 列 名 通 过 column= ” {prop1=col1,prop2=col2} ” 这种语法来传递给嵌套查询语 句。这会引起 prop1 和 prop2 以参数对象形式来设置给目标嵌套查询语句。 fetchType Optional. Valid values are lazy and eager. If present, it supersedes the global configuration parameter lazyLoadingEnabled for this mapping. 示例: 1234567891011&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;association property=\"author\" column=\"author_id\" javaType=\"Author\" select=\"selectAuthor\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; SELECT * FROM BLOG WHERE ID = #&#123;id&#125;&lt;/select&gt;&lt;select id=\"selectAuthor\" resultType=\"Author\"&gt; SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;&lt;/select&gt; 我们有两个查询语句:一个来加载博客,另外一个来加载作者,而且博客的结果映射描 述了“selectAuthor”语句应该被用来加载它的 author 属性。 其他所有的属性将会被自动加载,假设它们的列和属性名相匹配。 这种方式很简单, 但是对于大型数据集合和列表将不会表现很好。 问题就是我们熟知的 “N+1 查询问题”。概括地讲,N+1 查询问题可以是这样引起的: 你执行了一个单独的 SQL 语句来获取结果列表(就是“+1”)。 对返回的每条记录,你执行了一个查询语句来为每个加载细节(就是“N”)。 这个问题会导致成百上千的 SQL 语句被执行。这通常不是期望的。 MyBatis 能延迟加载这样的查询就是一个好处,因此你可以分散这些语句同时运行的消 耗。然而,如果你加载一个列表,之后迅速迭代来访问嵌套的数据,你会调用所有的延迟加 载,这样的行为可能是很糟糕的。 所以还有另外一种方法。 关联的嵌套结果 属性 描述 resultMap 这是结果映射的 ID,可以映射关联的嵌套结果到一个合适的对象图中。这 是一种替代方法来调用另外一个查询语句。这允许你联合多个表来合成到 resultMap 一个单独的结果集。这样的结果集可能包含重复,数据的重复组需要被分 解,合理映射到一个嵌套的对象图。为了使它变得容易,MyBatis 让你“链 接”结果映射,来处理嵌套结果。一个例子会很容易来仿照,这个表格后 面也有一个示例。 columnPrefix When joining multiple tables, you would have to use column alias to avoid duplicated column names in the ResultSet. Specifying columnPrefix allows you to map such columns to an external resultMap. Please see the example explained later in this section. notNullColumn By default a child object is created only if at least one of the columns mapped to the child’s properties is non null. With this attribute you can change this behaviour by specifiying which columns must have a value so MyBatis will create a child object only if any of those columns is not null. Multiple column names can be specified using a comma as a separator. Default value: unset. autoMapping If present, MyBatis will enable or disable auto-mapping when mapping the result to this property. This attribute overrides the global autoMappingBehavior. Note that it has no effect on an external resultMap, so it is pointless to use it with select or resultMap attribute. Default value: unset. 在上面你已经看到了一个非常复杂的嵌套关联的示例。 下面这个是一个非常简单的示例 来说明它如何工作。代替了执行一个分离的语句,我们联合博客表和作者表在一起,就像: 12345678910111213&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio from Blog B left outer join Author A on B.author_id = A.id where B.id = #&#123;id&#125;&lt;/select&gt; 注意这个联合查询, 以及采取保护来确保所有结果被唯一而且清晰的名字来重命名。 这使得映射非常简单。现在我们可以映射这个结果: 12345678910111213&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;id property=\"id\" column=\"blog_id\" /&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;association property=\"author\" column=\"blog_author_id\" javaType=\"Author\" resultMap=\"authorResult\"/&gt;&lt;/resultMap&gt;&lt;resultMap id=\"authorResult\" type=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt; &lt;result property=\"password\" column=\"author_password\"/&gt; &lt;result property=\"email\" column=\"author_email\"/&gt; &lt;result property=\"bio\" column=\"author_bio\"/&gt;&lt;/resultMap&gt; 在上面的示例中你可以看到博客的作者关联代表着“authorResult”结果映射来加载作 者实例。 非常重要: 在嵌套据诶过映射中 id 元素扮演了非常重要的角色。应应该通常指定一个 或多个属性,它们可以用来唯一标识结果。实际上就是如果你离开她了,但是有一个严重的 性能问题时 MyBatis 仍然可以工作。选择的属性越少越好,它们可以唯一地标识结果。主键 就是一个显而易见的选择(尽管是联合主键)。 现在,上面的示例用了外部的结果映射元素来映射关联。这使得 Author 结果映射可以 重用。然而,如果你不需要重用它的话,或者你仅仅引用你所有的结果映射合到一个单独描 述的结果映射中。你可以嵌套结果映射。这里给出使用这种方式的相同示例: 1234567891011&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;id property=\"id\" column=\"blog_id\" /&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;association property=\"author\" javaType=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt; &lt;result property=\"password\" column=\"author_password\"/&gt; &lt;result property=\"email\" column=\"author_email\"/&gt; &lt;result property=\"bio\" column=\"author_bio\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; What if the blog has a co-author? The select statement would look like: 12345678910111213141516171819&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; select B.id as blog_id, B.title as blog_title, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, CA.id as co_author_id, CA.username as co_author_username, CA.password as co_author_password, CA.email as co_author_email, CA.bio as co_author_bio from Blog B left outer join Author A on B.author_id = A.id left outer join Author CA on B.co_author_id = CA.id where B.id = #&#123;id&#125;&lt;/select&gt; Recall that the resultMap for Author is defined as follows. 1234567&lt;resultMap id=\"authorResult\" type=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt; &lt;result property=\"password\" column=\"author_password\"/&gt; &lt;result property=\"email\" column=\"author_email\"/&gt; &lt;result property=\"bio\" column=\"author_bio\"/&gt;&lt;/resultMap&gt; Because the column names in the results differ from the columns defined in the resultMap, you need to specify columnPrefix to reuse the resultMap for mapping co-author results. 123456789&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;id property=\"id\" column=\"blog_id\" /&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;association property=\"author\" resultMap=\"authorResult\" /&gt; &lt;association property=\"coAuthor\" resultMap=\"authorResult\" columnPrefix=\"co_\" /&gt;&lt;/resultMap&gt; 上面你已经看到了如何处理“有一个”类型关联。但是“有很多个”是怎样的?下面这 个部分就是来讨论这个主题的。 集合12345&lt;collection property=\"posts\" ofType=\"domain.blog.Post\"&gt; &lt;id property=\"id\" column=\"post_id\"/&gt; &lt;result property=\"subject\" column=\"post_subject\"/&gt; &lt;result property=\"body\" column=\"post_body\"/&gt;&lt;/collection&gt; 集合元素的作用几乎和关联是相同的。实际上,它们也很相似,文档的异同是多余的。 所以我们更多关注于它们的不同。 我们来继续上面的示例,一个博客只有一个作者。但是博客有很多文章。在博客类中, 这可以由下面这样的写法来表示: 1private List&lt;Post&gt; posts; 要映射嵌套结果集合到 List 中,我们使用集合元素。就像关联元素一样,我们可以从 连接中使用嵌套查询,或者嵌套结果。 集合的嵌套查询首先,让我们看看使用嵌套查询来为博客加载文章。 1234567891011&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;collection property=\"posts\" javaType=\"ArrayList\" column=\"id\" ofType=\"Post\" select=\"selectPostsForBlog\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; SELECT * FROM BLOG WHERE ID = #&#123;id&#125;&lt;/select&gt;&lt;select id=\"selectPostsForBlog\" resultType=\"Blog\"&gt; SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;&lt;/select&gt; 这里你应该注意很多东西,但大部分代码和上面的关联元素是非常相似的。首先,你应 该注意我们使用的是集合元素。然后要注意那个新的“ofType”属性。这个属性用来区分 JavaBean(或字段)属性类型和集合包含的类型来说是很重要的。所以你可以读出下面这个 映射: 1&lt;collection property=\"posts\" javaType=\"ArrayList\" column=\"id\" ofType=\"Post\" select=\"selectPostsForBlog\"/&gt; 读作: “在 Post 类型的 ArrayList 中的 posts 的集合。” javaType 属性是不需要的,因为 MyBatis 在很多情况下会为你算出来。所以你可以缩短 写法: 1&lt;collection property=\"posts\" column=\"id\" ofType=\"Post\" select=\"selectPostsForBlog\"/&gt; 集合的嵌套结果至此,你可以猜测集合的嵌套结果是如何来工作的,因为它和关联完全相同,除了它应 用了一个“ofType”属性 First, let’s look at the SQL: 123456789101112&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, P.id as post_id, P.subject as post_subject, P.body as post_body, from Blog B left outer join Post P on B.id = P.blog_id where B.id = #&#123;id&#125;&lt;/select&gt; 我们又一次联合了博客表和文章表,而且关注于保证特性,结果列标签的简单映射。现 在用文章映射集合映射博客,可以简单写为: 123456789&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;id property=\"id\" column=\"blog_id\" /&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;collection property=\"posts\" ofType=\"Post\"&gt; &lt;id property=\"id\" column=\"post_id\"/&gt; &lt;result property=\"subject\" column=\"post_subject\"/&gt; &lt;result property=\"body\" column=\"post_body\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 同样,要记得 id 元素的重要性,如果你不记得了,请阅读上面的关联部分。 同样, 如果你引用更长的形式允许你的结果映射的更多重用, 你可以使用下面这个替代 的映射: 1234567891011&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;id property=\"id\" column=\"blog_id\" /&gt; &lt;result property=\"title\" column=\"blog_title\"/&gt; &lt;collection property=\"posts\" ofType=\"Post\" resultMap=\"blogPostResult\" columnPrefix=\"post_\"/&gt;&lt;/resultMap&gt;&lt;resultMap id=\"blogPostResult\" type=\"Post\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"subject\" column=\"subject\"/&gt; &lt;result property=\"body\" column=\"body\"/&gt;&lt;/resultMap&gt; 注意 这个对你所映射的内容没有深度,广度或关联和集合相联合的限制。当映射它们 时你应该在大脑中保留它们的表现。 你的应用在找到最佳方法前要一直进行的单元测试和性 能测试。好在 myBatis 让你后来可以改变想法,而不对你的代码造成很小(或任何)影响。 高级关联和集合映射是一个深度的主题。文档只能给你介绍到这了。加上一点联系,你 会很快清楚它们的用法。 鉴别器123&lt;discriminator javaType=\"int\" column=\"draft\"&gt; &lt;case value=\"1\" resultType=\"DraftPost\"/&gt;&lt;/discriminator&gt; 有时一个单独的数据库查询也许返回很多不同 (但是希望有些关联) 数据类型的结果集。 鉴别器元素就是被设计来处理这个情况的, 还有包括类的继承层次结构。 鉴别器非常容易理 解,因为它的表现很像 Java 语言中的 switch 语句。 定义鉴别器指定了 column 和 javaType 属性。 列是 MyBatis 查找比较值的地方。 JavaType 是需要被用来保证等价测试的合适类型(尽管字符串在很多情形下都会有用)。比如: 1234567891011121314&lt;resultMap id=\"vehicleResult\" type=\"Vehicle\"&gt; &lt;id property=\"id\" column=\"id\" /&gt; &lt;result property=\"vin\" column=\"vin\"/&gt; &lt;result property=\"year\" column=\"year\"/&gt; &lt;result property=\"make\" column=\"make\"/&gt; &lt;result property=\"model\" column=\"model\"/&gt; &lt;result property=\"color\" column=\"color\"/&gt; &lt;discriminator javaType=\"int\" column=\"vehicle_type\"&gt; &lt;case value=\"1\" resultMap=\"carResult\"/&gt; &lt;case value=\"2\" resultMap=\"truckResult\"/&gt; &lt;case value=\"3\" resultMap=\"vanResult\"/&gt; &lt;case value=\"4\" resultMap=\"suvResult\"/&gt; &lt;/discriminator&gt;&lt;/resultMap&gt; 在这个示例中, MyBatis 会从结果集中得到每条记录, 然后比较它的 vehicle 类型的值。 如果它匹配任何一个鉴别器的实例,那么就使用这个实例指定的结果映射。换句话说,这样 做完全是剩余的结果映射被忽略(除非它被扩展,这在第二个示例中讨论) 。如果没有任何 一个实例相匹配,那么 MyBatis 仅仅使用鉴别器块外定义的结果映射。所以,如果 carResult 按如下声明: 123&lt;resultMap id=\"carResult\" type=\"Car\"&gt; &lt;result property=\"doorCount\" column=\"door_count\" /&gt;&lt;/resultMap&gt; 那么只有 doorCount 属性会被加载。这步完成后完整地允许鉴别器实例的独立组,尽管 和父结果映射可能没有什么关系。这种情况下,我们当然知道 cars 和 vehicles 之间有关系, 如 Car 是一个 Vehicle 实例。因此,我们想要剩余的属性也被加载。我们设置的结果映射的 简单改变如下。 123&lt;resultMap id=\"carResult\" type=\"Car\" extends=\"vehicleResult\"&gt; &lt;result property=\"doorCount\" column=\"door_count\" /&gt;&lt;/resultMap&gt; 现在 vehicleResult 和 carResult 的属性都会被加载了。 尽管曾经有些人会发现这个外部映射定义会多少有一些令人厌烦之处。 因此还有另外一 种语法来做简洁的映射风格。比如: 1234567891011121314151617181920212223&lt;resultMap id=\"vehicleResult\" type=\"Vehicle\"&gt; &lt;id property=\"id\" column=\"id\" /&gt; &lt;result property=\"vin\" column=\"vin\"/&gt; &lt;result property=\"year\" column=\"year\"/&gt; &lt;result property=\"make\" column=\"make\"/&gt; &lt;result property=\"model\" column=\"model\"/&gt; &lt;result property=\"color\" column=\"color\"/&gt; &lt;discriminator javaType=\"int\" column=\"vehicle_type\"&gt; &lt;case value=\"1\" resultType=\"carResult\"&gt; &lt;result property=\"doorCount\" column=\"door_count\" /&gt; &lt;/case&gt; &lt;case value=\"2\" resultType=\"truckResult\"&gt; &lt;result property=\"boxSize\" column=\"box_size\" /&gt; &lt;result property=\"extendedCab\" column=\"extended_cab\" /&gt; &lt;/case&gt; &lt;case value=\"3\" resultType=\"vanResult\"&gt; &lt;result property=\"powerSlidingDoor\" column=\"power_sliding_door\" /&gt; &lt;/case&gt; &lt;case value=\"4\" resultType=\"suvResult\"&gt; &lt;result property=\"allWheelDrive\" column=\"all_wheel_drive\" /&gt; &lt;/case&gt; &lt;/discriminator&gt;&lt;/resultMap&gt; 要记得 这些都是结果映射, 如果你不指定任何结果, 那么 MyBatis 将会为你自动匹配列 和属性。所以这些例子中的大部分是很冗长的,而其实是不需要的。也就是说,很多数据库 是很复杂的,我们不太可能对所有示例都能依靠它。 自动映射正如你在前面一节看到的，在简单的场景下，MyBatis可以替你自动映射查询结果。 如果遇到复杂的场景，你需要构建一个result map。 但是在本节你将看到，你也可以混合使用这两种策略。 让我们到深一点的层面上看看自动映射是怎样工作的。 当自动映射查询结果时，MyBatis会获取sql返回的列名并在java类中查找相同名字的属性（忽略大小写）。 这意味着如果Mybatis发现了ID列和id属性，Mybatis会将ID的值赋给id。 通常数据库列使用大写单词命名，单词间用下划线分隔；而java属性一般遵循驼峰命名法。 为了在这两种命名方式之间启用自动映射，需要将 mapUnderscoreToCamelCase设置为true。 自动映射甚至在特定的result map下也能工作。在这种情况下，对于每一个result map,所有的ResultSet提供的列， 如果没有被手工映射，则将被自动映射。自动映射处理完毕后手工映射才会被处理。 在接下来的例子中， id 和 userName列将被自动映射， hashed_password 列将根据配置映射。 12345678&lt;select id=\"selectUsers\" resultMap=\"userResultMap\"&gt; select user_id as \"id\", user_name as \"userName\", hashed_password from some_table where id = #&#123;id&#125;&lt;/select&gt; 123&lt;resultMap id=\"userResultMap\" type=\"User\"&gt; &lt;result property=\"password\" column=\"hashed_password\"/&gt;&lt;/resultMap&gt; There are three auto-mapping levels: NONE - disables auto-mapping. Only manually mapped properties will be set. PARTIAL - will auto-map results except those that have nested result mappings defined inside (joins). FULL - auto-maps everything. The default value is PARTIAL, and it is so for a reason. When FULL is used auto-mapping will be performed when processing join results and joins retrieve data of several different entities in the same row hence this may result in undesired mappings. To understand the risk have a look at the following sample: 12345678&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; select B.id, B.title, A.username, from Blog B left outer join Author A on B.author_id = A.id where B.id = #&#123;id&#125;&lt;/select&gt; 1234567&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;association property=\"author\" resultMap=\"authorResult\"/&gt;&lt;/resultMap&gt;&lt;resultMap id=\"authorResult\" type=\"Author\"&gt; &lt;result property=\"username\" column=\"author_username\"/&gt;&lt;/resultMap&gt; With this result map both Blog and Author will be auto-mapped. But note that Author has an id property and there is a column named id in the ResultSet so Author’s id will be filled with Blog’s id, and that is not what you were expecting. So use the FULL option with caution. Regardless of the auto-mapping level configured you can enable or disable the automapping for an specific ResultMap by adding the attribute autoMapping to it: 123&lt;resultMap id=\"userResultMap\" type=\"User\" autoMapping=\"false\"&gt; &lt;result property=\"password\" column=\"hashed_password\"/&gt;&lt;/resultMap&gt; 缓存MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。MyBatis 3 中的缓存实现的很多改进都已经实现了,使得它更加强大而且易于配置。 默认情况下是没有开启缓存的,除了局部的 session 缓存,可以增强变现而且处理循环 依赖也是必须的。要开启二级缓存,你需要在你的 SQL 映射文件中添加一行: 1&lt;cache/&gt; 字面上看就是这样。这个简单语句的效果如下: 映射语句文件中的所有 select 语句将会被缓存。 映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。 缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。 根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。 缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。 缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。 所有的这些属性都可以通过缓存元素的属性来修改。比如: 12345&lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/&gt; 这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。 可用的收回策略有: LRU – 最近最少使用的:移除最长时间不被使用的对象。 FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认的是 LRU。 flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。 size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。 readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。 使用自定义缓存除了这些自定义缓存的方式, 你也可以通过实现你自己的缓存或为其他第三方缓存方案 创建适配器来完全覆盖缓存行为。 1&lt;cache type=\"com.domain.something.MyCustomCache\"/&gt; 这个示 例展 示了 如何 使用 一个 自定义 的缓 存实 现。type 属 性指 定的 类必 须实现 org.mybatis.cache.Cache 接口。这个接口是 MyBatis 框架中很多复杂的接口之一,但是简单 给定它做什么就行。 123456789public interface Cache &#123; String getId(); int getSize(); void putObject(Object key, Object value); Object getObject(Object key); boolean hasKey(Object key); Object removeObject(Object key); void clear();&#125; 要配置你的缓存, 简单和公有的 JavaBeans 属性来配置你的缓存实现, 而且是通过 cache 元素来传递属性, 比如, 下面代码会在你的缓存实现中调用一个称为 “setCacheFile(String file)” 的方法: 123&lt;cache type=\"com.domain.something.MyCustomCache\"&gt; &lt;property name=\"cacheFile\" value=\"/tmp/my-custom-cache.tmp\"/&gt;&lt;/cache&gt; 你可以使用所有简单类型作为 JavaBeans 的属性,MyBatis 会进行转换。 记得缓存配置和缓存实例是绑定在 SQL 映射文件的命名空间是很重要的。因此,所有 在相同命名空间的语句正如绑定的缓存一样。 语句可以修改和缓存交互的方式, 或在语句的 语句的基础上使用两种简单的属性来完全排除它们。默认情况下,语句可以这样来配置: 1234&lt;select ... flushCache=\"false\" useCache=\"true\"/&gt;&lt;insert ... flushCache=\"true\"/&gt;&lt;update ... flushCache=\"true\"/&gt;&lt;delete ... flushCache=\"true\"/&gt; 因为那些是默认的,你明显不能明确地以这种方式来配置一条语句。相反,如果你想改 变默认的行为,只能设置 flushCache 和 useCache 属性。比如,在一些情况下你也许想排除 从缓存中查询特定语句结果,或者你也许想要一个查询语句来刷新缓存。相似地,你也许有 一些更新语句依靠执行而不需要刷新缓存。 参照缓存回想一下上一节内容, 这个特殊命名空间的唯一缓存会被使用或者刷新相同命名空间内 的语句。也许将来的某个时候,你会想在命名空间中共享相同的缓存配置和实例。在这样的 情况下你可以使用 cache-ref 元素来引用另外一个缓存。 1&lt;cache-ref namespace=\"com.someone.application.data.SomeMapper\"/&gt;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://qinjiangbo.com/tags/mybatis/"},{"name":"ibatis","slug":"ibatis","permalink":"http://qinjiangbo.com/tags/ibatis/"}]},{"title":"MyBatis框架-3-映射配置文件","slug":"mybatis-framework-mapper-confguration-3","date":"2016-08-26T16:09:18.000Z","updated":"2018-04-02T09:00:56.000Z","comments":true,"path":"mybatis-framework-mapper-confguration-3.html","link":"","permalink":"http://qinjiangbo.com/mybatis-framework-mapper-confguration-3.html","excerpt":"","text":"XML 映射配置文件MyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。 properties这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。例如： 1234&lt;properties resource=\"org/mybatis/example/config.properties\"&gt; &lt;property name=\"username\" value=\"dev_user\"/&gt; &lt;property name=\"password\" value=\"F2Fa3!33TYyg\"/&gt;&lt;/properties&gt; 其中的属性就可以在整个配置文件中使用来替换需要动态配置的属性值。比如: 123456&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt;&lt;/dataSource&gt; 这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。 属性也可以被传递到 SqlSessionBuilder.build()方法中。例如： 12345SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, props);// ... or ...SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, environment, props); 如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载： 在 properties 元素体内指定的属性首先被读取。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。 最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。 因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的是 properties 属性中指定的属性。 settings这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。下表描述了设置中各项的意图、默认值等。 设置参数 描述 有效值 默认值 cacheEnabled 该配置影响的所有映射器中配置的缓存的全局开关。 true &#124; false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态 true &#124; false false aggressiveLazyLoading 当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载。 true &#124; false true multipleResultSetsEnabled 是否允许单一语句返回多结果集（需要兼容驱动）。 true &#124; false true useColumnLabel 使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。 true &#124; false true useGeneratedKeys 允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。 true &#124; false false autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。 NONE, PARTIAL, FULL PARTIAL defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 SIMPLE REUSE BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定驱动等待数据库响应的秒数。 Any positive integer Not Set (null) safeRowBoundsEnabled 允许在嵌套语句中使用分页（RowBounds）。 true &#124; false false mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 true &#124; false false localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 SESSION &#124; STATEMENT SESSION jdbcTypeForNull 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 JdbcType enumeration. Most common are: NULL, VARCHAR and OTHER OTHER lazyLoadTriggerMethods 指定哪个对象的方法触发一次延迟加载。 A method name list separated by commas equals,clone,hashCode,toString defaultScriptingLanguage 指定动态 SQL 生成的默认语言。 A type alias or fully qualified class name. org.apache.ibatis.scripting.xmltags.XMLDynamicLanguageDriver callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。 true &#124; false false logPrefix 指定 MyBatis 增加到日志名称的前缀。 Any String Not set logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J &#124; LOG4J &#124; LOG4J2 &#124; JDK_LOGGING &#124; COMMONS_LOGGING &#124; STDOUT_LOGGING &#124; NO_LOGGING Not set proxyFactory 指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。 CGLIB &#124; JAVASSIST CGLIB 一个配置完整的 settings 元素的示例如下： 123456789101112131415&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt;&lt;/settings&gt; typeAliases类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。例如: 12345678&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/&gt; &lt;typeAlias alias=\"Comment\" type=\"domain.blog.Comment\"/&gt; &lt;typeAlias alias=\"Post\" type=\"domain.blog.Post\"/&gt; &lt;typeAlias alias=\"Section\" type=\"domain.blog.Section\"/&gt; &lt;typeAlias alias=\"Tag\" type=\"domain.blog.Tag\"/&gt;&lt;/typeAliases&gt; 当这样配置时，Blog可以用在任何使用domain.blog.Blog的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如: 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。看下面的例子： 1234@Alias(\"author\")public class Author &#123; ...&#125; 已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，需要注意的是由基本类型名称重复导致的特殊处理。 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator typeHandlers无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。 类型处理器 Java 类型 JDBC 类型 BooleanTypeHandler java.lang.Boolean, boolean 数据库兼容的 BOOLEAN ByteTypeHandler java.lang.Byte, byte 数据库兼容的 NUMERIC 或 BYTE ShortTypeHandler java.lang.Short, short 数据库兼容的 NUMERIC 或 SHORT INTEGER IntegerTypeHandler java.lang.Integer, int 数据库兼容的 NUMERIC 或 INTEGER LongTypeHandler java.lang.Long, long 数据库兼容的 NUMERIC 或 LONG INTEGER FloatTypeHandler java.lang.Float, float 数据库兼容的 NUMERIC 或 FLOAT DoubleTypeHandler java.lang.Double, double 数据库兼容的 NUMERIC 或 DOUBLE BigDecimalTypeHandler java.math.BigDecimal 数据库兼容的 NUMERIC 或 DECIMAL StringTypeHandler java.lang.String CHAR, VARCHAR ClobTypeHandler java.lang.String CLOB, LONGVARCHAR NStringTypeHandler java.lang.String NVARCHAR, NCHAR NClobTypeHandler java.lang.String NCLOB ByteArrayTypeHandler byte[] 数据库兼容的字节流类型 BlobTypeHandler byte[] BLOB, LONGVARBINARY DateTypeHandler java.util.Date TIMESTAMP DateOnlyTypeHandler java.util.Date DATE TimeOnlyTypeHandler java.util.Date TIME SqlTimestampTypeHandler java.sql.Timestamp TIMESTAMP SqlDateTypeHandler java.sql.Date DATE SqlTimeTypeHandler java.sql.Time TIME ObjectTypeHandler Any OTHER 或未指定类型 EnumTypeHandler Enumeration Type VARCHAR-任何兼容的字符串类型，存储枚举的名称（而不是索引） EnumOrdinalTypeHandler Enumeration Type 任何兼容的 NUMERIC 或 DOUBLE 类型，存储枚举的索引（而不是名称）。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个 JDBC 类型。比如： 123456789101112131415161718192021222324// ExampleTypeHandler.java@MappedJdbcTypes(JdbcType.VARCHAR)public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123; ps.setString(i, parameter); &#125; @Override public String getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return rs.getString(columnName); &#125; @Override public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return rs.getString(columnIndex); &#125; @Override public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return cs.getString(columnIndex); &#125;&#125; 1234&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=\"org.mybatis.example.ExampleTypeHandler\"/&gt;&lt;/typeHandlers&gt; 使用这个的类型处理器将会覆盖已经存在的处理 Java 的 String 类型属性和 VARCHAR 参数及结果的类型处理器。 要注意 MyBatis 不会窥探数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明那是 VARCHAR 类型的字段， 以使其能够绑定到正确的类型处理器上。 这是因为：MyBatis 直到语句被执行才清楚数据类型。 通过类型处理器的泛型，MyBatis 可以得知该类型处理器处理的 Java 类型，不过这种行为可以通过两种方法改变： 在类型处理器的配置元素（typeHandler element）上增加一个 javaType 属性（比如：javaType=&quot;String&quot;）； 在类型处理器的类上（TypeHandler class）增加一个 @MappedTypes 注解来指定与其关联的 Java 类型列表。 如果在 javaType 属性中也同时指定，则注解方式将被忽略。 可以通过两种方式来指定被关联的 JDBC 类型： 在类型处理器的配置元素上增加一个 javaType 属性（比如：javaType=”VARCHAR”）； 在类型处理器的类上（TypeHandler class）增加一个 @MappedJdbcTypes 注解来指定与其关联的 JDBC 类型列表。 如果在 javaType 属性中也同时指定，则注解方式将被忽略。 最后，可以让 MyBatis 为你查找类型处理器： 1234&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt; &lt;package name=\"org.mybatis.example\"/&gt;&lt;/typeHandlers&gt; 注意在使用自动检索（autodiscovery）功能的时候，只能通过注解方式来指定 JDBC 的类型。 你能创建一个泛型类型处理器，它可以处理多于一个类。为达到此目的， 需要增加一个接收该类作为参数的构造器，这样在构造一个类型处理器的时候 MyBatis 就会传入一个具体的类。 12345678910//GenericTypeHandler.javapublic class GenericTypeHandler&lt;E extends MyObject&gt; extends BaseTypeHandler&lt;E&gt; &#123; private Class&lt;E&gt; type; public GenericTypeHandler(Class&lt;E&gt; type) &#123; if (type == null) throw new IllegalArgumentException(\"Type argument cannot be null\"); this.type = type; &#125; ... EnumTypeHandler 和 EnumOrdinalTypeHandler 都是泛型类型处理器（generic TypeHandlers）， 我们将会在接下来的部分详细探讨。 处理枚举类型若想映射枚举类型 Enum，则需要从 EnumTypeHandler 或者 EnumOrdinalTypeHandler 中选一个来使用。 比如说我们想存储取近似值时用到的舍入模式。默认情况下，MyBatis 会利用 EnumTypeHandler 来把 Enum 值转换成对应的名字。 注意 EnumTypeHandler 在某种意义上来说是比较特别的，其他的处理器只针对某个特定的类，而它不同，它会处理任意继承了 Enum 的类。 不过，我们可能不想存储名字，相反我们的 DBA 会坚持使用整形值代码。那也一样轻而易举： 在配置文件中把 EnumOrdinalTypeHandler 加到 typeHandlers 中即可， 这样每个 RoundingMode 将通过他们的序数值来映射成对应的整形。 1234&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.EnumOrdinalTypeHandler\" javaType=\"java.math.RoundingMode\"/&gt;&lt;/typeHandlers&gt; 但是怎样能将同样的 Enum 既映射成字符串又映射成整形呢？ 自动映射器（auto-mapper）会自动地选用 EnumOrdinalTypeHandler 来处理， 所以如果我们想用普通的 EnumTypeHandler，就非要为那些 SQL 语句显式地设置要用到的类型处理器不可。 （下一节才开始讲映射器文件，所以如果是首次阅读该文档，你可能需要先越过这一步，过会再来看。） 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.apache.ibatis.submitted.rounding.Mapper\"&gt; &lt;resultMap type=\"org.apache.ibatis.submitted.rounding.User\" id=\"usermap\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;result column=\"funkyNumber\" property=\"funkyNumber\"/&gt; &lt;result column=\"roundingMode\" property=\"roundingMode\"/&gt; &lt;/resultMap&gt; &lt;select id=\"getUser\" resultMap=\"usermap\"&gt; select * from users &lt;/select&gt; &lt;insert id=\"insert\"&gt; insert into users (id, name, funkyNumber, roundingMode) values ( #&#123;id&#125;, #&#123;name&#125;, #&#123;funkyNumber&#125;, #&#123;roundingMode&#125; ) &lt;/insert&gt; &lt;resultMap type=\"org.apache.ibatis.submitted.rounding.User\" id=\"usermap2\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;result column=\"funkyNumber\" property=\"funkyNumber\"/&gt; &lt;result column=\"roundingMode\" property=\"roundingMode\" typeHandler=\"org.apache.ibatis.type.EnumTypeHandler\"/&gt; &lt;/resultMap&gt; &lt;select id=\"getUser2\" resultMap=\"usermap2\"&gt; select * from users2 &lt;/select&gt; &lt;insert id=\"insert2\"&gt; insert into users2 (id, name, funkyNumber, roundingMode) values ( #&#123;id&#125;, #&#123;name&#125;, #&#123;funkyNumber&#125;, #&#123;roundingMode, typeHandler=org.apache.ibatis.type.EnumTypeHandler&#125; ) &lt;/insert&gt;&lt;/mapper&gt; 注意，这里的 select 语句强制使用 resultMap 来代替 resultType。 对象工厂（objectFactory）MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。比如： 1234567891011121314// ExampleObjectFactory.javapublic class ExampleObjectFactory extends DefaultObjectFactory &#123; public Object create(Class type) &#123; return super.create(type); &#125; public Object create(Class type, List&lt;Class&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) &#123; return super.create(type, constructorArgTypes, constructorArgs); &#125; public void setProperties(Properties properties) &#123; super.setProperties(properties); &#125; public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type) &#123; return Collection.class.isAssignableFrom(type); &#125;&#125; 1234&lt;!-- mybatis-config.xml --&gt;&lt;objectFactory type=\"org.mybatis.example.ExampleObjectFactory\"&gt; &lt;property name=\"someProperty\" value=\"100\"/&gt;&lt;/objectFactory&gt; ObjectFactory 接口很简单，它包含两个创建用的方法，一个是处理默认构造方法的，另外一个是处理带参数的构造方法的。 最后，setProperties 方法可以被用来配置 ObjectFactory，在初始化你的 ObjectFactory 实例后， objectFactory 元素体中定义的属性会被传递给 setProperties 方法。 插件（plugins）MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括： Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) 这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 的发行包中的源代码。 假设你想做的不仅仅是监控方法的调用，那么你应该很好的了解正在重写的方法的行为。 因为如果在试图修改或重写已有方法的行为的时候，你很可能在破坏 MyBatis 的核心模块。 这些都是更低层的类和方法，所以使用插件的时候要特别当心。 通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定了想要拦截的方法签名即可。 123456789101112131415// ExamplePlugin.java@Intercepts(&#123;@Signature( type= Executor.class, method = \"update\", args = &#123;MappedStatement.class,Object.class&#125;)&#125;)public class ExamplePlugin implements Interceptor &#123; public Object intercept(Invocation invocation) throws Throwable &#123; return invocation.proceed(); &#125; public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; public void setProperties(Properties properties) &#123; &#125;&#125; 123456&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt; &lt;plugin interceptor=\"org.mybatis.example.ExamplePlugin\"&gt; &lt;property name=\"someProperty\" value=\"100\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。 NOTE 覆盖配置类 除了用插件来修改 MyBatis 核心行为之外，还可以通过完全覆盖配置类来达到目的。只需继承后覆盖其中的每个方法，再把它传递到 sqlSessionFactoryBuilder.build(myConfig) 方法即可。再次重申，这可能会严重影响 MyBatis 的行为，务请慎之又慎。 配置环境（environments）MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同 Schema 的多个生产数据库， 想使用相同的 SQL 映射。许多类似的用例。 不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。 所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单： 每个数据库对应一个 SqlSessionFactory 实例 为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是： 12SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, environment);SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, environment,properties); 如果忽略了环境参数，那么默认环境将会被加载，如下所示： 12SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader);SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader,properties); 环境元素定义了如何配置环境。 12345678910111213&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 注意这里的关键点: 默认的环境 ID（比如:default=”development”）。 每个 environment 元素定义的环境 ID（比如:id=”development”）。 事务管理器的配置（比如:type=”JDBC”）。 数据源的配置（比如:type=”POOLED”）。 默认的环境和环境 ID 是一目了然的。随你怎么命名，只要保证默认环境要匹配其中一个环境ID。 事务管理器（transactionManager） 在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）： JDBC – 这个配置就是直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务范围。 MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。例如: 123&lt;transactionManager type=\"MANAGED\"&gt; &lt;property name=\"closeConnection\" value=\"false\"/&gt;&lt;/transactionManager&gt; NOTE 如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。 这两种事务管理器类型都不需要任何属性。它们不过是类型别名，换句话说，你可以使用 TransactionFactory 接口的实现类的完全限定名或类型别名代替它们。 12345public interface TransactionFactory &#123; void setProperties(Properties props); Transaction newTransaction(Connection conn); Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit); &#125; 任何在 XML 中配置的属性在实例化之后将会被传递给 setProperties() 方法。你也需要创建一个 Transaction 接口的实现类，这个接口也很简单： 123456public interface Transaction &#123; Connection getConnection() throws SQLException; void commit() throws SQLException; void rollback() throws SQLException; void close() throws SQLException;&#125; 使用这两个接口，你可以完全自定义 MyBatis 对事务的处理。 数据源（dataSource） dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 许多 MyBatis 的应用程序将会按示例中的例子来配置数据源。然而它并不是必须的。要知道为了方便使用延迟加载，数据源才是必须的。 有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）： UNPOOLED– 这个数据源的实现只是每次被请求时打开和关闭连接。虽然一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择。 不同的数据库在这方面表现也是不一样的，所以对某些数据库来说使用连接池并不重要，这个配置也是理想的。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性： driver – 这是 JDBC 驱动的 Java 类的完全限定名（并不是JDBC驱动中可能包含的数据源类）。 url – 这是数据库的 JDBC URL 地址。 username – 登录数据库的用户名。 password – 登录数据库的密码。 defaultTransactionIsolationLevel – 默认的连接事务隔离级别。 作为可选项，你也可以传递属性给数据库驱动。要这样做，属性的前缀为“driver.”，例如： driver.encoding=UTF8 这将通过DriverManager.getConnection(url,driverProperties)方法传递值为 UTF8 的 encoding 属性给数据库驱动。 POOLED – 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 除了上述提到 UNPOOLED 下的属性外，会有更多属性用来配置 POOLED 的数据源： poolMaximumActiveConnections – 在任意时间可以存在的活动（也就是正在使用）连接数量，默认值：10 poolMaximumIdleConnections – 任意时间可能存在的空闲连接数。 poolMaximumCheckoutTime – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒） poolTimeToWait – 这是一个底层设置，如果获取连接花费的相当长的时间，它会给连接池打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败），默认值：20000 毫秒（即 20 秒）。 poolPingQuery – 发送到数据库的侦测查询，用来检验连接是否处在正常工作秩序中并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息。 poolPingEnabled – 是否启用侦测查询。若开启，也必须使用一个可执行的 SQL 语句设置 poolPingQuery 属性（最好是一个非常快的 SQL），默认值：false。 poolPingConnectionsNotUsedFor – 配置 poolPingQuery 的使用频度。这可以被设置成匹配具体的数据库连接超时时间，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。 JNDI – 这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种数据源配置只需要两个属性： initial_context – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么 data_source 属性将会直接从 InitialContext 中寻找。 data_source – 这是引用数据源实例位置的上下文的路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。 和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给初始上下文。比如： env.encoding=UTF8 这就会在初始上下文（InitialContext）实例化时往它的构造方法传递值为 UTF8 的 encoding 属性。 通过需要实现接口 org.apache.ibatis.datasource.DataSourceFactory ， 也可使用任何第三方数据源，： 1234public interface DataSourceFactory &#123; void setProperties(Properties props); DataSource getDataSource();&#125; org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory 可被用作父类来构建新的数据源适配器，比如下面这段插入 C3P0 数据源所必需的代码： 123456789import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;import com.mchange.v2.c3p0.ComboPooledDataSource; public class C3P0DataSourceFactory extends UnpooledDataSourceFactory &#123; public C3P0DataSourceFactory() &#123; this.dataSource = new ComboPooledDataSource(); &#125;&#125; 为了令其工作，为每个需要 MyBatis 调用的 setter 方法中增加一个属性。下面是一个可以连接至 PostgreSQL 数据库的例子： 123456&lt;dataSource type=\"org.myproject.C3P0DataSourceFactory\"&gt; &lt;property name=\"driver\" value=\"org.postgresql.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:postgresql:mydb\"/&gt; &lt;property name=\"username\" value=\"postgres\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt;&lt;/dataSource&gt; databaseIdProviderMyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。 MyBatis 会加载不带 databaseId属性和带有匹配当前数据库 databaseId 属性的所有语句。 如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃。 为支持多厂商特性只要像下面这样在 mybatis-config.xml 文件中加入 databaseIdProvider 即可： 1&lt;databaseIdProvider type=\"DB_VENDOR\" /&gt; 这里的 DB_VENDOR 会通过 DatabaseMetaData#getDatabaseProductName() 返回的字符串进行设置。 由于通常情况下这个字符串都非常长而且相同产品的不同版本会返回不同的值，所以最好通过设置属性别名来使其变短，如下： 12345&lt;databaseIdProvider type=\"DB_VENDOR\"&gt; &lt;property name=\"SQL Server\" value=\"sqlserver\"/&gt; &lt;property name=\"DB2\" value=\"db2\"/&gt; &lt;property name=\"Oracle\" value=\"oracle\" /&gt;&lt;/databaseIdProvider&gt; 在有 properties 时，DB_VENDOR databaseIdProvider 的将被设置为第一个能匹配数据库产品名称的属性键对应的值，如果没有匹配的属性将会设置为 “null”。 在这个例子中，如果 getDatabaseProductName() 返回“Oracle (DataDirect)”，databaseId 将被设置为“oracle”。 你可以通过实现接口 org.apache.ibatis.mapping.DatabaseIdProvider 并在 mybatis-config.xml 中注册来构建自己的 DatabaseIdProvider： 1234public interface DatabaseIdProvider &#123; void setProperties(Properties p); String getDatabaseId(DataSource dataSource) throws SQLException;&#125; 映射器（mappers）既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。例如： 123456&lt;!-- Using classpath relative resources --&gt;&lt;mappers&gt; &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/&gt; &lt;mapper resource=\"org/mybatis/builder/BlogMapper.xml\"/&gt; &lt;mapper resource=\"org/mybatis/builder/PostMapper.xml\"/&gt;&lt;/mappers&gt; 123456&lt;!-- Using url fully qualified paths --&gt;&lt;mappers&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;mapper url=\"file:///var/mappers/BlogMapper.xml\"/&gt; &lt;mapper url=\"file:///var/mappers/PostMapper.xml\"/&gt;&lt;/mappers&gt; 123456&lt;!-- Using mapper interface classes --&gt;&lt;mappers&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;mapper class=\"org.mybatis.builder.BlogMapper\"/&gt; &lt;mapper class=\"org.mybatis.builder.PostMapper\"/&gt;&lt;/mappers&gt; 1234&lt;!-- Register all interfaces in a package as mappers --&gt;&lt;mappers&gt; &lt;package name=\"org.mybatis.builder\"/&gt;&lt;/mappers&gt; 这些配置会告诉了 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了，也就是接下来我们要讨论的。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://qinjiangbo.com/tags/mybatis/"},{"name":"ibatis","slug":"ibatis","permalink":"http://qinjiangbo.com/tags/ibatis/"}]},{"title":"MyBatis框架-2-构建SqlSessionFactory","slug":"mybatis-framework-session-factory-2","date":"2016-08-26T16:01:04.000Z","updated":"2018-04-02T09:01:01.000Z","comments":true,"path":"mybatis-framework-session-factory-2.html","link":"","permalink":"http://qinjiangbo.com/mybatis-framework-session-factory-2.html","excerpt":"","text":"安装MyBatis要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于 classpath 中即可。 如果使用 Maven 来构建项目，则需将下面的 dependency 代码置于 pom.xml 文件中： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; 从 XML 中构建 SqlSessionFactory每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流(InputStream)实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。 123String resource = \"org/mybatis/example/mybatis-config.xml\";InputStream inputStream = Resources.getResourceAsStream(resource);sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务范围和控制方式的事务管理器（TransactionManager）。XML 配置文件的详细内容后面再探讨，这里先给出一个简单的示例： 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 当然，还有很多可以在XML 文件中进行配置，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，用来验证 XML 文档正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则是包含一组 mapper 映射器（这些 mapper 的 XML 文件包含了 SQL 代码和映射定义信息）。 不使用 XML 构建 SqlSessionFactory如果你更愿意直接从 Java 程序而不是 XML 文件中创建 configuration，或者创建你自己的 configuration 构建器，MyBatis 也提供了完整的配置类，提供所有和 XML 文件相同功能的配置项。 123456DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();TransactionFactory transactionFactory = new JdbcTransactionFactory();Environment environment = new Environment(\"development\", transactionFactory, dataSource);Configuration configuration = new Configuration(environment);configuration.addMapper(BlogMapper.class);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); 注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射语句的注解从而避免了 XML 文件的依赖。不过，由于 Java 注解的一些限制加之某些 MyBatis 映射的复杂性，XML 映射对于大多数高级映射（比如：嵌套 Join 映射）来说仍然是必须的。有鉴于此，如果存在一个对等的 XML 配置文件的话，MyBatis 会自动查找并加载它（这种情况下， BlogMapper.xml 将会基于类路径和 BlogMapper.class 的类名被加载进来）。具体细节稍后讨论。 从 SqlSessionFactory 中获取 SqlSession既然有了 SqlSessionFactory ，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如： 123456SqlSession session = sqlSessionFactory.openSession();try &#123; Blog blog = (Blog) session.selectOne(\"org.mybatis.example.BlogMapper.selectBlog\", 101);&#125; finally &#123; session.close();&#125; 诚然这种方式能够正常工作，并且对于使用旧版本 MyBatis 的用户来说也比较熟悉，不过现在有了一种更直白的方式。使用对于给定语句能够合理描述参数和返回值的接口（比如说BlogMapper.class），你现在不但可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。 例如： 1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; finally &#123; session.close();&#125; 现在我们来探究一下这里到底是怎么执行的。 探究已映射的 SQL 语句现在，或许你很想知道 SqlSession 和 Mapper 到底执行了什么操作，而 SQL 语句映射是个相当大的话题，可能会占去文档的大部分篇幅。不过为了让你能够了解个大概，这里会给出几个例子。 在上面提到的两个例子中，一个语句应该是通过 XML 定义，而另外一个则是通过注解定义。先看 XML 定义这个，事实上 MyBatis 提供的全部特性可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。如果你以前用过 MyBatis，这个概念应该会比较熟悉。不过 XML 映射文件已经有了很多的改进，随着文档的进行会愈发清晰。这里给出一个基于 XML 映射语句的示例，它应该可以满足上述示例中 SqlSession 的调用。 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.mybatis.example.BlogMapper\"&gt; &lt;select id=\"selectBlog\" resultType=\"Blog\"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 对于这个简单的例子来说似乎有点小题大做了，但实际上它是非常轻量级的。在一个 XML 映射文件中，你想定义多少个映射语句都是可以的，这样下来，XML 头部和文档类型声明占去的部分就显得微不足道了。文件的剩余部分具有很好的自解释性。在命名空间“com.mybatis.example.BlogMapper”中定义了一个名为“selectBlog”的映射语句，这样它就允许你使用指定的完全限定名“org.mybatis.example.BlogMapper.selectBlog”来调用映射语句，就像上面的例子中做的那样： 1Blog blog = (Blog) session.selectOne(\"org.mybatis.example.BlogMapper.selectBlog\", 101); 你可能注意到这和使用完全限定名调用 Java 对象的方法是相似的，之所以这样做是有原因的。这个命名可以直接映射到在命名空间中同名的 Mapper 类，并在已映射的 select 语句中的名字、参数和返回类型匹配成方法。这样你就可以向上面那样很容易地调用这个对应 Mapper 接口的方法。不过让我们再看一遍下面的例子： 12BlogMapper mapper = session.getMapper(BlogMapper.class);Blog blog = mapper.selectBlog(101); 第二种方法有很多优势，首先它不是基于字符串常量的，就会更安全；其次，如果你的 IDE 有代码补全功能，那么你可以在有了已映射 SQL 语句的基础之上利用这个功能。 提示命名空间的一点注释 命名空间（Namespaces）在之前版本的 MyBatis 中是可选的，容易引起混淆因此是没有益处的。现在的命名空间则是必须的，目的是希望能比只是简单的使用更长的完全限定名来区分语句更进一步。 命名空间使得你所见到的接口绑定成为可能，尽管你觉得这些东西未必用得上，你还是应该遵循这里的规定以防哪天你改变了主意。出于长远考虑，使用命名空间，并将它置于合适的 Java 包命名空间之下，你将拥有一份更加整洁的代码并提高了 MyBatis 的可用性。 命名解析：为了减少输入量，MyBatis 对所有的命名配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。 完全限定名（比如“com.mypackage.MyMapper.selectAllThings”）将被直接查找并且找到即用。 短名称（比如“selectAllThings”）如果全局唯一也可以作为一个单独的引用。如果不唯一，有两个或两个以上的相同名称（比如“com.foo.selectAllThings ”和“com.bar.selectAllThings”），那么使用时就会收到错误报告说短名称是不唯一的，这种情况下就必须使用完全限定名。 对于像 BlogMapper 这样的映射器类（Mapper class）来说，还有另一招来处理。它们的映射的语句可以不需要用 XML 来做，取而代之的是可以使用 Java 注解。比如，上面的 XML 示例可被替换如下： 12345package org.mybatis.example;public interface BlogMapper &#123; @Select(\"SELECT * FROM blog WHERE id = #&#123;id&#125;\") Blog selectBlog(int id);&#125; 对于简单语句来说，注解使代码显得更加简洁，然而 Java 注解对于稍微复杂的语句就会力不从心并且会显得更加混乱。因此，如果你需要做很复杂的事情，那么最好使用 XML 来映射语句。 选择何种方式以及映射语句的定义的一致性对你来说有多重要这些完全取决于你和你的团队。换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换。 范围（Scope）和生命周期理解我们目前已经讨论过的不同范围和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。 提示 对象生命周期和依赖注入框架 依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器（mapper）并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。如果对如何通过依赖注入框架来使用 MyBatis 感兴趣可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。 SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳范围是方法范围（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。 SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳范围是应用范围。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的范围是请求或方法范围。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理范围中，比如 Serlvet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的范围中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式： 123456SqlSession session = sqlSessionFactory.openSession();try &#123; // do work&#125; finally &#123; session.close();&#125; 在你的所有的代码中一致性地使用这种模式来保证所有数据库资源都能被正确地关闭。 映射器实例（Mapper Instances）映射器是创建用来绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，映射器实例的最大范围是和 SqlSession 相同的，因为它们都是从 SqlSession 里被请求的。尽管如此，映射器实例的最佳范围是方法范围。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求范围（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个范围上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法范围（method scope）内。下面的示例就展示了这个实践： 1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); // do work&#125; finally &#123; session.close();&#125;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://qinjiangbo.com/tags/mybatis/"},{"name":"ibatis","slug":"ibatis","permalink":"http://qinjiangbo.com/tags/ibatis/"}]},{"title":"MyBatis框架-1-简介","slug":"mybatis-framework-introduction-1","date":"2016-08-26T15:57:53.000Z","updated":"2018-04-02T09:00:47.000Z","comments":true,"path":"mybatis-framework-introduction-1.html","link":"","permalink":"http://qinjiangbo.com/mybatis-framework-introduction-1.html","excerpt":"","text":"什么是 MyBatis ？MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://qinjiangbo.com/tags/mybatis/"},{"name":"ibatis","slug":"ibatis","permalink":"http://qinjiangbo.com/tags/ibatis/"}]},{"title":"GitHub Pages入门指南","slug":"getting-started-with-github-pages","date":"2016-08-25T15:43:17.000Z","updated":"2016-11-04T01:25:27.000Z","comments":true,"path":"getting-started-with-github-pages.html","link":"","permalink":"http://qinjiangbo.com/getting-started-with-github-pages.html","excerpt":"","text":"Github Pages是能通过Github轻松发布以及托管的公开网页。最快上手并且使用的方式就是通过页面自动生成器为我们生成一些HTML和CSS文件。然后你就可以通过浏览器或者本机电脑远程修改Github Pages里面的内容以及样式。 创建你自己的网站一旦你已经登录了，你就可以开始创建一个上手的资源库。 在新的资源库的页面上，你需要指定这个资源库的名字从而生成你的网站。 你的网站的HTML和CSS资源将会被存放在名为username.github.io 的资源库中（其中 “username”是你的github用户名）。为了得到一组最基础的HTML和CSS资源，你需要打开设置标签页然后开启页面自动生成器功能。 如果你滚动鼠标到设置页面，你就会看到Automatic Page Generator这样一个按钮。通过点击这个按钮，你就开始自动生成这个网站的内容了。 一旦你已经点击了这个按钮，你将会被重定向到这个生成步骤的第一步：内容。你可以暂时保持默认的内容，之后可以修改这个内容。然后让我们继续，点击底部的按钮“Continue to Layouts”。 现在，你需要选择你的主题。这部分不需要太多思考，选择你喜欢的主题即可，如果想改后面再重新更新主题内容。当你在这个页面看了一圈终于找到你喜欢的主题之后，点击“Publish”来结束自动生成的过程。 一旦你点击了发布（Publish），Github做了所有将游客引流到username.github.io去查看你网站的工作。这可能会花费十分钟左右。一旦这个时间一过，你就可以打开你浏览器的新标签页面去查看你的网站！ 制造变化你要做的第一件事就是将你的首页的标题给移除掉，并且添加一个更为友好的标题。因为这是一个非常迅速的修改，而且是你的第一条修改，所以建议你将这个变化记录到master分支上。 如果你点击了index.html去导航这个文件，你也可以直接点击EDIT来编辑它。 让我们找到这个文件中说到的username.github.io然后将其更改为更为友好的标题。对于Octocat而言，我会将其更改为”欢迎来到Octocat的主页！”。你也可以这样做，只不过需要将username改为你的名字。在这个标题下面，你应该添加一条关于这个页面的目的的消息并且用你的话描述。 当你做了这个小的改变之后，将鼠标滚动到页面的最下面，然后执行你的第一次提交。你有两个地方去写关于这个变化：一个是主题，另一个是拓展描述。这个拓展描述是可选的，所以，让我们在这个主题里面留一些描述性的信息。 当你一切就绪之后，点击“Commit Changes” 然后你的提交将会在几秒钟生效！ 下一步仅仅是因为你在你的项目中做了一些改变是远远不够的！你需要其他的指南知道你如何向其他的项目提交代码。 GitHub Flow Contributing to Open Source","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://qinjiangbo.com/tags/Git/"},{"name":"Cheat Sheet","slug":"Cheat-Sheet","permalink":"http://qinjiangbo.com/tags/Cheat-Sheet/"}]},{"title":"GitHub Git 备忘单","slug":"github-git-remainder","date":"2016-08-25T15:04:40.000Z","updated":"2016-08-26T03:43:40.000Z","comments":true,"path":"github-git-remainder.html","link":"","permalink":"http://qinjiangbo.com/github-git-remainder.html","excerpt":"","text":"Git是一个开源的分布式版本控制系统，方便你在笔记本或桌面端进行GitHub的操作，这个备忘单总结了常用的Git命令行指令，以便快速查询。 安装GitGitHub提供了包含图形界面的桌面客户端，通过客户端可以完成大部分常用的仓库操作，同时可以自动更新Git的命令行版本，以适应新的场景。 GitHub for Windowshttp://windows.github.com GitHub for Machttp://mac.github.com GitHub的Linux和POSIX版本可以在官方的Git SCM网站上获取。 Git 全平台版http://git-scm.com 配置工具对所有本地仓库的用户信息进行配置 $ git config --global user.name &quot;[name]&quot; 对你的commit操作设置关联的用户名 $ git config --global user.email &quot;[email address]&quot; 对你的commit操作设置关联的邮箱地址 创建仓库创建一个新的仓库或者从一个现有的链接获取仓库 $ git init [project-name]创建一个本地的仓库，并设置名字 $ git clone [url]下载一个项目以及它所有的版本历史 重构文件重定位并移除版本文件 $ git rm [file]从工作目录中删除文件并暂存此删除 $ git rm --cached [file]从版本控制中移除文件，并在本地保存文件 $ git mv [file-original] [file-renamed]改变文件名并准备commit 停止追踪不包含临时文件和路径 *.log build/ temp-* 文本文件.gitignore可以防止一些特定的文件进入到版本控制中 $ git ls-files --other --ignored --exclude-standard列出所有项目中忽略的文件 保存临时更改暂存一些未完成的更改 $ git stash临时存储所有修改的已跟踪文件 $ git stash pop重新存储所有最近被stash的文件 $ git stash list列出所有被stash的更改 $ git stash drop放弃所有最近stash的更改 更改检查已有的编辑并执行commit操作 $ git status列出所有新建或者更改的文件，这些文件需要被commit $ git diff展示那些没有暂存文件的差异 $ git add [file]将文件进行快照处理用于版本控制 $ git diff --staged展示暂存文件与最新版本之间的不同 $ git reset [file]将文件移除暂存区，但是保留其内容 $ git commit -m [commit-message]将文件快照永久地记录在版本历史中 批量更改命名一系列commit以及合并已完成的工作 $ git branch 列出当前仓库中所有的本地分支 $ git branch [branch-name]建立一个新分支 $ git checkout [branch-name]切换到一个特定的分支上并更新工作目录 $ git merge [branch-name]合并特定分支的历史到当前分支 $ git branch -d [branch-name]删除特定的分支 查阅历史浏览并检查项目文件的发展 $ git log 列出当前分支的版本历史 $ git log --follow [file]列出文件的版本历史，包括重命名 $ git diff [branch-first] ... [branch-last]展示两个不同分支之间的差异 $ git show [commit]输出元数据以及特定commit的内容变化 撤销commit擦除错误并更改历史 $ git reset [commit]撤销所有[commit]后的的commit，在本地保存更改 $ git reset --hard [commit]放弃所有更改并回到某个特定的commit 同步更改注册一个远程的链接，交换仓库的版本历史 $ git fetch [remote]下载远程仓库的所有历史 $ git merge [remote] / [branch]合并远程分支到当前本地分支 $ git push [remote] [branch]上传所有本地分支commit到GitHub上 $ git pull下载书签历史并合并更改","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://qinjiangbo.com/tags/Git/"},{"name":"Cheat Sheet","slug":"Cheat-Sheet","permalink":"http://qinjiangbo.com/tags/Cheat-Sheet/"}]},{"title":"Could not read from remote repository","slug":"could-not-read-from-remote-repository","date":"2016-08-20T04:28:06.000Z","updated":"2016-08-25T15:10:30.000Z","comments":true,"path":"could-not-read-from-remote-repository.html","link":"","permalink":"http://qinjiangbo.com/could-not-read-from-remote-repository.html","excerpt":"","text":"问题描述12345Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 问题分析其实问题描述中已经非常清楚了，Permission denied (publickey)。就是公钥权限问题，一般git不管是上传还是更新文件都需要验证这个公钥，如果公钥不存在或者公钥的权限不够，都会导致更新或者上传失败。可以登录github检查SSH keys的权限。 问题解决需要生成一个公钥，并将其添加到github的SSH keys里面，注意，不是项目的SSH keys，是整个账号的SSH keys。 终端代码： 123456789101112131415161718192021222324ssh-keygen -t rsa -C \"qinjiangbo\"Generating public/private rsa key pair.Enter file in which to save the key (/Users/Richard/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/Richard/.ssh/id_rsa.Your public key has been saved in /Users/Richard/.ssh/id_rsa.pub.The key fingerprint is:SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx qinjiangboThe key's randomart image is:+---[RSA 2048]----+| .. .oB==. || .o ..==+.B || oo.. o+oo= * || . .+ ..+oB E . || . .o. S* = = || + . . * || . o . . . || . || |+----[SHA256]-----+cat /Users/Richard/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1xxxxxxxxxxxxxxxxxxxxxxxUZDXD qinjiangbo 将cat出来的内容拷贝到github账号中，完成！然后在进行pull或者push就OK啦！","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://qinjiangbo.com/tags/Git/"}]},{"title":"Twitter-Snowflake，64位自增ID算法详解","slug":"twitter-snowflakes-64-bit-algortithms","date":"2016-08-18T14:38:23.000Z","updated":"2017-04-05T01:40:40.000Z","comments":true,"path":"twitter-snowflakes-64-bit-algortithms.html","link":"","permalink":"http://qinjiangbo.com/twitter-snowflakes-64-bit-algortithms.html","excerpt":"","text":"Twitter-Snowflake算法产生的背景相当简单，为了满足Twitter每秒上万条消息的请求，每条消息都必须分配一条唯一的id，这些id还需要一些大致的顺序（方便客户端排序），并且在分布式系统中不同机器产生的id必须不同。 Snowflake算法核心把时间戳，工作机器id，序列号组合在一起。 除了最高位bit标记为不可用以外，其余三组bit占位均可浮动，看具体的业务需求而定。默认情况下41bit的时间戳可以支持该算法使用到2082年，10bit的工作机器id可以支持1023台机器，序列号支持1毫秒产生4095个自增序列id。下文会具体分析。 Snowflake – 时间戳这里时间戳的细度是毫秒级，具体代码如下，建议使用64位linux系统机器，因为有vdso，gettimeofday()在用户态就可以完成操作，减少了进入内核态的损耗。 123456uint64_t generateStamp()&#123; timeval tv; gettimeofday(&amp;tv, 0); return (uint64_t)tv.tv_sec * 1000 + (uint64_t)tv.tv_usec / 1000;&#125; 默认情况下有41个bit可以供使用，那么一共有T（1L &lt;&lt; 41）毫秒供你使用分配，年份 = T / (3600 * 24 * 365 * 1000) = 69.7年。如果你只给时间戳分配39个bit使用，那么根据同样的算法最后年份 = 17.4年。 Snowflake – 工作机器id严格意义上来说这个bit段的使用可以是进程级，机器级的话你可以使用MAC地址来唯一标示工作机器，工作进程级可以使用IP+Path来区分工作进程。如果工作机器比较少，可以使用配置文件来设置这个id是一个不错的选择，如果机器过多配置文件的维护是一个灾难性的事情。 这里的解决方案是需要一个工作id分配的进程，可以使用自己编写一个简单进程来记录分配id，或者利用Mysql auto_increment机制也可以达到效果。 工作进程与工作id分配器只是在工作进程启动的时候交互一次，然后工作进程可以自行将分配的id数据落文件，下一次启动直接读取文件里的id使用。 PS：这个工作机器id的bit段也可以进一步拆分，比如用前5个bit标记进程id，后5个bit标记线程id之类:D Snowflake – 序列号序列号就是一系列的自增id（多线程建议使用atomic），为了处理在同一毫秒内需要给多条消息分配id，若同一毫秒把序列号用完了，则“等待至下一毫秒”。 12345678uint64_t waitNextMs(uint64_t lastStamp)&#123; uint64_t cur = 0; do &#123; cur = generateStamp(); &#125; while (cur &lt;= lastStamp); return cur;&#125; 总体来说，是一个很高效很方便的GUID产生算法，一个int64_t字段就可以胜任，不像现在主流128bit的GUID算法，即使无法保证严格的id序列性，但是对于特定的业务，比如用做游戏服务器端的GUID产生会很方便。另外，在多线程的环境下，序列号使用atomic可以在代码实现上有效减少锁的密度。 参考资料：https://github.com/twitter/snowflake Snowflake - 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package com.qinjiangbo.util;import java.util.Random;/** * 基于Twitter/snowflake 算法的分布式全局id生成器 * 64位ID (42(毫秒)+10位（统一分配的业务号workerIdBits）+12(重复累加)) * * 整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分）， * 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。 * * 以下代码均为twitter官方scala版本的一个改编版,算法核心无二 */public class TwitterSnowFlake &#123; //当前起始时间戳 private final static long twepoch = 1468685273491L; //机器码标识 private static long workerId = 0L; //数据中心标识 private static long datacenterId = 0L; //序列号 private static long sequence = 0L; //机器码标识位数 private static long workerIdBits = 5L; //数据中心标识位数 private static long datacenterIdBits = 5L; //最大机器码标识 private static long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); //最大数据中心标识 private static long maxDataCenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); //序列号位数 private static long sequenceBits = 12L; //机器码位移数 private static long workerIdShift = sequenceBits; //数据中心标识位移数 private static long datacenterIdShift = workerIdBits + sequenceBits; //时间戳位移数 private static long timestampShift = datacenterIdBits + workerIdBits + sequenceBits; //上次计算的时间戳 private static long lastTimeStamp = -1L; //序列号掩码 private static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); //构造函数 public TwitterSnowFlake() &#123; Random random = new Random(); workerId = random.nextInt((int) maxWorkerId); datacenterId = random.nextInt((int) maxDataCenterId); &#125; public TwitterSnowFlake(final long workerId, final long datacenterId) &#123; if(workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(\"worker Id can't be greater than %d or less than 0\"); &#125; if(datacenterId &gt; maxDataCenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(\"datacenter Id can't be greater than %d or less than 0\"); &#125; this.datacenterId = datacenterId; this.workerId = workerId; &#125; private long getWorkerId() &#123; return this.workerId; &#125; private long getDatacenterId() &#123; return this.datacenterId; &#125; private long getTimeStamp() &#123; return System.currentTimeMillis(); &#125; public synchronized long nextId() &#123; long timeStamp = timeGen(); if(timeStamp &lt; lastTimeStamp) &#123; try &#123; throw new Exception(String.format(\"Clock moved backwards. Refusing to generate id for %d milliseconds\", lastTimeStamp - timeStamp)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; if(timeStamp == lastTimeStamp) &#123; sequence = (sequence + 1) &amp; sequenceMask; if(sequence == 0) &#123; timeStamp = tilNextMills(); &#125; &#125;else &#123; sequence = 0; &#125; lastTimeStamp = timeStamp; long workId = ((timeStamp - twepoch) &lt;&lt; timestampShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; return workId; &#125; /** * 等到下一秒 * @return */ private long tilNextMills() &#123; long timeStamp = timeGen(); do &#123; timeStamp = timeGen(); &#125; while (timeStamp &lt;= lastTimeStamp); return timeStamp; &#125; /** * 生产时间戳 * @return */ private long timeGen() &#123; return System.currentTimeMillis(); &#125;&#125;","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"算法","slug":"架构师/算法","permalink":"http://qinjiangbo.com/categories/架构师/算法/"}],"tags":[{"name":"Twitter","slug":"Twitter","permalink":"http://qinjiangbo.com/tags/Twitter/"},{"name":"自增算法","slug":"自增算法","permalink":"http://qinjiangbo.com/tags/自增算法/"}]},{"title":"Unix查看及修改文件的权限","slug":"previliges-of-modifications-in-unix","date":"2016-08-17T17:00:21.000Z","updated":"2018-05-13T09:21:30.000Z","comments":true,"path":"previliges-of-modifications-in-unix.html","link":"","permalink":"http://qinjiangbo.com/previliges-of-modifications-in-unix.html","excerpt":"","text":"权限介绍在终端输入:ls -l xxx.xxx （xxx.xxx是文件名）那么就会出现相类似的信息，主要都是这些：-rw-rw-r--一共有10位数.其中：最前面那个-代表的是类型.中间那三个 rw-代表的是所有者（user）然后那三个 rw-代表的是组群（group）最后那三个r--代表的是其他人（other） 然后我再解释一下后面那9位数：r 表示文件可以被读（read）w 表示文件可以被写（write）x 表示文件可以被执行（如果它是程序的话）- 表示相应的权限还没有被授予 修改文件权限在终端输入：chmod o w xxx.xxx表示给其他人授予写xxx.xxx这个文件的权限chmod go-rw xxx.xxx表示删除xxx.xxx中组群和其他人的读和写的权限，其中： u 代表所有者（user） g 代表所有者所在的组群（group） o 代表其他人，但不是u和g （other） a 代表全部的人，也就是包括u，g和o r 表示文件可以被读（read） w 表示文件可以被写（write） x 表示文件可以被执行（如果它是程序的话） 其中：rwx也可以用数字来代替 r ——————4 w —————-2 x ——————1 - ——————0 动作： + 表示添加权限 - 表示删除权限 = 表示使之成为唯一的权限 常见修改权限命令当大家都明白了上面的东西之后，那么我们常见的以下的一些权限就很容易都明白了： -rw———- (600) 只有所有者才有读和写的权限 -rw-r—r— (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限 -rwx——— (700) 只有所有者才有读，写，执行的权限 -rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限 -rwx—x—x (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限 -rw-rw-rw- (666) 每个人都有读写的权限 -rwxrwxrwx (777) 每个人都有读写和执行的权限","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qinjiangbo.com/tags/Linux/"},{"name":"Chown","slug":"Chown","permalink":"http://qinjiangbo.com/tags/Chown/"}]},{"title":"使用命令chown改变目录或文件的所有权","slug":"change-ownership-of-files-with-chown-command","date":"2016-08-17T16:57:23.000Z","updated":"2018-05-13T09:12:54.000Z","comments":true,"path":"change-ownership-of-files-with-chown-command.html","link":"","permalink":"http://qinjiangbo.com/change-ownership-of-files-with-chown-command.html","excerpt":"","text":"文件与目录不仅可以改变权限，其所有权及所属用户组也能修改，和设置权限类似，用户可以通过图形界面来设置，或执行chown命令来修改。 我们先执行ls -l看看目录情况： 12345678910[root@localhost ~]# ls -l总用量 368-rwxrwxrwx 1 root root 12172 8月 15 23:18 conkyrc.sampledrwxr-xr-x 2 root root 48 9月 4 16:32 Desktop-r--r--r-- 1 root root 331844 10月 22 21:08 libfreetype.so.6drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1-rwxr-xr-x 1 root root 512 11月 5 08:08 net.lodrwxr-xr-x 2 root root 48 9月 6 13:06 vmware 可以看到conkyrc.sample文件的所属用户组为root，所有者为root。 执行下面命令，把conkyrc.sample文件的所有权转移到用户user: 1234567891011[root@localhost ~]# chown user conkyrc.sample[root@localhost ~]# ls -l总用量 368-rwxrwxrwx 1 user root 12172 8月 15 23:18 conkyrc.sampledrwxr-xr-x 2 root root 48 9月 4 16:32 Desktop-r--r--r-- 1 root root 331844 10月 22 21:08 libfreetype.so.6drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1-rwxr-xr-x 1 root root 512 11月 5 08:08 net.lodrwxr-xr-x 2 root root 48 9月 6 13:06 vmware 要改变所属组，可使用下面命令： 1234567891011[root@localhost ~]# chown :users conkyrc.sample[root@localhost ~]# ls -l总用量 368-rwxrwxrwx 1 user users 12172 8月 15 23:18 conkyrc.sampledrwxr-xr-x 2 root root 48 9月 4 16:32 Desktop-r--r--r-- 1 root root 331844 10月 22 21:08 libfreetype.so.6drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1-rwxr-xr-x 1 root root 512 11月 5 08:08 net.lodrwxr-xr-x 2 root root 48 9月 6 13:06 vmware 要修改目录的权限，使用－R参数就可以了，方法和前面一样","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qinjiangbo.com/tags/Linux/"},{"name":"Chown","slug":"Chown","permalink":"http://qinjiangbo.com/tags/Chown/"}]},{"title":"使用chmod改变文件或目录的访问权限","slug":"change-access-previliges-with-chmod-command","date":"2016-08-17T16:50:36.000Z","updated":"2018-05-13T09:13:04.000Z","comments":true,"path":"change-access-previliges-with-chmod-command.html","link":"","permalink":"http://qinjiangbo.com/change-access-previliges-with-chmod-command.html","excerpt":"","text":"文件和目录的权限表示，是用rwx这三个字符来代表所有者、用户组和其他用户的权限。有时候，字符似乎过于麻烦，因此还有另外一种方法是以数字来表示权限，而且仅需三个数字。 r: 对应数值4 w: 对应数值2 x：对应数值1 －：对应数值0 数字设定的关键是mode的取值，一开始许多初学者会被搞糊涂，其实很简单，我们将rwx看成二进制数，如果有则有1表示，没有则有0表示，那么rwx r-x r- -则可以表示成为： 111 101 100 再将其每三位转换成为一个十进制数，就是754。 例如，我们想让a.txt这个文件的权限为： 自己同组用户其他用户 可读是是是 可写是是 可执行 那么，我们先根据上表得到权限串为：rw-rw-r—，那么转换成二进制数就是110 110 100，再每三位转换成为一个十进制数，就得到664，因此我们执行命令： [root@localhost ~]# chmod 664 a.txt 按照上面的规则，rwx合起来就是4 2 1＝7，一个rwxrwxrwx权限全开放的文件，数值表示为777；而完全不开放权限的文件“－－－－－－－－－”其数字表示为000。下面举几个例子： -rwx———:等于数字表示700。 -rwxr—r—:等于数字表示744。 -rw-rw-r-x:等于数字表示665。 drwx—x—x:等于数字表示711。 drwx———:等于数字表示700。 在文本模式下，可执行chmod命令去改变文件和目录的权限。我们先执行ls -l 看看目录内的情况： 12345678910[root@localhost ~]# ls -l总用量 368-rw-r--r-- 1 root root 12172 8月 15 23:18 conkyrc.sampledrwxr-xr-x 2 root root 48 9月 4 16:32 Desktop-r--r--r-- 1 root root 331844 10月 22 21:08 libfreetype.so.6drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1-rwxr-xr-x 1 root root 512 11月 5 08:08 net.lodrwxr-xr-x 2 root root 48 9月 6 13:06 vmware 可以看到当然文件conkyrc.sample文件的权限是644,然后把这个文件的权限改成777。执行下面命令 [root@localhost ~]# chmod 777 conkyrc.sample 然后ls -l看一下执行后的结果： 12345678910[root@localhost ~]# ls -l总用量 368-rwxrwxrwx 1 root root 12172 8月 15 23:18 conkyrc.sampledrwxr-xr-x 2 root root 48 9月 4 16:32 Desktop-r--r--r-- 1 root root 331844 10月 22 21:08 libfreetype.so.6drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1-rwxr-xr-x 1 root root 512 11月 5 08:08 net.lodrwxr-xr-x 2 root root 48 9月 6 13:06 vmware 可以看到conkyrc.sample文件的权限已经修改为rwxrwxrwx 如果要加上特殊权限，就必须使用4位数字才能表示。特殊权限的对应数值为： s或 S （SUID）：对应数值4。 s或 S （SGID）：对应数值2。 t或 T ：对应数值1。 用同样的方法修改文件权限就可以了, 例如： 1234567891011[root@localhost ~]# chmod 7600 conkyrc.sample[root@localhost ~]# ls -l总用量 368-rwS--S--T 1 root root 12172 8月 15 23:18 conkyrc.sampledrwxr-xr-x 2 root root 48 9月 4 16:32 Desktop-r--r--r-- 1 root root 331844 10月 22 21:08 libfreetype.so.6drwxr-xr-x 2 root root 48 8月 12 22:25 MyMusic-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth0-rwxr-xr-x 1 root root 9776 11月 5 08:08 net.eth1-rwxr-xr-x 1 root root 512 11月 5 08:08 net.lodrwxr-xr-x 2 root root 48 9月 6 13:06 vmware 加入想一次修改某个目录下所有文件的权限，包括子目录中的文件权限也要修改，要使用参数－R表示启动递归处理。 例如： [root@localhost ~]# chmod 777 /home/user 注：仅把/home/user目录的权限设置为rwxrwxrwx [root@localhost ~]# chmod -R 777 /home/user 注：表示将整个/home/user目录与其中的文件和子目录的权限都设置为rwxrwxrwx","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qinjiangbo.com/tags/Linux/"},{"name":"Chmod","slug":"Chmod","permalink":"http://qinjiangbo.com/tags/Chmod/"}]},{"title":"非常有用的制作logo的网站","slug":"useful-logo-maker-websites","date":"2016-08-17T16:38:27.000Z","updated":"2016-08-27T01:01:49.000Z","comments":true,"path":"useful-logo-maker-websites.html","link":"","permalink":"http://qinjiangbo.com/useful-logo-maker-websites.html","excerpt":"","text":"1、LogoEaseLogoEase是一个免费使用的网站,可以让你轻松创建logo。 2、LogoMaker和LogoEase,LogoMaker一样，是另外一个web服务站点，它允许您创建和下载logo。该网站可以让你选择一个logo的类别，定制个性图标，当然也包括文本和颜色。 3、CoolTextCoolText是一个非常有用的文字创造者，极其简单的使用流程，它允许您设计标识，仅仅通过选择一个字体列表就可以啦。 4、FlamingTextFlamingText是一个美妙的标识创建网站，你可以使用库存的现有模板。一旦你选择了一个logo设计后，您可以修改许多属性，直到改头换面成您满意的那个。 5、LogoYes Logo Creator这是一个很棒的网站，提供了大量创造Logo的特性。而且非常容易上手。 6、LogoSnapLogoSnap是另一个在线标识创建工具，着重帮助您创建个性的logo。同样是简单的开始，选择一个logo类别，然后继续自定义文本和颜色，可以根据你的需要和偏好来完成标识设计。 7、Online Logo Maker噢，说真的，这是一个很好的标志制造者，兢兢业业而且不断完善，制造商允许您选择和定制logo用在你的项目中。除了友好的用户界面，应用程序的功能也是丰富之极，当然这一切都是希望您能得到一个好LOGO！","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"Logo","slug":"Logo","permalink":"http://qinjiangbo.com/tags/Logo/"},{"name":"设计","slug":"设计","permalink":"http://qinjiangbo.com/tags/设计/"}]},{"title":"CSS3滤镜","slug":"css3-filter","date":"2016-08-17T14:48:03.000Z","updated":"2017-01-14T03:21:11.000Z","comments":true,"path":"css3-filter.html","link":"","permalink":"http://qinjiangbo.com/css3-filter.html","excerpt":"","text":"语法1filter: function(param); 很很多CSS3属性一样，监狱支持情况需要使用浏览器前缀，CSS滤镜支持的方法有 grayscale 灰度 sepia 褐色 saturate 饱和度 hue-rotate 色相旋转 invert 反色 opacity 透明度 brightness 亮度 contrast 对比度 blur 模糊 drop-shadow 阴影 模糊 -webkit-filter:blur(10px); (非常流行的开始页面) 使用方式: 1-webkit-filter:function_name(params);","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"前端","slug":"开发技术/前端","permalink":"http://qinjiangbo.com/categories/开发技术/前端/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://qinjiangbo.com/tags/CSS3/"},{"name":"网页滤镜","slug":"网页滤镜","permalink":"http://qinjiangbo.com/tags/网页滤镜/"}]},{"title":"Highlight.js支持的语言列表","slug":"language-list-supported-by-highlightjs","date":"2016-08-16T16:35:28.000Z","updated":"2016-10-28T16:14:01.000Z","comments":true,"path":"language-list-supported-by-highlightjs.html","link":"","permalink":"http://qinjiangbo.com/language-list-supported-by-highlightjs.html","excerpt":"","text":"支持语言的名称和别名 名称 别名 1C 1c ABNF abnf Access logs accesslog Ada ada ARM assembler armasm, arm AVR assembler avrasm ActionScript actionscript, as Apache apache, apacheconf AppleScript applescript, osascript AsciiDoc asciidoc, adoc AspectJ aspectj AutoHotkey autohotkey AutoIt autoit Awk awk, mawk, nawk, gawk Axapta axapta Bash bash, sh, zsh Basic basic BNF bnf Brainfuck brainfuck, bf C# cs, csharp C++ cpp, c, cc, h, c++, h++, hpp C/AL cal Cache Object Script cos, cls CMake cmake, cmake.in Coq coq CSP csp CSS css Cap’n Proto capnproto, capnp Clojure clojure, clj CoffeeScript coffeescript, coffee, cson, iced Crmsh crmsh, crm, pcmk Crystal crystal, cr D d DNS Zone file dns, zone, bind DOS dos, bat, cmd Dart dart Delphi delphi, dpr, dfm, pas, pascal, freepascal, lazarus, lpr, lfm Diff diff, patch Django django, jinja Dockerfile dockerfile, docker dsconfig dsconfig DTS (Device Tree) dts Dust dust, dst EBNF ebnf Elixir elixir Elm elm Erlang erlang, erl Excel excel, xls, xlsx F# fsharp, fs FIX fix Fortran fortran, f90, f95 G-Code gcode, nc Gams gams, gms GAUSS gauss, gss Gherkin gherkin Go go, golang Golo golo, gololang Gradle gradle Groovy groovy HTML, XML xml, html, xhtml, rss, atom, xjb, xsd, xsl, plist HTTP http, https Haml haml Handlebars handlebars, hbs, html.hbs, html.handlebars Haskell haskell, hs Haxe haxe, hx Ini ini Inform7 inform7, i7 IRPF90 irpf90 JSON json Java java, jsp JavaScript javascript, js, jsx Lasso lasso, ls, lassoscript Less less LDIF ldif Lisp lisp LiveCode Server livecodeserver LiveScript livescript, ls Lua lua Makefile makefile, mk, mak Markdown markdown, md, mkdown, mkd Mathematica mathematica, mma Matlab matlab Maxima maxima Maya Embedded Language mel Mercury mercury Mizar mizar Mojolicious mojolicious Monkey monkey Moonscript moonscript, moon NSIS nsis Nginx nginx, nginxconf Nimrod nimrod, nim Nix nix OCaml ocaml, ml Objective C objectivec, mm, objc, obj-c OpenGL Shading Language glsl OpenSCAD openscad, scad Oracle Rules Language ruleslanguage Oxygene oxygene PF pf, pf.conf PHP php, php3, php4, php5, php6 Parser3 parser3 Perl perl, pl, pm Pony pony PowerShell powershell, ps Processing processing Prolog prolog Protocol Buffers protobuf Puppet puppet, pp Python python, py, gyp Python profiler results profile Q k, kdb QML qml R r RenderMan RIB rib RenderMan RSL rsl Roboconf graph, instances Ruby ruby, rb, gemspec, podspec, thor, irb Rust rust, rs SCSS scss SQL sql STEP Part 21 p21, step, stp Scala scala Scheme scheme Scilab scilab, sci Smali smali Smalltalk smalltalk, st Stan stan Stata stata Stylus stylus, styl SubUnit subunit Swift swift Test Anything Protocol tap Tcl tcl, tk TeX tex Thrift thrift TP tp Twig twig, craftcms TypeScript typescript, ts VB.Net vbnet, vb VBScript vbscript, vbs VHDL vhdl Vala vala Verilog verilog, v Vim Script vim x86 Assembly x86asm XL xl, tao XQuery xpath, xq Zephir zephir, zep","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"编程经验","slug":"经验感悟/编程经验","permalink":"http://qinjiangbo.com/categories/经验感悟/编程经验/"}],"tags":[{"name":"Highlight.js","slug":"Highlight-js","permalink":"http://qinjiangbo.com/tags/Highlight-js/"},{"name":"Jquery","slug":"Jquery","permalink":"http://qinjiangbo.com/tags/Jquery/"}]},{"title":"Hadoop启动时SSH免密码登录","slug":"ssh-non-login-of-hadoop","date":"2016-08-16T15:00:26.000Z","updated":"2017-11-26T08:49:16.000Z","comments":true,"path":"ssh-non-login-of-hadoop.html","link":"","permalink":"http://qinjiangbo.com/ssh-non-login-of-hadoop.html","excerpt":"","text":"现在在学习大数据，买了一台云服务器，照着网上的教程安装的。现在在启动（start-all.sh）Hadoop的时候老是要求输入密码，后面在真实环境下不可能每一次通信都要求手动输入密码的，所以，免密码很重要： 现在直接上代码： 12345678910111213141516171819ssh-keygen -t rsa -P \"\"Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:a0:0d:8a:b4:dd:e7:92:6f:44:25:36:9a:5b:75:10:a8 root@richardThe key's randomart image is:+--[ RSA 2048]----+| .oo || = o . || . . * = . ||..o..E + ||......=.S || .+. || o.. || o. || .. |+-----------------+ 接下来将密钥写入ssh中 12cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys/etc/init.d/ssh reload 再次启动hadoop就没有密码输入的要求了。","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"大数据","slug":"数据科学/大数据","permalink":"http://qinjiangbo.com/categories/数据科学/大数据/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qinjiangbo.com/tags/Linux/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://qinjiangbo.com/tags/Hadoop/"}]},{"title":" Word转PDF[不采用OpenOffice]","slug":"word-to-pdf-without-open-office","date":"2016-08-16T14:50:42.000Z","updated":"2016-08-16T14:57:28.000Z","comments":true,"path":"word-to-pdf-without-open-office.html","link":"","permalink":"http://qinjiangbo.com/word-to-pdf-without-open-office.html","excerpt":"","text":"目前在做一个与文档有关的项目，网上看到的都是利用OpenOffice来转化word为pdf的，其实局限性很大，下载那么大一个软件，却只是为了它的服务。所以决定找一下有没有别的方法，终于遇到了docx4j这个神一样的JAR包，完美解决了我的问题！不说了，直接上代码！ 所需Jar包如下: avalon-framework-4.1.5 commons-io-2.4 docx4j-2.7.1 log4j-1.2.15 serializer-2.7.1 xmlgraphics-commons-1.3 batik-util-1.6-1 commons-logging-1.1.3 fop-0.93 xalan-2.7.1 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package in.javadomain;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.util.List;import org.docx4j.convert.out.pdf.viaXSLFO.PdfSettings;import org.docx4j.fonts.IdentityPlusMapper;import org.docx4j.fonts.Mapper;import org.docx4j.fonts.PhysicalFont;import org.docx4j.fonts.PhysicalFonts;import org.docx4j.openpackaging.packages.WordprocessingMLPackage;public class Word2Pdf &#123; public static void main(String[] args) &#123; try &#123; long start = System.currentTimeMillis(); InputStream is = new FileInputStream( new File(\"D:\\\\javadomain.docx\")); WordprocessingMLPackage wordMLPackage = WordprocessingMLPackage .load(is); List sections = wordMLPackage.getDocumentModel().getSections(); for (int i = 0; i &lt; sections.size(); i++) &#123; System.out.println(\"sections Size\" + sections.size()); wordMLPackage.getDocumentModel().getSections().get(i) .getPageDimensions().setHeaderExtent(3000); &#125; Mapper fontMapper = new IdentityPlusMapper(); PhysicalFont font = PhysicalFonts.getPhysicalFonts().get( \"Comic Sans MS\"); fontMapper.getFontMappings().put(\"Algerian\", font); wordMLPackage.setFontMapper(fontMapper); PdfSettings pdfSettings = new PdfSettings(); org.docx4j.convert.out.pdf.PdfConversion conversion = new org.docx4j.convert.out.pdf.viaXSLFO.Conversion( wordMLPackage); OutputStream out = new FileOutputStream(new File( \"D:\\\\javadomain.pdf\")); conversion.output(out, pdfSettings); System.err.println(\"Time taken to Generate pdf \" + (System.currentTimeMillis() - start) + \"ms\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"DOC转PDF","slug":"DOC转PDF","permalink":"http://qinjiangbo.com/tags/DOC转PDF/"},{"name":"DOCX4J","slug":"DOCX4J","permalink":"http://qinjiangbo.com/tags/DOCX4J/"}]},{"title":"Mathjax与LaTex公式简介","slug":"introduction-to-mathjax-and-latex","date":"2016-08-14T14:40:59.000Z","updated":"2018-08-05T07:24:50.000Z","comments":true,"path":"introduction-to-mathjax-and-latex.html","link":"","permalink":"http://qinjiangbo.com/introduction-to-mathjax-and-latex.html","excerpt":"","text":"MathJax简介MathJax是一款运行在浏览器中的开源的数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片。目前，MathJax可以解析Latex、MathML和ASCIIMathML的标记语言。 MathJax项目于2009年开始，发起人有American Mathematical Society, Design Science等，还有众多的支持者，个人感觉MathJax会成为今后数学符号渲染引擎中的主流，也许现在已经是了。 本文接下来会讲述MathJax的基础用法，但不涉及MathJax的安装及配置。此外，推荐使用StackEdit学习MathJax的语法，它支持Markdown和MathJax，本文使用此编辑器撰写。 基础公式标记与查看公式使用MathJax时，需要用一些适当的标记告诉MathJax某段文本是公式代码。此外，MathJax中的公式排版有两种方式，inline和displayed。inline表示公式嵌入到文本段中，displayed表示公式独自成为一个段落。例如，$f(x)=3\\times x$这是一个inline公式，而下面 f(x)=3\\times x是一个displayed公式。 在MathJax中，默认的displayed公式分隔符有$$...$$ 和\\[…\\],而默认的inline公式分隔符为 (…) ,当然这些都是可以自定义的，具体配置请参考文档。下文中，使用$$…$$作为displayed分隔符，$…$作为inline分隔符。 此外，可以在渲染完成的公式上方右键点击，唤出右键菜单。在菜单中提供了查看公式代码、设置显示效果和渲染模式的选项。 希腊字母请参见下表： 名称 大写 Tex 小写 Tex alpha $A$ A $\\alpha$ \\alpha beta $B$ B $\\beta$ \\beta gamma $\\Gamma$ \\Gamma $\\gamma$ \\gamma delta $\\Delta$ \\Delta $\\delta$ \\delta epsilon $E$ E $\\epsilon$ \\epsilon zeta $Z$ Z $\\zeta$ \\zeta eta $H$ H $\\eta$ \\eta theta $\\Theta$ \\Theta $\\theta$ \\theta iota $I$ I $\\iota$ \\iota kappa $K$ K $\\kappa$ \\kappa lambda $\\Lambda$ \\Lambda $\\lambda$ \\lambda mu $M$ M $\\mu$ \\mu nu $N$ N $\\nu$ \\nu xi $\\Xi$ \\Xi $\\xi$ \\xi omicron $O$ O $\\omicron$ \\omicron pi $\\Pi$ \\Pi $\\pi$ \\pi rho $P$ P $\\rho$ \\rho sigma $\\Sigma$ \\Sigma $\\sigma$ \\sigma tau $T$ T $\\tau$ \\tau upsilon $\\Upsilon$ \\Upsilon $\\upsilon$ \\upsilon phi $\\Phi$ \\Phi $\\phi$ \\phi chi $X$ X $\\chi$ \\chi psi $\\Psi$ \\Psi ψ \\psi omega $\\Omega$ \\Omega $\\omega$ \\omega 上标与下标上标和下标分别使用\\^与_，例如x_i^2：$x_i^2$。默认情况下，上下标符号仅仅对下一个组起作用。一个组即单个字符或者使用{..}包裹起来的内容。也就是说，如果使用10^10，会得到$10^10$，而10^{10}才是$10^{10}$。同时，大括号还能消除二义性，如x^5^6将得到一个错误，必须使用大括号来界定^的结合性，如{x^5}^6：${x^5}^6$ 或者 x^{5^6}：$x^{5^6}$。 括号 小括号与方括号：使用原始的( )，[ ]即可，如(2+3)[4+4]：(2+3)[4+4] 大括号：时由于大括号{}被用来分组，因此需要使用\\\\{和\\\\}表示大括号，也可以使用\\\\lbrace 和\\\\rbrace来表示。如\\{a*b\\}:a∗b，\\lbrace a*b \\rbrace：$\\{a∗b\\}, \\lbrace a*b \\rbrace$。 尖括号：使用\\langle 和 \\rangle表示左尖括号和右尖括号。如\\langle x \\rangle：$\\langle x \\rangle$。 上取整：使用\\lceil 和 \\rceil 表示。 如，\\lceil x \\rceil：$\\lceil x \\rceil$。 下取整：使用\\lfloor 和 \\rfloor 表示。如，\\lfloor x \\rfloor：$\\lfloor x \\rfloor$。 不可见括号：使用.表示。 需要注意的是，原始符号并不会随着公式大小缩放。如，(\\frac12)：$\\frac 1 2)$。可以使用\\left(…\\right)来自适应的调整括号大小。如下， \\{\\sum_{i=0}^ni^2=\\frac {(n^2+n)(2n+1)}{6}\\} \\tag {1.1}\\left\\{\\sum_{i=0}^ni^2=\\frac {(n^2+n)(2n+1)}{6}\\right\\} \\tag {1.2}可以看到，公式1.2中的括号是经过缩放的。 求和与积分 \\sum用来表示求和符号，其下标表示求和下限，上标表示上限。如，\\sum_1^n：$\\sum_1^n$。 \\int用来表示积分符号，同样地，其上下标表示积分的上下限。如，\\int_1^\\infty：$\\int_1^\\infty$。 与此类似的符号还有，\\prod：$\\prod$，\\bigcup:$\\bigcup$，\\bigcap：$\\bigcap$，\\iint：$\\iint$。 分式与根式分式的表示。第一种，使用\\frac a b，\\frac作用于其后的两个组a，b，结果为$\\frac a b$。如果你的分子或分母不是单个字符，请使用{..}来分组。第二种，使用\\over来分隔一个组的前后两部分，如{a+1\\over b+1}：${a+1\\over b+1}$。 根式使用\\sqrt来表示。如，\\sqrt[4]{\\frac xy} ：$\\sqrt[4]{\\frac {x}{y}}$ 字体 使用\\mathbb或\\Bbb显示黑板粗体字，此字体经常用来表示代表实数、整数、有理数、复数的大写字母。如，$\\mathbb{CHNQRZ}$。 使用\\mathbf显示黑体字，如，$\\mathbf{ABCDEFGHIJKLMNOPQRSTUVWXYZ，abcdefghijklmnopqrstuvwxyz}$。 使用\\mathtt显示打印机字体，如，$\\mathtt{𝙰𝙱𝙲𝙳𝙴𝙵𝙶𝙷𝙸𝙹𝙺𝙻𝙼𝙽𝙾𝙿𝚀𝚁𝚂𝚃𝚄𝚅𝚆𝚇𝚈𝚉，𝚊𝚋𝚌𝚍𝚎𝚏𝚐𝚑𝚒𝚓𝚔𝚕𝚖𝚗𝚘𝚙𝚚𝚛𝚜𝚝𝚞𝚟𝚠𝚡𝚢𝚣}$。 使用\\mathrm显示罗马字体，如，$\\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ，abcdefghijklmnopqrstuvwxyz}$。 使用\\mathscr显示手写体，如，$\\mathscr{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$。 使用\\mathfrak显示Fraktur字母（一种德国字体），如$\\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ，abcdefghijklmnopqrstuvwxyz}$。 特殊函数与符号 常见的三角函数，求极限符号可直接使用+缩写即可。如$sin x$, $arctan x$, $lim_{1\\to\\infty}$。 比较运算符：\\lt \\gt \\le \\ge \\neq ： $\\lt \\gt \\le \\ge \\neq$。可以在这些运算符前面加上\\not，如\\not\\lt：$\\not\\lt$。 \\times \\div \\pm \\mp表示：$\\times \\div \\pm \\mp$，\\cdot表示居中的点，x \\cdot y : $x \\cdot y$。 集合关系与运算：\\cup \\cap \\setminus \\subset \\subseteq \\subsetneq \\supset \\in \\notin \\emptyset \\varnothing ：$\\cup \\cap \\setminus \\subset \\subseteq \\subsetneq \\supset \\in \\notin \\emptyset \\varnothing$. 表示排列使用{n+1 \\choose 2k} 或 \\binom{n+1}{2k}，${n+1 \\choose 2k}$。 箭头：\\to \\rightarrow \\leftarrow \\Rightarrow \\Leftarrow \\mapsto : $\\to \\rightarrow \\leftarrow \\Rightarrow \\Leftarrow \\mapsto$。 逻辑运算符：\\land \\lor \\lnot \\forall \\exists \\top \\bot \\vdash \\vDash ： $\\land \\lor \\lnot \\forall \\exists \\top \\bot \\vdash \\vDash$。 \\star \\ast \\oplus \\circ \\bullet ： $\\star \\ast \\oplus \\circ \\bullet$。 \\approx \\sim \\cong \\equiv \\prec ： $\\approx \\sim \\cong \\equiv \\prec$。 \\infty \\aleph_0 $\\infty \\aleph_0$ \\nabla \\partial $\\nabla \\partial$ \\Im \\Re $\\Im \\Re$。 模运算 \\pmode, 如，a\\equiv b\\pmod n：$a\\equiv b\\pmod n$。 \\ldots与\\cdots，其区别是dots的位置不同，ldots位置稍低，cdots位置居中。$a_1+a_2+\\cdots+a_n，a_1,a_2,\\ldots,a_n$。 一些希腊字母具有变体形式，如 \\epsilon \\varepsilon : $\\epsilon \\varepsilon$, \\phi \\varphi $\\phi \\varphi$。 空间通常MathJax通过内部策略自己管理公式内部的空间，因此a…b与a…….b（.表示空格）都会显示为ab。可以通过在ab间加入\\,增加些许间隙，\\;增加较宽的间隙，\\quad 与 \\qquad 会增加更大的间隙，如，$a\\qquad b$。 顶部符号对于单字符，\\hat x：$\\hat x$，多字符可以使用\\widehat {xy},$\\widehat {xy}$.类似的还有\\hat,\\overline,\\vec,\\overrightarrow, \\dot \\ddot : $\\hat {x} \\quad \\widehat {xy}\\quad \\overline {xyz} \\quad \\vec {abc} \\quad \\overrightarrow {xxx} \\quad \\dot{h} \\quad \\ddot{x}$。 结束基础部分就是这些。需要注意的是一些MathJax使用的特殊字符，可以使用\\转义为原来的含义。如\\$表示‘$‘，\\_表示下划线。 表格使用$$\\begin{array}{列样式}…\\end{array}$$这样的形式来创建表格，列样式可以是clr表示居中，左，右对齐，还可以使用|表示一条竖线。表格中 各行使用\\\\分隔，各列使用&amp;分隔。使用\\hline在本行前加入一条直线。 例如 $$ \\begin{array}{c|lcr} n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\ \\hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\\\ 2 &amp; -1 &amp; 189 &amp; -8 \\\\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\ \\end{array} $$ \\begin{array}{c|lcr} n & \\text{Left} & \\text{Center} & \\text{Right} \\\\ \\hline 1 & 0.24 & 1 & 124 \\\\ 2 & -11 & 189 & 90 \\\\ 3 & -20 & 789 & 1+10i \\\\ \\end{array}矩阵基本用法使用$$\\begin{matrix}…\\end{matrix}$$这样的形式来表示矩阵，在\\begin与\\end之间加入矩阵中的元素即可。矩阵的行之间使用\\\\分隔，列之间使用&amp;分隔。 例如 $$ \\begin{matrix} 1 &amp; x &amp; x^2 \\\\ 1 &amp; y &amp; y^2 \\\\ 1 &amp; z &amp; z^2 \\\\ \\end{matrix} $$ 结果： \\begin{matrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{matrix}加括号如果要对矩阵加括号，可以像上文中提到的一样，使用\\left与\\right配合表示括号符号。也可以使用特殊的matrix。即替换\\begin{matrix}…\\end{matrix}中的matrix为pmatrix，bmatrix，Bmatrix，vmatrix,Vmatrix. \\begin{pmatrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{pmatrix} \\tag {pmatrix} \\begin{bmatrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{bmatrix} \\tag {bmatrix} \\begin{Bmatrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{Bmatrix} \\tag {Bmatrix} \\begin{vmatrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{vmatrix} \\tag {vmatrix} \\begin{Vmatrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{Vmatrix} \\tag {Vmatrix}省略元素可以使用\\cdots $\\cdots$ \\ddots $\\ddots$ \\vdots $\\vdots$来省略矩阵中的元素，如： \\begin{pmatrix} 1 & a_1 & a_1^2 & a_1^3 & \\cdots & a_1^n \\\\ 2 & a_2 & a_2^2 & a_2^3 & \\cdots & a_2^n \\\\ 3 & a_3 & a_3^2 & a_3^3 & \\cdots & a_3^n \\\\ 4 & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 4 & a_4 & a_4^2 & a_4^3 & \\cdots & a_4^n \\\\ \\end{pmatrix} \\tag {demo}增广矩阵增广矩阵需要使用前面的array来实现，如 $$ \\left[ \\begin{array}{cc|c} 1&amp;2&amp;3\\\\ 4&amp;5&amp;6 \\end{array} \\right] $$ 结果： \\left[ \\begin{array}{cc|c} 1&2&3 \\\\ 4&5&6 \\\\ \\end{array} \\right]对齐的公式有时候可能需要一系列的公式中等号对齐，如： $$ \\begin{align} \\sqrt{37} &amp; = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ &amp; = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ &amp; \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\end{align} $$ \\begin{align} \\sqrt{37} & = \\sqrt{\\frac{73^2-1}{12^2}} \\\\\\ & = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\\\ & = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\\\ & = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\\\ & \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\end{align}这需要使用形如\\begin{align}…\\end{align}的格式，其中需要使用&amp;来指示需要对齐的位置。请使用右键查看上述公式的代码。 分类表达式定义函数的时候经常需要分情况给出表达式，可使用\\begin{cases}…\\end{cases}。其中，使用\\来分类，使用&amp;指示需要对齐的位置。如： $$ f(n) = \\begin{cases} n/2, &amp; \\text{if $n$ is even} \\\\ 3n+1, &amp; \\text{if $n$ is odd} \\\\ \\end{cases} $$ f(n) = \\begin{cases} n/2, & \\text{if n is even} \\\\\\ 3n+1, & \\text{if n is odd} \\end{cases}上述公式的括号也可以移动到右侧，不过需要使用array来实现，如下： $$ \\left. \\begin{array}{l} \\text{if $n$ is even:}&amp;n/2\\\\ \\text{if $n$ is odd:}&amp;3n+1 \\end{array} \\right\\} =f(n) $$ \\left. \\begin{array}{l} \\text{if n is even:}&n/2\\\\ \\text{if n is odd:}&3n+1 \\end{array} \\right\\} =f(n)最后，如果想分类之间的垂直间隔变大，可以使用\\[2ex]代替\\来分隔不同的情况。(3ex,4ex也可以用，1ex相当于原始距离）。 数学符号查询一般而言，从一个巨大的符号表中查询所需要的特定符号是一件令人沮丧的事情。在此向大家介绍一个$\\TeX$手写符号识别系统，如下图：尽情享用吧~ Detexify²。 空间问题在使用Latex公式时，有一些不会影响公式正确性，但却会使其看上去很槽糕的问题。 不要在指数或者积分中使用 \\frac在指数或者积分表达式中使用\\frac会使表达式看起来不清晰，因此在专业的数学排版中很少被使用。应该使用一个水平的/来代替，效果如下： \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ e^{i\\frac{\\pi}2} \\quad e^{\\frac{i\\pi}2}& e^{i\\pi/2} \\\\ \\int_{-\\frac\\pi2}^\\frac\\pi2 \\sin x\\,dx & \\int_{-\\pi/2}^{\\pi/2}\\sin x\\,dx \\\\ \\end{array}使用 \\mid 代替 | 作为分隔符符号|作为分隔符时有排版空间大小的问题，应该使用\\mid代替。效果如下： \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ \\{x|x^2\\in\\Bbb Z\\} & \\{x\\mid x^2\\in\\Bbb Z\\} \\\\ \\end{array}多重积分对于多重积分，不要使用\\int\\int此类的表达，应该使用\\iint \\iiint等特殊形式。效果如下： \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ \\int\\int_S f(x)\\,dy\\,dx & \\iint_S f(x)\\,dy\\,dx \\\\ \\int\\int\\int_V f(x)\\,dz\\,dy\\,dx & \\iiint_V f(x)\\,dz\\,dy\\,dx \\end{array}此外，在微分前应该使用\\,来增加些许空间，否则$\\TeX$会将微分紧凑地排列在一起。如下： \\begin{array}{cc} \\mathrm{Bad} & \\mathrm{Better} \\\\ \\hline \\\\ \\iiint_V f(x)dz dy dx & \\iiint_V f(x)\\,dz\\,dy\\,dx \\end{array}连分数书写连分数表达式时，请使用\\cfrac代替\\frac或者\\over两者效果对比如下： x = a_0 + \\cfrac{1^2}{a_1 +\\, \\cfrac{2^2}{a_2 +\\, \\cfrac{3^2}{a_3 + \\cfrac{4^4}{a_4 + \\cdots}}}} \\tag{\\cfrac} x = a_0 + \\frac{1^2}{a_1 +\\, \\frac{2^2}{a_2 +\\, \\frac{3^2}{a_3 + \\frac{4^4}{a_4 + \\cdots}}}} \\tag{\\frac}方程组使用\\begin{array} … \\end{array}与\\left{…\\right.配合，表示方程组，如： \\left\\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1 \\\\\\ a_2x+b_2y+c_2z=d_2 \\\\\\ a_3x+b_3y+c_3z=d_3 \\end{array} \\right.同时，还可以使用\\begin{cases}…\\end{cases}表达同样的方程组，如： \\begin{cases} a_1x+b_1y+c_1z=d_1 \\\\\\ a_2x+b_2y+c_2z=d_2 \\\\\\ a_3x+b_3y+c_3z=d_3 \\end{cases}对齐方程组中的 = 号，可以使用 \\being{aligned} .. \\end{aligned}，如： \\left\\{ \\begin{aligned} a_1x+b_1y+c_1z &=d_1+e_1 \\\\\\ a_2x+b_2y&=d_2 \\\\\\ a_3x+b_3y+c_3z &=d_3 \\end{aligned} \\right.如果要对齐 = 号 和项，可以使用\\being{array}{列样式} .. \\end{array}，如： \\left\\{ \\begin{array}{ll} a_1x+b_1y+c_1z &=d_1+e_1 \\\\\\ a_2x+b_2y &=d_2 \\\\\\ a_3x+b_3y+c_3z &=d_3 \\end{array} \\right.颜色命名颜色是浏览器相关的，如果浏览器没有定义相关的颜色名称，则相关文本将被渲染为黑色。以下颜色是HTML4与CSS2标准中定义的一些颜色，其应该被大多数浏览器定义了。 \\begin{array}{|rc|} \\hline \\verb+\\color{black}{text}+ & \\color{black}{text} \\\\ \\verb+\\color{gray}{text}+ & \\color{gray}{text} \\\\ \\verb+\\color{silver}{text}+ & \\color{silver}{text} \\\\ \\verb+\\color{white}{text}+ & \\color{white}{text} \\\\ \\hline \\verb+\\color{maroon}{text}+ & \\color{maroon}{text} \\\\ \\verb+\\color{red}{text}+ & \\color{red}{text} \\\\ \\verb+\\color{yellow}{text}+ & \\color{yellow}{text} \\\\ \\verb+\\color{lime}{text}+ & \\color{lime}{text} \\\\ \\verb+\\color{olive}{text}+ & \\color{olive}{text} \\\\ \\verb+\\color{green}{text}+ & \\color{green}{text} \\\\ \\verb+\\color{teal}{text}+ & \\color{teal}{text} \\\\ \\verb+\\color{aqua}{text}+ & \\color{aqua}{text} \\\\ \\verb+\\color{blue}{text}+ & \\color{blue}{text} \\\\ \\verb+\\color{navy}{text}+ & \\color{navy}{text} \\\\ \\verb+\\color{purple}{text}+ & \\color{purple}{text} \\\\ \\verb+\\color{fuchsia}{text}+ & \\color{magenta}{text} \\\\ \\hline \\end{array}HTML色彩快速参考手册 公式标记与引用使用\\tag{yourtag}来标记公式，如果想在之后引用该公式，则还需要加上\\label{yourlabel}在\\tag之后，如： a := x^2-y^3 \\tag{\\*}\\label{\\*}为了引用公式，可以使用\\eqref{rlabel}，如： a+y^3 \\stackrel{\\eqref{\\*}}= x^2可以看到，通过超链接可以跳转到被引用公式位置。 Written with Macdown. 本文转载自 http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"LaTEX","slug":"LaTEX","permalink":"http://qinjiangbo.com/tags/LaTEX/"},{"name":"Hexo-Math","slug":"Hexo-Math","permalink":"http://qinjiangbo.com/tags/Hexo-Math/"}]},{"title":"Hexo中Marked.js与MathJax共存问题","slug":"solution-to-coexistance-of-markerjs-and-mathjax","date":"2016-08-14T14:26:35.000Z","updated":"2016-08-27T01:01:27.000Z","comments":true,"path":"solution-to-coexistance-of-markerjs-and-mathjax.html","link":"","permalink":"http://qinjiangbo.com/solution-to-coexistance-of-markerjs-and-mathjax.html","excerpt":"","text":"使Marked.js与MathJax共存因此我提供一个修改marked.js源码的方式来避开这些问题 针对下划线的问题，我决定取消_作为斜体转义，因为marked.js中*也是斜体的意思，所以取消掉_的转义并不影响我们使用markdown，只要我们习惯用*作为斜体字标记就行了。 针对marked.js与Mathjax对于个别字符二次转义的问题，我们只要不让marked.js去转义\\\\\\,\\\\{,\\\\}在MathJax中有特殊用途的字符就行了。 具体修改方式，用编辑器打开marked.js（在./node_modules/hexo-renderer-marked/node_modules/marked中） Step1: 1escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/, 替换成 1escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/, 这一步是在原基础上取消了对\\\\\\,\\\\{,\\\\}的转义(escape) Step2: 1em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 替换成 1em:/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 这样一来MathJax就能与marked.js共存了。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"LaTEX","slug":"LaTEX","permalink":"http://qinjiangbo.com/tags/LaTEX/"},{"name":"Hexo-Math","slug":"Hexo-Math","permalink":"http://qinjiangbo.com/tags/Hexo-Math/"}]},{"title":"[转]懂得尊重别人，才值得别人尊重","slug":"all-about-respect","date":"2016-08-12T19:33:20.000Z","updated":"2018-09-02T10:25:56.000Z","comments":true,"path":"all-about-respect.html","link":"","permalink":"http://qinjiangbo.com/all-about-respect.html","excerpt":"","text":"善待别人是一种胸怀，欣赏别人是一种境界，尊敬别人是一种智慧。正所谓“敬人者，人恒敬之”，生活中我们一定要学会尊敬周围的人。人之相敬，敬于德。所以，我们需要提高自己的品德修养，在尊敬别人的同时赢得别人的敬意。 脸庞因为笑容而美丽，生命因为希望而精彩。脸上的笑容如果说是对他人的布施，那么希望则是对自己的仁慈。人生在世，众生平等，然而每个人所处的环境并不相同。有的人生来富有，受百般人宠爱；有的人生来贫寒，身边亦没有亲人关怀。但不管怎样，人们都应该一如既往地对生活抱以热情的微笑，每个人都应该走出自己的一条路，活出自己的精彩。因为即使起点不同、出身不同、家境不同、遭遇不同，也可以抵达同样的顶峰。 也许这个过程会有所差异，有的人走得可能十分轻松，有的人可能一路坎坷，但无论如何，只要抱定一份虚怀若谷的决心，守住一份执着高贵的希望，就算是风雨兼程，也能活出属于自己的一片晴空。 一个年轻人自小颇有慧根，于是只身前往法华寺剃发修行。老住持见小和尚有些造诣，便指名让他跟随自己修行。寺里的生活虽然清苦，但小和尚仍然对修行充满了向往。不过，住持似乎并不急于向他传经授学。小和尚刚刚安顿下不久，住持就找到他，对他说：“我知道你爱好读书写字，所以需要独立的空间，你便搬到隔壁的大房间去住吧！” 小和尚非常高兴，很快收拾东西告别了师兄弟住进了大房间。可第二天，小和尚一觉醒来后，住持又对他说：“你业障太重，恐怕无福享受这么大的房间，还是搬到小房间去吧！”小和尚虽然心中颇有些不满，但还是照住持的话做了。他本来以为搬回小房间之后就能随住持参禅了，谁知没过两日住持又提出让他搬回大房间去住。这次，小和尚尽量克制自己的气恼，心平气和地对住持说：“师父，我可以住在小房间里。”听到这话，住持立刻严厉斥责他，并要求他遵照自己的指示去做。 在接下来的日子里，依照师父的要求，小和尚不断地从大房间搬到小房间，又从小房间搬到大房间。他也曾表示抗议，但出于对住持师父的尊敬，他最终还是选择了服从。不知过了多少日子，小和尚忽然顿悟了，他想这也许正是住持锻炼自己心性的一种方式。于是，他再也不抗议，心平气和地接受住持的指示。结果，当他不再犹豫，不再不满，也不再恼怒后，住持就让他住定不动了。 当你埋怨得不到高人的指点或得不到他人的赏识时，其实不知道这正是一种修行。只有虚怀若谷地去迎接一切，你才能容纳一切，从而让自己变得精彩。正如以上故事，如果没有一个虚怀若谷的胸怀，你可能只看到住持的严厉和不可理喻，或者只看到修行的艰难和不易，却无法得知宽容地接受这一切正是修行的过程。我们可以把生活中大大小小的境遇都当成一场修行，然后通过每件小事去磨砺心智，陶冶品性。秉持着一颗虔诚的心，才能让自己变得更平和、更谦逊，生活也便能多几分惬意。 孔子说：“三人行，必有我师。”生活中，我们必须学会质疑，并学会尊师。有什么问题 ，那就多想几个为什么，或者多请教别人几次，把生活中的每个人、每件事都当成能使自己进步的老师，你便能真的进步了。生活中，要想最大限度地发挥你的才能，更大程度上得到社会的认可，就必须让自己谦虚一点，恭敬一点。一个人不怕得不到别人的尊重，最怕自己不尊重自己，只有正视自己的能力，你才能始终保持自己的尊严。真正的智者，一定心宽似海，容得下百川。在谦虚敬人的同时，不自轻自贱，不轻易对自己产生怀疑；否则，即使你是一颗蒙尘珠玉，也将被视为毫无价值的沙粒。 在曲折的生命旅途上，如果我们能够泅渡苦闷的心里冰河，谦虚一点，自爱一点，就相当于给了自己一缕温暖的阳光，就能够化解与消释一切困难与不幸，从而让我们的生命之旅变得更加顺畅和开阔。 原文地址：http://www.59xihuan.cn/content_21644.html","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"心灵鸡汤","slug":"心灵鸡汤","permalink":"http://qinjiangbo.com/tags/心灵鸡汤/"},{"name":"美文","slug":"美文","permalink":"http://qinjiangbo.com/tags/美文/"}]},{"title":"MySQL命令行操作","slug":"mysql-command-line-operations","date":"2016-08-12T18:36:01.000Z","updated":"2016-10-24T01:10:34.000Z","comments":true,"path":"mysql-command-line-operations.html","link":"","permalink":"http://qinjiangbo.com/mysql-command-line-operations.html","excerpt":"一、连接MYSQL。格式： mysql -h 主机地址 -u 用户名 －p 用户密码 例1：连接到本机上的MYSQL。首先在打开DOS窗口，然后进入目录 mysqlbin，再键入命令mysql -uroot -p，回车后提示你输密码，如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是：mysql＞","text":"一、连接MYSQL。格式： mysql -h 主机地址 -u 用户名 －p 用户密码 例1：连接到本机上的MYSQL。首先在打开DOS窗口，然后进入目录 mysqlbin，再键入命令mysql -uroot -p，回车后提示你输密码，如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是：mysql＞ 例2：连接到远程主机上的MYSQL。假设远程主机的IP为：110 .110.110.110，用户名为root,密码为abcd123。则键入以下命令： 1mysql -h110.110.110.110 -u root -p abcd123 （注:u与root可以不用加空格，其它也一样） 3、退出MySQL命令： exit （回车） 二、修改密码。格式：mysqladmin -u 用户名 -p 旧密码 password 新密码 1、例1：给root加个密码ab12。首先在DOS下进入目录mysqlbin，然后键入以下命令 (password 里面不要加命令符) 1mysqladmin -u root password ab12 注：因为开始时root没有密码，所以-p 旧密码一项就可以省略了。 2、例2：再将root的密码改为djg345。 1mysqladmin -u root -p ab12 password djg345 三、增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码” 例1、增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用以root用户连入MYSQL，然后键入以下命令： 1grant select,insert,update,delete on *.* to test1@\"%\" Identified by \"abc\"; 但例1增加的用户是十分危险的，你想如某个人知道test1的密码，那么他就可以在internet上的任何一台电脑上登录你的mysql数据库并对你的数据可以为所欲为了，解决办法见例2。 例2、增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机），这样用户即使用知道test2的密码，他也无法从internet上直接访问数据库，只能通过MYSQL主机上的web页来访问了。 1grant select,insert,update,delete on mydb.* to test2@localhost identified by \"abc\"; 如果你不想test2有密码，可以再打一个命令将密码消掉。 1grant select,insert,update,delete on mydb.* to test2@localhost identified by \"\";","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"},{"name":"MySQL","slug":"数据科学/MySQL","permalink":"http://qinjiangbo.com/categories/数据科学/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://qinjiangbo.com/tags/MySQL/"},{"name":"命令行","slug":"命令行","permalink":"http://qinjiangbo.com/tags/命令行/"}]},{"title":"Language Model Tools Usage of SRILM","slug":"language-model-tools-usage-of-srilm","date":"2016-08-12T15:43:21.000Z","updated":"2016-10-19T15:50:35.000Z","comments":true,"path":"language-model-tools-usage-of-srilm.html","link":"","permalink":"http://qinjiangbo.com/language-model-tools-usage-of-srilm.html","excerpt":"一、小数据 假设有去除特殊符号的训练文本trainfile.txt，以及测试文本testfile.txt，那么训练一个语言模型以及对其进行评测的步骤如下：","text":"一、小数据 假设有去除特殊符号的训练文本trainfile.txt，以及测试文本testfile.txt，那么训练一个语言模型以及对其进行评测的步骤如下： 1：词频统计 1ngram-count -text trainfile.txt -order 3 -write trainfile.count 其中-order 3为3-gram，trainfile.count为统计词频的文本 2：模型训练 1ngram-count -read trainfile.count -order 3 -lm trainfile.lm -interpolate -kndiscount 其中trainfile.lm为生成的语言模型，-interpolate和-kndiscount为插值与折回参数 3：测试（困惑度计算） 1ngram -ppl testfile.txt -order 3 -lm trainfile.lm -debug 2 &gt; file.ppl 其中testfile.txt为测试文本，-debug 2为对每一行进行困惑度计算，类似还有-debug 0 , -debug 1, -debug 3等，最后 将困惑度的结果输出到file.ppl。 二、大数据（BigLM） 对于大文本的语言模型训练不能使用上面的方法，主要思想是将文本切分，分别计算，然后合并。步骤如下： 1：切分数据 1split -l 10000 trainfile.txt filedir/ 即每10000行数据为一个新文本存到filedir目录下。 2：对每个文本统计词频 1make-bath-counts filepath.txt 1 cat ./counts -order 3 其中filepath.txt为切分文件的全路径，可以用命令实现：ls $(echo $PWD)/* &gt; filepath.txt，将统计的词频结果存放在counts目录下 3：合并counts文本并压缩 1merge-batch-counts ./counts 不解释 4：训练语言模型 1make-big-lm -read ../counts/*.ngrams.gz -lm ../split.lm -order 3 用法同ngram-counts 5: 测评（计算困惑度） 1ngram -ppl filepath.txt -order 3 -lm split.lm -debug 2 &gt; file.ppl","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"SRILM","slug":"SRILM","permalink":"http://qinjiangbo.com/tags/SRILM/"},{"name":"NLP","slug":"NLP","permalink":"http://qinjiangbo.com/tags/NLP/"}]},{"title":"Fisrt Bite of Hexo","slug":"fisrt-bite-of-hexo","date":"2016-08-11T17:24:51.000Z","updated":"2016-10-29T05:15:20.000Z","comments":true,"path":"fisrt-bite-of-hexo.html","link":"","permalink":"http://qinjiangbo.com/fisrt-bite-of-hexo.html","excerpt":"","text":"Markdown语法简要说明标题在 Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低。 # 一号标题 ## 二号标题 ### 三号标题 #### 四号标题 ##### 五号标题 ###### 六号标题 列表在 Markdown 中，你只需要在文字前面加上 - 就可以了 - 文本一 - 文本二 - 文本三 也可以加上 * 或者 + 来表示. * 文本一 * 文本二 * 文本三 效果如下: 文本一 文本二 文本三 链接和图片在 Markdown 中，插入链接不需要其他按钮，你只需要使用[显示文本](链接地址)这样的语法即可 [简书](http://jianshu.io) 效果如下:简书 在 Markdown 中，插入图片不需要其他按钮，你只需要使用![](图片链接地址)这样的语法即可 ![](https://obrxbqjbi.qnssl.com/blog/image/salt-lake.jpg) 效果如下: 引用在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了 &gt; 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 效果如下: 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 粗体和斜体Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。 *一盏灯*， 一片昏黄；**一简书**， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 效果如下: 一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 表格Markdown中的表格相对而言麻烦一点，但是还是非常简洁的。 | Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | 效果如下: Tables Are Cool col 3 is right-aligned 1600 col 2 is centered 12 zebra stripes are neat 1 显示链接中带括号的图片![][1] [1]: http://latex.codecogs.com/gif.latex?\\prod%20\\(n_{i}\\)+1 效果如下: 插入代码如果你是一名程序员，可以使用如下方法插入代码块. ` ` ` java public void sayHello() { System.out.println(&quot;Hello&quot;); } ` ` ` 效果如下: 123public void sayHello() &#123; System.out.println(\"Hello\");&#125; 插入数学公式对于需要写公式的数学生来说，Markdown是不二选择！ $$x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$$ 效果如下: x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://qinjiangbo.com/tags/生活/"},{"name":"技术","slug":"技术","permalink":"http://qinjiangbo.com/tags/技术/"}]},{"title":"基于双向链接表和HashMap实现的LRU缓存","slug":"lru-cache-based-on-double-linked-list","date":"2016-07-22T13:20:08.000Z","updated":"2016-10-19T15:55:58.000Z","comments":true,"path":"lru-cache-based-on-double-linked-list.html","link":"","permalink":"http://qinjiangbo.com/lru-cache-based-on-double-linked-list.html","excerpt":"","text":"一直在做关于缓存方面的研究，今天终于用非LinkedHashMap的方式将其实现了，Mark一下！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package hk.inso.service;import java.util.HashMap;/** * Created by IntelliJ IDEA. * Date: 8/10/15 3:25 PM * Author: Richard */public class LRUCache&lt;K, V&gt; &#123; /** * 构造一个内部类作为双向链接表的单个元素 */ class Entry&lt;K, V&gt; &#123; public V value; public K key; public Entry prev; public Entry next; public Entry(K key, V value) &#123; this.key = key; this.value = value; &#125; public String toString() &#123; return \"&#123;\"+key+\":\"+value+\"&#125;\"; &#125; &#125; public final int CAPACITY; private HashMap&lt;K, Entry&lt;K, V&gt;&gt; hashMap = new HashMap&lt;K, Entry&lt;K, V&gt;&gt;(); private Entry first = null; private Entry last = null; public LRUCache(int capacity) &#123; this.CAPACITY = capacity; &#125; /** * 往缓存里面添加元素 * @param key * @param value */ public synchronized void put(K key, V value) &#123; if(!hashMap.containsKey(key)) &#123; if(hashMap.size() &gt;= CAPACITY) &#123; hashMap.remove(last.key); remove(last); &#125; Entry entry = new Entry(key, value); addToFirst(entry); hashMap.put(key, entry); return; &#125; Entry entry = (Entry) hashMap.get(key); moveToFirst(entry); hashMap.put(key, entry); &#125; /** * 获取相应key对应的值 * @param key * @return */ public synchronized V get(K key) &#123; Entry&lt;K, V&gt; entry = hashMap.get(key); if (entry == null) &#123; return null; &#125; moveToFirst(entry); return entry.value; &#125; /** * 从双向链表中移除一个元素 * @param entry */ public synchronized void remove(Entry entry) &#123; if(entry.prev != null) &#123; //当前节点被移除，那么它的前一个元素的后继就变成了它当前的后继 entry.prev.next = entry.next; &#125;else&#123; //如果当前元素是第一个元素，则它的后继变成第一个元素 first = entry.next; &#125; if(entry.next != null) &#123; //如果当前节点不是最后一个元素，则它的后一个元素的前驱就是它当前的前驱 entry.next.prev = entry.prev; &#125;else&#123; //如果当前元素是最后一个元素，则它的前驱变成了最后一个元素 last = entry.prev; &#125; //同时也需要将其从HashMap中除掉 hashMap.remove(entry.key); &#125; /** * 设置当前元素为第一个元素 * @param entry */ public synchronized void moveToFirst(Entry entry) &#123; if(entry.prev != null) &#123; entry.prev.next = entry.next; &#125; else &#123; //如果该元素为首位，则不作任何改变 return; &#125; if(entry.next != null) &#123; entry.next.prev = entry.prev; &#125; else &#123; last = entry.prev; &#125; entry.next = first; first.prev = entry; //first只是一个指针，将指针移至第一个 first = entry; &#125; /** * 添加元素到链表，并将其放在队首 * @param entry */ public synchronized void addToFirst(Entry entry) &#123; if(first == null || last == null) &#123; first = last = entry; return; &#125; else &#123; entry.next = first; first.prev = entry; first = entry; &#125; &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); Entry entry = first; while (entry != null) &#123; stringBuilder.append(entry.toString()+\" \"); entry = entry.next; &#125; return stringBuilder.toString(); &#125;&#125;","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"算法","slug":"架构师/算法","permalink":"http://qinjiangbo.com/categories/架构师/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://qinjiangbo.com/tags/数据结构/"},{"name":"LRU","slug":"LRU","permalink":"http://qinjiangbo.com/tags/LRU/"},{"name":"HashMap","slug":"HashMap","permalink":"http://qinjiangbo.com/tags/HashMap/"}]},{"title":"DoubleLinkedList独立实现","slug":"implementation-of-double-linkedlist","date":"2016-07-18T15:21:50.000Z","updated":"2016-10-19T15:55:48.000Z","comments":true,"path":"implementation-of-double-linkedlist.html","link":"","permalink":"http://qinjiangbo.com/implementation-of-double-linkedlist.html","excerpt":"","text":"精彩继续，实现完SingleLinkedList之后，今天又实现了双向链接表，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387public class DoubleLinkedList&lt;E&gt; &#123; class Node&lt;E&gt; &#123; E element; Node prev; Node next; public Node(E element) &#123; //constructor with args this.element = element; &#125; public Node() &#123; //constructor without args &#125; @Override public String toString() &#123; return this.element.toString(); &#125; &#125; private Node first = null; private Node last = null; /** * 链接结点到链表首部 * @param node */ private void linkFirst(Node node) &#123; if (first == null || last == null) &#123; first = last = node; &#125; node.next = first; first.prev = node; first = node; &#125; /** * 链接结点到链表尾部 * @param node */ private void linkLast(Node node) &#123; last.next = node; node.prev = last; last = node; &#125; /** * 链接一个结点到链表中间 * @param node1 要链接的结点 * @param node2 链接点位置的结点 * example: * [插入前]node -&gt; node2 -&gt; node3 * [插入后]node -&gt; node1 -&gt; node2 -&gt; node3 */ private void link(Node node1, Node node2) &#123; Node node = node2.prev; node.next = node1; node1.prev = node; node1.next = node2; node2.prev = node1; &#125; /** * 移除某个节点 * @param node */ public void unlink(Node node) &#123; Node prevNode = node.prev; Node nextNode = node.next; prevNode.next = nextNode; nextNode.prev = prevNode; &#125; /** * 移除首结点 */ private void unlinkFirst() &#123; first = first.next; first.prev = null; &#125; /** * 移除尾结点 */ private void unlinkLast() &#123; last = last.prev; last.next = null; &#125; /** * 根据索引获取结点 * @param index * @return */ private Node getNode(int index) &#123; Node node = first; Node currentNode = new Node(); if (index == 0) &#123; currentNode = first; &#125; if (index &gt;= size()) &#123; throw new IndexOutOfBoundsException(errMessage(index)); &#125; else &#123; int i = 0; while (i &lt;= index) &#123; if (node != null) &#123; currentNode = node; node = node.next; &#125; i++; &#125; &#125; return currentNode; &#125; /** * 统计链表里面所有元素的个数 * @return 总的元素的个数 */ public int size() &#123; Node node = first; int count = 0; while (node != null) &#123; count++; node = node.next; &#125; return count; &#125; /** * 错误消息显示 * @param index * @return */ private String errMessage(int index) &#123; return \"Size: \"+ size() + \", index: \"+ index; &#125; /** * 插入元素到链表中 * @param index * @param element */ public void insert(int index, E element) &#123; Node node = new Node&lt;E&gt;(element); if (index == 0) &#123; linkFirst(node); &#125; if (index &lt; 0 || index &gt;= size()) &#123; throw new IndexOutOfBoundsException(errMessage(index)); &#125; if (index == size() -1) &#123; linkLast(node); &#125; else &#123; Node node1 = getNode(index); link(node, node1); &#125; &#125; /** * 添加元素到链表 * @param element */ public void add(E element) &#123; Node node = new Node&lt;E&gt;(element); linkFirst(node); &#125; /** * 添加元素到链表首部 * @param element */ public void addFirst(E element) &#123; Node node = new Node&lt;E&gt;(element); linkFirst(node); &#125; /** * 添加元素到链表尾部 * @param element */ public void addLast(E element) &#123; Node node = new Node&lt;E&gt;(element); linkLast(node); &#125; /** * 移除指定索引下得元素 * @param index */ public void remove(int index) &#123; if (index == 0) &#123; unlinkFirst(); &#125; else if (index == size() -1 )&#123; unlinkLast(); &#125; else if (index &lt; 0 || index &gt;= size()) &#123; throw new IndexOutOfBoundsException(errMessage(index)); &#125; else &#123; Node node = getNode(index); unlink(node); &#125; &#125; /** * 移除最后一个元素 */ public void removeLast() &#123; unlinkLast(); &#125; /** * 移除第一个元素 */ public void removeFirst() &#123; unlinkFirst(); &#125; /** * 清空链表 */ public void clear() &#123; first = null; &#125; /** * 判断链表是否为空 * @return */ public boolean isEmpty() &#123; return first == null; &#125; /** * 重载toString方法 * @return */ @Override public String toString() &#123; Node node = first; StringBuilder stringBuilder = new StringBuilder(); if (node == null) &#123; return \"&#123;&#125;\"; &#125; else &#123; stringBuilder.append(\"&#123; \"); while (node != null) &#123; stringBuilder.append(\"[\"+ node.toString() +\"],\"); node = node.next; &#125; &#125; String result = stringBuilder.toString(); int index = result.lastIndexOf(\",\"); return result.substring(0, index) + \" &#125;\"; &#125; /** * 判断某个元素是否在链表中 * @param element * @return */ public boolean contains(E element) &#123; return getIndexOf(element) != -1; &#125; /** * 获取一个元素 * @param index * @return */ public E get(int index) &#123; return (E) getNode(index).element; &#125; /** * 获取最后一个元素 * @return */ public E getLast() &#123; return (E) last.element; &#125; /** * 获取第一个元素 * @return */ public E getFirst() &#123; return (E) first.element; &#125; /** * 替换特定索引的元素 * @param index * @param element */ public void replace(int index, E element) &#123; getNode(index).element = element; &#125; /** * 获取某个元素的索引,这里通常是第一次出现的索引 * @param element * @return */ public int getIndexOf(E element) &#123; int index = 0; if (element == null) &#123; for (Node&lt;E&gt; node = first; node != null; node = node.next) &#123; if (node.element == null) &#123; return index; &#125; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; node = first; node != null; node = node.next) &#123; if (node.element.equals(element)) &#123; return index; &#125; index++; &#125; &#125; return -1; &#125; /** * 获取某个元素最后一次出现的索引 * @param element * @return */ public int getLastIndexOf(E element) &#123; int index = size(); if (element == null) &#123; for (Node&lt;E&gt; node = last; node != null; node = node.prev) &#123; index--; if (node.element == null) &#123; return index; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; node = last; node != null; node = node.prev) &#123; index--; if (node.element.equals(element)) &#123; return index; &#125; &#125; &#125; return -1; &#125; /** * 移除某个元素第一次出现的位置 * @param element */ public void removeFirstOccurrence(E element) &#123; if (element == null) &#123; return; &#125; int index = getIndexOf(element); remove(index); &#125; /** * 移除某个元素最后一次出现的位置 * @param element */ public void removeLastOccurrence(E element) &#123; if (element == null) &#123; return; &#125; int index = getLastIndexOf(element); remove(index); &#125;&#125; 测试代码: 1234567891011121314151617181920public class TestDoubleLinkedList &#123; public static void main(String[] args) &#123; DoubleLinkedList&lt;User&gt; list = new DoubleLinkedList&lt;User&gt;(); list.add(new User(15, \"Amy\", \"Girl\")); list.add(new User(14, \"Tony\", \"Boy\")); list.add(new User(17, \"Masha\", \"Girl\")); list.addLast(new User(20, \"Shabby\", \"Boy\")); list.addFirst(new User(11, \"Sasa\", \"Girl\")); list.add(new User(14, \"Tony\", \"Boy\")); //System.out.println(list.contains(new User(14, \"Tony\", \"Boy\"))); //list.removeFirst(); //list.removeLast(); //list.removeLastOccurrence(new User(14, \"Tony\", \"Boy\")); //System.out.println(list.getLastIndexOf(new User(14, \"Tony\", \"Boy\"))); System.out.println(list.get(4)); System.out.println(list.toString()); &#125;&#125; 以上测试代码，所有功能均通过测试。完成！","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"算法","slug":"架构师/算法","permalink":"http://qinjiangbo.com/categories/架构师/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://qinjiangbo.com/tags/数据结构/"},{"name":"双向链表","slug":"双向链表","permalink":"http://qinjiangbo.com/tags/双向链表/"}]},{"title":"SingleLinkedList独立实现","slug":"implementation-of-single-linkedlist","date":"2016-07-16T15:28:43.000Z","updated":"2016-10-19T15:55:38.000Z","comments":true,"path":"implementation-of-single-linkedlist.html","link":"","permalink":"http://qinjiangbo.com/implementation-of-single-linkedlist.html","excerpt":"","text":"现在对Java原生数据结构特感兴趣，于是决定自己动手实现一些类，比如这个List类，在熟习了单链表和双链表的数据结构之后，终于实现了，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252package hk.inso.service;/** * Created by IntelliJ IDEA. * Date: 8/10/15 6:09 PM * Author: Richard */public class SingleLinkedList&lt;E&gt; &#123; private static class Node&lt;E&gt; &#123; private E element; private Node next; public Node(E element) &#123; //constructor with args this.element = element; &#125; public Node() &#123; //constructor without args &#125; @Override public String toString() &#123; return element.toString(); &#125; &#125; private Node first; private Node last; /** * 添加元素到链表头部 * @param element */ public void add(E element) &#123; Node&lt;E&gt; node = new Node&lt;E&gt;(element); linkFirst(node); &#125; /** * 添加元素到链表尾部 * @param element */ public void addLast(E element) &#123; Node&lt;E&gt; node = new Node&lt;E&gt;(element); linkLast(node); &#125; /** * 根据索引移除元素 * @param index */ public void remove(int index) &#123; if (index == 0) &#123; unlinkFirst(); &#125; else&#123; Node node = getNode(index); unlink(node); &#125; &#125; /** * 移除链表中最后一个元素 */ public void removeLast() &#123; unlinkLast(); &#125; /** * 将元素插入指定链表索引为止 * @param index * @param element */ public void insert(int index, E element) &#123; Node&lt;E&gt; node1 = new Node&lt;E&gt;(element); if(index == 0) &#123; linkFirst(node1); &#125; else &#123; Node node2 = getNode(index); link(node1, node2); &#125; &#125; /** * 获取某个元素 * @param index * @return */ public E get(int index) &#123; Node&lt;E&gt; node = getNode(index); E element = node.element; return element; &#125; /** * 统计链表里面所有元素的个数 * @return 总的元素的个数 */ public int size() &#123; int count = 0; Node node = first; while (node != null) &#123; count++; node = node.next; &#125; return count; &#125; /** * toString方法实现 * @return */ @Override public String toString() &#123; Node node = first; StringBuilder stringBuilder = new StringBuilder(); if(node == null) &#123; return \"&#123;&#125;\"; &#125; while (node != null) &#123; stringBuilder.append(\"[\" + node.element.toString() +\"],\"); node = node.next; &#125; String result = stringBuilder.toString(); int index = result.lastIndexOf(\",\"); return result.substring(0, index); &#125; /** * 插入结点到链表中间 * 插入前 * node2-&gt;node3-&gt;node4 * 插入后 * node2-&gt;node1-&gt;node3-&gt;node4 * @param node1 要插入的结点 * @param node2 插入结点位置结点 */ private void link(Node node1, Node node2) &#123; node1.next = node2; Node prevNode = getPrevNode(node2); prevNode.next = node1; &#125; /** * 插入结点到链表首部 * @param node */ private void linkFirst(Node node) &#123; if(first == null || last == null) &#123; first = last = node; &#125; else &#123; node.next = first; first = node; &#125; &#125; /** * 插入结点到链表尾部 * @param node */ private void linkLast(Node node) &#123; last.next = node; last = node; &#125; /** * 从链表中间移除当前结点 * @param node */ private void unlink(Node node) &#123; Node prevNode = getPrevNode(node); prevNode.next = node.next; &#125; /** * 移除头部的结点 */ private void unlinkFirst() &#123; first = first.next; &#125; /** * 移除尾部的结点 */ private void unlinkLast() &#123; Node prevNode = getPrevNode(last); prevNode.next = null; last = prevNode; &#125; /** * 寻找当前结点的前一个结点 * @param node 当前结点 * @return */ private Node getPrevNode(Node node) &#123; //这里多走了一步 // Node nodeItr = first.next; Node nodeItr = first; Node prevNode = new Node(); while (!nodeItr.equals(node)) &#123; prevNode = nodeItr; nodeItr = nodeItr.next; &#125; return prevNode; &#125; /** * 根据索引查找链表中得数据 * @param index * @return 链表结点 */ private Node getNode(int index) &#123; Node node = first; Node currentNode = new Node(); if (index == 0) &#123; //continue &#125; if (index &gt;= size()) &#123; throw new IndexOutOfBoundsException(errMessage(index)); &#125; else &#123; int i = 0; while (i &lt;= index) &#123; if(node != null) &#123; currentNode = node; //注意这里有递增 node = node.next; &#125; i++; &#125; &#125; return currentNode; &#125; /** * 错误消息显示 * @param index * @return */ private String errMessage(int index) &#123; return \"Size: \"+ size() + \", index: \"+ index; &#125;&#125; 测试代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package hk.inso.test;import hk.inso.service.SingleLinkedList;/** * Created by IntelliJ IDEA. * Date: 8/11/15 4:58 PM * Author: Richard */public class TestSingleLinkedList &#123; public static void main(String[] args) &#123; SingleLinkedList&lt;User&gt; list = new SingleLinkedList&lt;User&gt;(); list.add(new User(5, \"Jimmy\", \"Girl\")); list.add(new User(7, \"Tom\", \"Boy\")); list.addLast(new User(6, \"Amy\", \"Girl\")); System.out.println(list.toString()); &#125;&#125;class User &#123; private int age; private String name; private String gender; public User(int age, String name, String gender) &#123; this.age = age; this.name = name; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"age=\" + age + \", name='\" + name + '\\'' + \", gender='\" + gender + '\\'' + '&#125;'; &#125;&#125; 以上代码均测试通过！","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"算法","slug":"架构师/算法","permalink":"http://qinjiangbo.com/categories/架构师/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://qinjiangbo.com/tags/数据结构/"},{"name":"单向链表","slug":"单向链表","permalink":"http://qinjiangbo.com/tags/单向链表/"}]},{"title":"LinkedList实现基于LRU算法的缓存","slug":"lru-cache-based-on-linkedlist","date":"2016-07-13T15:38:03.000Z","updated":"2016-10-19T15:55:30.000Z","comments":true,"path":"lru-cache-based-on-linkedlist.html","link":"","permalink":"http://qinjiangbo.com/lru-cache-based-on-linkedlist.html","excerpt":"","text":"学过操作系统的人都知道LRU页面切换算法，其实这个算法不仅仅只是能在页面切换中应用到，在缓存中也有很实际的应用。最典型的实现方式是采用LinkedHashMap来实现这个缓存，大家可以在Java源码里面看到这个类的作者关于这个的描述，不过全是英文，但是却明确提到过。 下面废话不多说，直接展示我自己关于这个算法实现的代码吧，亲测通过： 核心算法代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.Hashtable;import java.util.LinkedList;/** * Created by IntelliJ IDEA. * Date: 8/7/15 4:46 PM * Author: Richard */public class LinkedListCache&lt;Object&gt;&#123; //默认的缓存大小 private static int CAPACITY = 0; //引用一个双向链接表 private LinkedList&lt;Object&gt; list; //构造函数 public LinkedListCache(int capacity) &#123; this.CAPACITY = capacity; list = new LinkedList&lt;Object&gt;(); &#125; //添加一个元素 public synchronized void put(Object object) &#123; if(list != null &amp;&amp; list.contains(object)) &#123; list.remove(object); &#125; removeLeastVisitElement(); list.addFirst(object); &#125; //移除最近访问次数最少的元素 private synchronized void removeLeastVisitElement() &#123; int size = size(); //注意，这儿必须得是CAPACITY - 1否则所获的size比原来大1 if(size &gt; (CAPACITY - 1) ) &#123; Object object = list.removeLast(); System.out.println(\"本次被踢掉的元素是:\" + object.toString()); &#125; &#125; //获取第N个索引下面的元素 public synchronized Object get(int index) &#123; return list.get(index); &#125; //清空缓存 public synchronized void clear() &#123; list.clear(); &#125; //获取链接表的大小 public int size() &#123; if(list == null) &#123; return 0; &#125; return list.size(); &#125; //toString方法 public String toString() &#123; return list.toString(); &#125;&#125; 测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package hk.inso.www.test;import hk.inso.www.cache.LRUCache;import hk.inso.www.cache.LinkedListCache;import hk.inso.www.cache.MapCache;import java.util.Iterator;import java.util.Map;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;/** * Created by Richard on 8/5/15. */public class CacheTest &#123; public static void main(String[] args) throws InterruptedException &#123; LinkedListCache linkedListCache = new LinkedListCache&lt;String&gt;(5); linkedListCache.put(\"1\"); System.out.println(linkedListCache.toString()); Thread.sleep(1000); linkedListCache.put(\"2\"); System.out.println(linkedListCache.toString()); Thread.sleep(1000); linkedListCache.put(\"3\"); System.out.println(linkedListCache.toString()); Thread.sleep(1000); linkedListCache.put(\"4\"); System.out.println(linkedListCache.toString()); Thread.sleep(1000); linkedListCache.put(\"5\"); System.out.println(linkedListCache.toString()); Thread.sleep(1000); linkedListCache.put(\"1\"); System.out.println(linkedListCache.toString()); Thread.sleep(1000); linkedListCache.put(\"6\"); System.out.println(linkedListCache.toString()); Thread.sleep(1000); linkedListCache.put(\"4\"); System.out.println(linkedListCache.toString()); Thread.sleep(1000); linkedListCache.put(\"7\"); System.out.println(linkedListCache.toString()); &#125;&#125; 不要吐槽这个哈，时间关系，就直接这么演示了，你可以直接拷贝下来运行就可以了。希望可以帮到你！","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"算法","slug":"架构师/算法","permalink":"http://qinjiangbo.com/categories/架构师/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://qinjiangbo.com/tags/数据结构/"},{"name":"LRU","slug":"LRU","permalink":"http://qinjiangbo.com/tags/LRU/"}]},{"title":"C/S架构程序多种类服务器之间实现单点登录","slug":"single-sign-on-system-architecture","date":"2016-07-12T18:30:41.000Z","updated":"2016-10-19T15:48:55.000Z","comments":true,"path":"single-sign-on-system-architecture.html","link":"","permalink":"http://qinjiangbo.com/single-sign-on-system-architecture.html","excerpt":"在项目开发的过程中，经常会出现这样的情况：我们的产品包括很多，以QQ举例，如登陆、好友下载、群下载、网络硬盘、QQ游戏、QQ音乐等，总不能要求用户每次输入用户名、密码吧，为解决这个问题，高手提出了一个很好的跨平台、跨应用的身份验证解决方案，那就是——单点登录（Single Sign On），简称为 SSO。","text":"在项目开发的过程中，经常会出现这样的情况：我们的产品包括很多，以QQ举例，如登陆、好友下载、群下载、网络硬盘、QQ游戏、QQ音乐等，总不能要求用户每次输入用户名、密码吧，为解决这个问题，高手提出了一个很好的跨平台、跨应用的身份验证解决方案，那就是——单点登录（Single Sign On），简称为 SSO。 一、 什么是单点登录（Single Sign On）单点登录（SSO，Single Sign-on）是一种方便用户访问多个系统的技术，用户只需在登录时进行一次注册，就可以在多个系统间自由穿梭，不必重复输入用户名和密码来确定身份。 二、如何实现单点登录（SSO）1、整体设计思路首先我们要明确单点登录的运行模式，即统一身份验证，在解决方案中，一般通过认证服务器（LoginServer）实现用户身份验证，验证通过后将自动随机生成身份验证票据，并将身份验证票据发送给用户，待用户访问其他应用时，只对身份验证票据进行合法性验证即可。 2、认证服务器（LoginServer）实现的功能在解决方案中，LoginServer提供的功能包括用户名/密码验证、身份验证票据的生成、身份验证票据的合法性验证这三个最基本的功能，其他功能可以根据用户的需求，自行扩展。由于LoginServer基于网络通讯，使用TCP或UDP协议，所以其本身是跨平台的，只要各个应用在开发过程中使用的开发语言支持身份验证票据验证，即可调用身份验证平台进行相关的操作。 3、身份验证票据所谓身份验证票据就是用户身份验证通过后，发给用户用以标示身份验证通过的信息。身份验证票据中可以加密保存用户的身份信息或某一特定的验证信息等，一般使用对称加密，方便在身份验证票据合法性的检查中进行相应的解密。C/S结构的程序，票据保存比较方便，只要其他应用能够取到就可以。 4、验证票据用户拿到身份验证票据后，当登录B系统时，把这个票据传给B系统，B系统拿这个票据系统到LoginServer进行认证即可。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"}],"tags":[{"name":"C/S","slug":"C-S","permalink":"http://qinjiangbo.com/tags/C-S/"},{"name":"SSO","slug":"SSO","permalink":"http://qinjiangbo.com/tags/SSO/"}]},{"title":"BinarySearchTree查找二叉树独立实现","slug":"implementation-of-binary-search-tree","date":"2016-07-12T15:15:45.000Z","updated":"2016-10-19T15:55:22.000Z","comments":true,"path":"implementation-of-binary-search-tree.html","link":"","permalink":"http://qinjiangbo.com/implementation-of-binary-search-tree.html","excerpt":"","text":"先看看实现了哪些功能吧？（1）构造二叉树 （2）遍历二叉树结点 （3）搜索二叉树结点 （4）删除二叉树结点 （5）判断结点是否存在二叉树 上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426package hk.inso.service;/** * Created by IntelliJ IDEA. * Date: 8/17/15 11:45 PM * Author: Richard */public class BinarySearchTree &#123; /** * 根结点，是所有遍历的入口 */ private Node root = null; private StringBuilder stringBuilder = new StringBuilder(); /** * 插入一个元素 * @param value */ public void add(int value) &#123; Node node = new Node(); node.setValue(value); insert(node); &#125; /** * 显示root * @return */ public String getRoot() &#123; return \"Root&#123; \" + root.value + \" &#125;\"; &#125; /** * 移除一个特定的元素 * @param value */ public void remove(int value) &#123; Node node = new Node(); node.setValue(value); delete(node); &#125; /** * 获取某个元素 * @param value * @return */ public String get(int value) &#123; Node node = new Node(); node.setValue(value); Node resultNode = search(node); return \"parent: \" + resultNode.parent + \" left: \" + resultNode.left + \" right: \" + resultNode.right; &#125; /** * 判断是否包含某个元素 * @param value * @return */ public boolean contains(int value) &#123; Node node = new Node(); node.setValue(value); Node resutlNode = search(node); if (resutlNode == null) &#123; return false; &#125; return true; &#125; /** * 先序遍历树，输出全部元素 * @return */ @Override public String toString()&#123; //很重要，flush StringBuilder对象 stringBuilder = new StringBuilder(); StringBuilder sb = new StringBuilder(); sb.append(\"BSTree&#123; \"); String midString = midTraverse(root); //String midString = preTraverse(root); //String midString = postTraverse(root); int index = midString.lastIndexOf(\", \"); midString = midString.substring(0, index); sb.append(midString); sb.append(\" &#125;\"); return sb.toString(); &#125; /** * 中序遍历树结构 * @param node * @return */ private String midTraverse(Node node) &#123; if (node == null) &#123; return null; &#125; midTraverse(node.left); stringBuilder.append(node.value + \", \"); midTraverse(node.right); return stringBuilder.toString(); &#125; /** * 先序遍历树结构 * @param node * @return */ private String preTraverse(Node node) &#123; if (node == null) &#123; return null; &#125; stringBuilder.append(node.value + \", \"); preTraverse(node.left); preTraverse(node.right); return stringBuilder.toString(); &#125; /** * 后序遍历树结构 * @param node * @return */ private String postTraverse(Node node) &#123; if (node == null) &#123; return null; &#125; postTraverse(node.left); postTraverse(node.right); stringBuilder.append(node.value + \", \"); return stringBuilder.toString(); &#125; /** * 插入结点到二叉查找树 * @param node */ private void insert(Node node)&#123; if (root == null) &#123; root = node; &#125; else &#123; boolean flag = true; Node iteratorNode = root; while (flag) &#123; //无子结点 if (iteratorNode.left == null &amp;&amp; iteratorNode.right == null) &#123; appendNode(node, iteratorNode); flag = false; &#125; //有子结点 else &#123; //插入比当前结点小的结点 if (node.value &lt; iteratorNode.value) &#123; if (iteratorNode.left == null) &#123; appendNode(node, iteratorNode); flag = false; &#125; else &#123; iteratorNode = iteratorNode.left; &#125; &#125; //插入比当前结点大的结点 else &#123; if (iteratorNode.right == null) &#123; appendNode(node, iteratorNode); flag = false; &#125; else &#123; iteratorNode = iteratorNode.right; &#125; &#125; &#125; &#125; &#125; &#125;; /** * 添加子结点 * @param node * @param parent */ private void appendNode(Node node, Node parent) &#123; if (node.value &lt; parent.value) &#123; parent.left = node; node.parent = parent; &#125; else &#123; parent.right = node; node.parent = parent; &#125; &#125; /** * 删除结点 * @param node */ private void delete(Node node)&#123; //找到该结点 Node resultNode = search(node); if (resultNode.value == root.value) &#123; if (resultNode.left != null &amp;&amp; resultNode.right != null) &#123; Node maxNode = getMaxNode(resultNode.left); maxNode.right = resultNode.right; resultNode.right.parent = maxNode; root = resultNode.left; &#125; else if (resultNode.left == null &amp;&amp; resultNode.right != null) &#123; root = resultNode.right; &#125; else if (resultNode.right == null &amp;&amp; resultNode.left != null) &#123; root = resultNode.left; &#125; else if (resultNode.right == null &amp;&amp; resultNode.left == null) &#123; root = null; &#125; &#125; else if (resultNode.left == null &amp;&amp; resultNode.right == null) &#123; if (resultNode.isLeft()) &#123; resultNode.parent.left = null; &#125; else &#123; resultNode.parent.right = null; &#125; &#125; else if (resultNode.left != null &amp;&amp; resultNode.right == null) &#123; if (resultNode.isLeft()) &#123; resultNode.parent.left = resultNode.left; &#125; else &#123; resultNode.parent.right = resultNode.left; &#125; resultNode.left.parent = resultNode.parent; &#125; else if (resultNode.left == null &amp;&amp; resultNode.right != null) &#123; if (resultNode.isLeft()) &#123; resultNode.parent.left = resultNode.right; &#125; else &#123; resultNode.parent.right = resultNode.right; &#125; resultNode.right.parent = resultNode.parent; &#125; /** * 将当前结点的右孩子连接到左子树的最大子结点，并作为这个最大子结点的右孩子 */ else if (resultNode.left != null &amp;&amp; resultNode.right != null) &#123; if (resultNode.isLeft()) &#123; resultNode.left.parent = resultNode.parent; resultNode.parent.left = resultNode.left; Node maxNode = getMaxNode(resultNode.left); maxNode.right = resultNode.right; resultNode.right.parent = maxNode; &#125; else &#123; resultNode.left.parent = resultNode.parent; resultNode.parent.right = resultNode.left; Node maxNode = getMaxNode(resultNode.left); maxNode.right = resultNode.right; resultNode.right.parent = maxNode; &#125; &#125; &#125;; /** * 查找某个元素 * @param node * @return */ private Node search(Node node)&#123; Node iteratorNode = root; if (node == null || iteratorNode == null) &#123; return null; &#125; boolean flag = true; while (flag) &#123; if (node != null &amp;&amp; iteratorNode != null &amp;&amp; node.value &lt; iteratorNode.value) &#123; if (iteratorNode.isLeaf())&#123; node = null; flag = false; &#125; else &#123; iteratorNode = iteratorNode.left; &#125; &#125; if (node != null &amp;&amp; iteratorNode != null &amp;&amp; node.value &gt; iteratorNode.value) &#123; if (iteratorNode.isLeaf())&#123; node = null; flag = false; &#125; else &#123; iteratorNode = iteratorNode.right; &#125; &#125; //一定要分析清楚这个地方 if (node != null &amp;&amp; iteratorNode != null &amp;&amp; node.value == iteratorNode.value) &#123; node = iteratorNode; flag = false; &#125; if (iteratorNode == null || node == null) &#123; node = null; flag = false; &#125; &#125; return node; &#125;; /** * 获取当前结点作为根的树下最小值的结点 * @param node * @return */ private Node getMinNode(Node node) &#123; Node iteratorNode = node; while (iteratorNode.left != null) &#123; iteratorNode = iteratorNode.left; &#125; return iteratorNode; &#125; /** * 获取当前结点作为根的树下最大值的结点 * @param node * @return */ private Node getMaxNode(Node node) &#123; Node iteratorNode = node; while (iteratorNode.right != null) &#123; iteratorNode = iteratorNode.right; &#125; return iteratorNode; &#125; /** * 内部类，树结点 */ class Node&#123; private Node parent = null; private Node left = null; private Node right = null; private int value = 0; public Node(Node parent, Node left, Node right, int value) &#123; this.parent = parent; this.left = left; this.right = right; this.value = value; &#125; public Node() &#123; //constructor without args &#125; public Node getParent() &#123; return parent; &#125; public void setParent(Node parent) &#123; this.parent = parent; &#125; public Node getLeft() &#123; return left; &#125; public void setLeft(Node left) &#123; this.left = left; &#125; public Node getRight() &#123; return right; &#125; public void setRight(Node right) &#123; this.right = right; &#125; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125; /** * 是否为左孩子 * @return */ public boolean isLeft() &#123; if (this.parent.left != null &amp;&amp; this.value == this.parent.left.value) &#123; return true; &#125; return false; &#125; /** * 是否为叶子结点 * @return */ public boolean isLeaf() &#123; if (this.left == null &amp;&amp; this.right == null) &#123; return true; &#125; return false; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"value=\" + value + \"&#125;\"; &#125; &#125;&#125; 测试代码： 123456789101112131415161718192021public class TestBinarySearchTree &#123; private static BinarySearchTree binarySearchTree = new BinarySearchTree(); public static void main(String[] args) &#123; binarySearchTree.add(14); binarySearchTree.add(20); binarySearchTree.add(7); binarySearchTree.add(11); binarySearchTree.add(19); binarySearchTree.add(2); binarySearchTree.add(44); binarySearchTree.add(32); binarySearchTree.add(4); binarySearchTree.remove(32); System.out.println(binarySearchTree.toString()); System.out.println(binarySearchTree.contains(32)); &#125;&#125; 查看结果: 12BSTree&#123; 2, 4, 7, 11, 14, 19, 20, 44 &#125;false 以上源码所对应的结点的值均为Int型，如果你感兴趣，可以更改源码，扩展它的类型。以上代码均通过测试。","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"算法","slug":"架构师/算法","permalink":"http://qinjiangbo.com/categories/架构师/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://qinjiangbo.com/tags/数据结构/"},{"name":"二叉树","slug":"二叉树","permalink":"http://qinjiangbo.com/tags/二叉树/"}]},{"title":"练出更好的团队","slug":"get-better-team","date":"2016-07-09T18:41:10.000Z","updated":"2017-05-24T13:14:06.000Z","comments":true,"path":"get-better-team.html","link":"","permalink":"http://qinjiangbo.com/get-better-team.html","excerpt":"","text":"长期以来，工作组织的概念一直在进化。除了敏捷实践者们，还有很多人也发现了自组织的团队效率会比较高。一个表现优秀的团队并不一定会有一个强有力的管理者，但这并不是说在这样的团队中缺乏领导力；在这样的团队中，领导力是分散在各个团队成员中的，并没有集中到一个人身上。 这种领导力分散的现象并不能说明Blake和Moulton的结论已经过时了，关注人员和结果，并让两者达到平衡对团队来说依然非常重要。为了检查团队中是否存在这样的平衡，Alexis Phillips和Phillip Sandahl以Blake的领导力坐标为基础，提出了一个团队诊断模型。他们将管理侧的“以人为本”转换成对团队积极性的评测，以反映团队的精神状态和工作愉悦程度。他们将“关注结果”转换成团队生产率，表示交付结果的成效。他们将每个领域的关键能力都一一提炼出来，令人惊奇的是，他们得出的结果列表跟敏捷的思维定式高度一致。 Phillips和Sandahl提炼出了下面这些团队积极性因素： 信任—所有团队成员彼此之间都相互信任。 尊敬—将所有人都当作宝贵的合作伙伴。 沟通—非暴力沟通的重点是解决方案。 交互—给出反馈，接收反馈，并将冲突当作改进的机会。 友情—团队成员能感受到同理心，会表达善意，并且彼此都是朋友乐观—团队成员能看到积极的方面。 价值观的多样性 — 多样性能激发新点子和不同的观点。 他们的生产率因素是： 目标和战略— 团队有清晰的产品目标和愿景。优先级已经确定。同事们会对目标的实现做出迅速反馈。 齐心协力 — 人们能感受到和这个愿景之间的联系，能让个人目标跟团队目标保持一致。 问责制 — 所有人都竭尽全力并且认为自己要为产品负责。 资源 — 除了简单呈现出完成工作所需的技能和设备之外，这个因素还允许团队去寻找或请求缺失的资源 决策制定 — 团队被鼓励在他们那个层级上做决定。 积极性 — 这表明他们能够接受变化，并且有创造性。 团队领导力 — 团队作为一个集体有很强的领导力，意味着在任何特定情况下，团队的“本地领导”将会接受邀请，鼓励团队朝同一个方向前进。","categories":[{"name":"经验感悟","slug":"经验感悟","permalink":"http://qinjiangbo.com/categories/经验感悟/"},{"name":"心灵港","slug":"经验感悟/心灵港","permalink":"http://qinjiangbo.com/categories/经验感悟/心灵港/"}],"tags":[{"name":"Team","slug":"Team","permalink":"http://qinjiangbo.com/tags/Team/"},{"name":"合作","slug":"合作","permalink":"http://qinjiangbo.com/tags/合作/"}]},{"title":"Java8-default,defender关键字","slug":"java8-default-keyword","date":"2016-06-26T15:08:25.000Z","updated":"2016-10-19T15:49:59.000Z","comments":true,"path":"java8-default-keyword.html","link":"","permalink":"http://qinjiangbo.com/java8-default-keyword.html","excerpt":"","text":"今天研究Java8源码的时候发现了一个神奇的关键字，default，我一直以为default只是在switch里面起作用，其余的就没什么了。然而，知道我看到它作为方法限定符之后我的三观刷新了。。。居然还可以作为权限访问符！ 写了几个例子研究一下：源码1： 12345678public interface DefaultAPI &#123; public void add(int a, int b); default void minus(int a, int b) &#123; System.out.println(\"a-b=\"+(a-b)); &#125;&#125; 12345678public interface DefaultAPI2 &#123; default void minus(int a, int b) &#123; System.out.println(a+\"-\"+b+\"=\"+(a-b)); &#125; public void add(int a, int b);&#125; 从源码可以看出，两个接口的方法都相同，只是打印的有点区别。那么这会有什么影响呢？ 子类继承这两个接口的时候，需要重写这个方法，而这两个方法已经被实现啦！没错，interface接口中可以写具体实现方法啦！ 这个作用是为了lambda表达式与之前的jdk接口紧密联系起来，向下兼容，更方便开发者利用计算机的资源。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://qinjiangbo.com/tags/JDK8/"}]},{"title":"设计模式学习之策略模式","slug":"design-pattern-strategy","date":"2016-06-21T19:54:09.000Z","updated":"2017-03-09T17:54:25.000Z","comments":true,"path":"design-pattern-strategy.html","link":"","permalink":"http://qinjiangbo.com/design-pattern-strategy.html","excerpt":"","text":"什么是策略模式策略模式（Strategy Design Pattern）定义算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的“变化”独立于使用算法的客户。 策略模式类图 策略模式实例分析先从一个简单的例子开始（盗用Head First图片哈），假设你的公司要你做一个鸭子模拟的游戏SimDuck，这个很简单吧，我们只需要熟悉OO设计原则即可以利用继承，多态来做。于是，我们有了以下的设计图： 这幅图我们并不感觉复杂，在Duck类里面定义了quack(), swim(), display()三个方法，然后display()方法被子类重写了，原因其实很简单，因为不同的鸭子他们的外观是不一样的，所以这里我们要重写这个display()方法。 好啦，这样我们的任务就完成了，然后开开心心给老板提交项目，结果老板也觉得还不错。过了两天，老板说，我们的游戏里面鸭子最好能飞就好啦！然后给你改，觉得如何？所以我们就直接在Duck里面加入了fly()方法，如下： 这样就好了吗？答案是否定的！因为，并不是所有的鸭子都会飞，所以这样就不行！也许有人还在说，我们可以在子类中重写fly()方法，然后在方法体里面啥也不写！有人会说这样也行？！那么，为什么不行呢？！但是这个不是一个好的设计，因为，如果我们加入一个玩具鸭子呢？模型鸭子呢？他们既不会游泳，也不会叫也不会飞。肿么办？我们是不希望他们具备飞这个属性或者能力的，对吧？但是这种继承的方法会使得我们在子类中存在这个属性或者方法，那是与实际情况不符的！ 有人想到了接口，那么用接口会如何呢？我们可以把我们需要的方法单独写在一个接口里面，供那些子类来调用和实现，比如我们可以有Flyable和Quackable接口，里面分别写上抽象方法fly()， quack()。然后子类继承Duck父类并实现这两个接口。如下图： 这样一来我们只需要在需要实现fly()或者quack()的类里面实现相应的接口即可。这样不是很好吗？你觉得呢？方正我当时觉得挺好的，不过当你往下看你就会注意到问题了。假设我们采用这种方式了，那么，我们会遇到什么情况呢？那就是你要多写很多很多行代码，因为每一个鸭子的子类中都会实现这两个方法中的一个，方法重复率太高了！而且我们需要去修改这个方法的时候，我们需要改动的代码数量可是相当庞大的！所以这个方式看似可以，实则不行！ 那么我们如何处理这个问题呢？其实有很多种方法，这里博主介绍自己的方法，那就是将我们项目变化的部分单独提取“封装”起来，让它不对项目的其它部分不受到影响。具体的做法是，我们可以将quack()和fly()两种方法，原则上变化部分还有display()，但是我们的display()方法只有一种类型的行为，也就是只有一个方法，所以这里没有必要把它单独写在一个接口里面，直接写在子类里面实现就好了。那么，下面我们可以将这个结构画出来了， 那么这样一来，我们就可以相同的方法添加许多其他的行为，而不会影响到这个原有的功能。这样程序里面个对象的耦合程度就比较低了，更便于管理和维护。我们需要在Duck类里面引用这两个接口的对象，但是不要求初始化，因为这个初始化的工作是交给子类去做的。那么，你可能会问，不是说“面向接口编程，不要面向实现”嘛！额，好吧，的确是这样的，我们也确实这么干了，但是我们要知道，到目前为止，我们还没有接触到其他的设计模式，所以目前就先这么写着，到了后面我们会有解决方法的，比如采用getBehavior()方法来动态地加载某个接口，这样我们就可在运行时动态地实现相关地方法。当然，这个本小节不提到。那么，我们现在这个设计已经很不错了，至少灵活性很高，而且非常好维护。概念图如下： 我们可以看到，这里面多了两个方法peformQuack()和performFly()，这是为了替换那个接口中得两个方法，我们不希望子类访问到父类的成员变量的方法里面去，这样耦合程度太高，而且也不利于维护。因为我们采用的是继承，所以子类直接能用flyBehavior和quackBehavior两个父类的成员变量。所以，我们就用peformQuack()和performFly()这两个方法来“封装”它。首先来看父类Duck的源码： 1234567891011121314151617181920212223public abstract class Duck &#123; FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck() &#123; &#125; public void performFly() &#123; flyBehavior.fly(); &#125; public void performQuack() &#123; quackBehavior.quack(); &#125; public abstract void display(); public void swim() &#123; System.out.println(\"All ducks float, even decoys!\"); &#125;&#125; 再看子类MollardDuck的源码： 12345678910111213public class MallardDuck extends Duck &#123; public MallardDuck() &#123; quackBehavior = new Quack(); flyBehavior = new FlyWithWings(); &#125; @Override public void display() &#123; System.out.println(\"I am a real mallard duck!\"); &#125; &#125; 它里面自己实现了display()的方法，打印了一条输出语句。接着FlyBehavior和QuackBehavior接口的源码： 1234567891011121314151617public interface FlyBehavior &#123; /** * 飞行方法 */ public void fly(); &#125; public interface QuackBehavior &#123; /** * 鸭叫方法 */ public void quack(); &#125; 这两个源码不解释了，很明显。实现者这两个行为方法的行为子类：飞行行为的： 123456789101112131415public class FlyWithWings implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(\"I am flying!\"); &#125;&#125;public class FlyNoWay implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(\"I can't fly!\"); &#125;&#125; 叫声行为： 1234567891011121314public class Quack implements QuackBehavior &#123; @Override public void quack() &#123; System.out.println(\"Quack!\"); &#125;&#125;public class MuteQuack implements QuackBehavior &#123; @Override public void quack() &#123; System.out.println(\"&lt;&lt; Silence! &gt;&gt;\"); &#125;&#125; 关于测试代码很简单，调用一个子类测试一下相关功能就好了。需求改变啦，需要增加一个模型鸭，然后加上火箭做推动器，然它飞起来。那么，这个时候呢，我们得先看一下这个需求，需要动态地指定flyBehavior行为对吧？因为它之前不会飞，然后要求它经过改变之后能飞，那就需要我们在运行时给它动态指定行为，这个时候，我们需要在Duck里面增加两个setter方法，如下： 1234567public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior;&#125; public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior;&#125; 那么我们就可以动态指定方法了。然后需要增加一个火箭助推行为： 1234567public class FlyRocketPowered implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(\"I am flying with a rocket!\"); &#125;&#125; 这样，我们就有了动态指定的对象了。测试代码如下： 12345678910public class Test2 &#123; public static void main(String[] args) &#123; Duck modelDuck = new ModelDuck(); modelDuck.performFly(); modelDuck.setFlyBehavior(new FlyRocketPowered()); modelDuck.performFly(); &#125;&#125; 运行结果是：12I can't fly!I am flying with a rocket! 是不是觉得这种方式挺方便的呢？支持拓展和维护，系统是非常具有弹性的。不管以后增加什么行为都可用相同的方式添加进去。当然啦，实际生产生活中得情况肯定比这个复杂很多，所以我们要根据实际情况来定。 关于策略模式我们有几点需要提醒大家：OO的基础：抽象，封装，多态，继承OO的原则： 封装“变化”； 多用组合，少用继承； 针对接口编程，不要针对实现编程； 第（3）点简单举个例子读者自己好好体会，感受一下区别： 针对实现编程：12Dog dog = new Dog();dog.bark(); 针对接口编程：12Animal animal = new Dog(); //上转型接口回调animal.makeSound(); 适用范围：适用于那些外在表现行为不同的场合，比如出行方式，通信方式等等，这些都是有不同的表现形式的，我们此时就可以采取策略模式。 设计模式GitHub仓库地址：https://github.com/QinJiangbo/DesignPatterns","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qinjiangbo.com/tags/设计模式/"},{"name":"策略模式","slug":"策略模式","permalink":"http://qinjiangbo.com/tags/策略模式/"}]},{"title":"（转）Submodual","slug":"submodual-problem","date":"2016-06-14T01:39:05.000Z","updated":"2017-04-02T12:57:02.000Z","comments":true,"path":"submodual-problem.html","link":"","permalink":"http://qinjiangbo.com/submodual-problem.html","excerpt":"","text":"子模态定义子模态是集合函数的一种性质。一个集合函数$f(x)$的定义要满足下面这个性质 f:2^\\Omega \\to \\mathbb R \\tag {1}即$f(x)$的定义域为集合$\\Omega$的任何一个子集，值域为实数集。而这个集合函数如果要满足子模态性质的话，还需要满足下面三个等价条件中的任何一个。 对于任何一个$X,Y\\subset\\Omega$且$X\\subset Y$，以及对任何一个$X, Y\\in\\Omega$，下面的式子一定成立。f(X\\cup x)−f(X)\\geq f(Y\\cup x)−f(Y) 对于任何一个$X,Y\\subset\\Omega$，下面的式子一定成立。f(X)+f(Y)\\geq f(X\\cup Y)+f(X\\cap Y) 对于任何一个$X\\subset\\Omega$及$x_1,x_2\\in\\Omega$，下面的式子一定成立f(X\\cup x_1)+f(X\\cup x_2)\\geq f(X\\cup x_1,x_2)+f(X) 读者可以很轻松的验证这几个条件是等价的，这里就不去证明了。 根据这些条件，我们可以得出下面这个结论。设$f_1(x),f_2(x),⋯,f_k(x)$都是有子模态性质的函数，$c_1,c_2,⋯,c_k$是非负实数，则下面这个函数 F(x) = \\sum_{i=1}^k c_if_i(x) \\tag {2}仍然是子模态的。即多个子模态函数的非负线性组合仍然是子模态函数。这个推论可以很简单的验证出来，这里也就懒得做证明的。 子模态与贪心方法接下来的问题就是，子模态这个函数性质有什么用。简单来说子模态这个函数性质在组合优化中很有用。特别是针对保持$\\mid x \\mid$的大小固定，然后去求$f(x)$的最大值这种问题。 这个子模态性质可以保证我们在贪心求解这个问题得到的解不会差，事实上贪心解$f(x)$的值不会小于$(1−1/e)∗OPT$，其中$OPT$为最优解。在该问题的贪心求解过程中，我们是从$0$开始构建目标集合$x$的。每一步我们将一个新的元素加入到$x$中，迭代$k$步。我们以$X_i$来代表迭代$i$次之后的$x$集合，初始$x_0 = \\phi$。我们对下一个要加入的节点$u$的选取的贪心规则为 u=argmax_u f(X_{i−1}\\cup u) \\tag {3}现在我们要证明在此贪心规则下 f(x)\\geq(1−\\frac{1}{e})*OPT \\tag {4}为此，我们先证明一个引理 f(A\\cup B)−f(A)\\leq\\sum_{j=1}^k[f(A\\cup b_j)−f(A)] \\tag {5}其中$B=b_1,⋯,b_k$.此时我们定义$B_i=b_1,⋯,b_i$，则 \\begin {aligned} f(A\\cup B)−f(A) &= \\sum_{i=1}^k[f(A\\cup B_i)−f(A\\cup B_{i−1})] \\\\\\ &=\\sum_{i=1}^k[f(A\\cup B_{i−1}\\cup b_i)−f(A\\cup B_{i−1})] \\\\\\ &≤\\sum_{j=1}^k[f(A\\cup b_j)−f(A)] \\end {aligned} \\tag {6}设最优解为$T=t_1,⋯,t_k,\\delta_i=f(X_i)−f(X_{i−1})$,根据上面这个不等式我们可以推出 \\begin {aligned} f(T) &≤ f(X_i\\cup T) \\\\\\ &=f(X_i\\cup T)−f(X_i)+f(X_i) \\\\\\ &≤\\sum_{j=1}^k[f(X_i\\cup t_j)−f(X_i)]+f(X_i) \\\\\\ &≤\\sum_{j=1}^k[\\delta_{i+1}]+f(X_i) \\\\\\ &=f(X_i)+k\\delta_{i+1} \\end {aligned} \\tag {7}综上我们可以得出这个结论 \\delta_{i+1}≥\\frac{1}{k}[f(T)−f(X_i)] \\tag {8}所以 \\begin {aligned} f(X_{i+1})&=f(X_i)+\\delta_{i+1} \\\\\\ &≥f(X_i)+\\frac{1}{k}[f(T)−f(X_i)] \\\\\\ &=(1−\\frac{1}{k})f(X_i)+\\frac{1}{k}f(T) \\end {aligned} \\tag {9}通过上面的递推式，我们可以给出$f(X_i)$ f(X_i)≥[1−(1−\\frac{1}{k})^i]f(T) \\tag {10}这个是简单的递推数列求通项，这里也就懒得证明了。所以 f(X_k)≥[1−(1−\\frac{1}{k})^k]f(T)≥[1−\\frac{1}{e}]f(T) \\tag {11}这就是贪心大法好的证明。 本文参考链接: http://spiritsaway.info/algorithm/submodual.html","categories":[{"name":"数据科学","slug":"数据科学","permalink":"http://qinjiangbo.com/categories/数据科学/"}],"tags":[{"name":"子模","slug":"子模","permalink":"http://qinjiangbo.com/tags/子模/"},{"name":"Submodual","slug":"Submodual","permalink":"http://qinjiangbo.com/tags/Submodual/"}]},{"title":"Ubuntu14.04安装AMD显卡驱动双屏显示器完全解决方案","slug":"solution-to-dual-display-with-amd-in-ubuntu14","date":"2016-05-26T16:20:42.000Z","updated":"2016-10-19T15:50:28.000Z","comments":true,"path":"solution-to-dual-display-with-amd-in-ubuntu14.html","link":"","permalink":"http://qinjiangbo.com/solution-to-dual-display-with-amd-in-ubuntu14.html","excerpt":"","text":"网上有很多方法，但是针对AMD显卡的方案不多，所以笔者今天想写一篇关于AMD显卡的教程。 首先，进入这个网址下载一些东东：[http://support.amd.com/zh-cn/download/desktop?os=Ubuntu+x86+64] (http://support.amd.com/zh-cn/download/desktop?os=Ubuntu+x86+64)，说明一下，这个网址是针对Ubuntu64位系统的，32位的用户请选择32位的文件下载。下哪些文件呢？ 有三个： AMD Catalyst™ 14.12 Proprietary Ubuntu 14.04 x86_64 Video Driver for Graphics Accelerators 大概是52MB AMD Catalyst™ 14.12 Proprietary Ubuntu 14.04 x86_64 Minimal Video Driver for Graphics Accelerators (Non-X Support) 大概是61MB AMD Catalyst™ 14.12 Proprietary Ubuntu 14.04 x86_64 Catalyst Control Center 这三个文件是很重要的，相信读者朋友们看到此文时这几个文件有了相应的更新，大家子集注意一下下载对应的文件即可。 首先我们要先安装第二个文件（Non-X Support），这个是可以直接安装不需要依赖的，下载下来以后这些都是deb包，所以双击用新立得安装即可，接着安装第一个文件，其次是第三个（这是一个图形化管理工具，可以在里面设置显示器分辨率，不过在我这儿好想不太管用，如果你的可以的话，那就直接设置就好了，打开命令是# amdcccle。如果不行的话，接着往下看。 好的，下面我相信大家可以输入一下命令了 1# xrandr 这是一个很重要的显示器分辨率管理工具 当输入这个命令时，我们会得到显示器的相应的信息如下： 12345678910111213Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192LVDS connected primary 1366x768+0+0 (normal left inverted right x axis y axis) 309mm x 174mm 1366x768 60.0*+ 1360x768 60.0 1280x768 60.0 1280x720 60.0 1024x768 60.0 1024x600 60.0 800x600 60.0 800x480 60.0 640x480 60.0 DFP1 disconnected (normal left inverted right x axis y axis)CRT1 disconnected (normal left inverted right x axis y axis) 解释一下，LVDS是你的笔记本的显示器，DFP1和CRT1是外接显示器，接上显示器的时候看这两个中哪个连接上了就用哪个。 笔者的是CRT1。 下面介绍几个命令： 为了增加你所需要的分辨率，可以用（1920*1080为例） 1# cvt 1920 1080 得到如下输出： 12# 1920x1080 59.96 Hz (CVT 2.07M9) hsync: 67.16 kHz; pclk: 173.00 MHzModeline \"1920x1080_60.00\" 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync 那么，下面这个Modeline后面的这一串就是我们要添加的显示器分辨率模式 好了，得到以后我们要新建这个模式呀，用这个命令： 1# xrandr --newmode \"1920x1080_60.00\" 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync 然后这个分辨率就新建成功了，下面我们要把它添加进去 1# xrandr --addmode CRT1(这个是我的型号，大家对应上) \"1920x1080_60.00\" 好的，添加成功，到了最后一步啦！应用到这个显示器上面去！ 1# xrandr --output CRT1 --mode \"1920x1080_60.00\" 发现你的屏幕是不duang,duang ~ 一下子就变成了你想要的分辨率呢？ 好啦，就写这么多了，有什么问题大家可以在下面留言～","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://qinjiangbo.com/tags/Ubuntu/"},{"name":"AMD","slug":"AMD","permalink":"http://qinjiangbo.com/tags/AMD/"},{"name":"Display","slug":"Display","permalink":"http://qinjiangbo.com/tags/Display/"}]},{"title":"Java网络编程之多线程Client-Server","slug":"java-net-multi-thread-server","date":"2016-05-13T15:01:00.000Z","updated":"2016-10-19T15:51:04.000Z","comments":true,"path":"java-net-multi-thread-server.html","link":"","permalink":"http://qinjiangbo.com/java-net-multi-thread-server.html","excerpt":"","text":"Java C/S架构网络编程的多线程版相比单线程版更复杂，同时效率也更高。 Client 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package exercise01; import java.io.*; import java.net.*; public class ThreadedClient &#123; private String hostname; private int port; Socket socket = null; public ThreadedClient(String hostname, int port)&#123; //constructor of the Client class this.hostname = hostname; this.port = port; &#125; public void connect() throws UnknownHostException, IOException&#123; System.out.println(\"Attempting connect to \"+ hostname +\":\"+port); socket = new Socket(hostname,port); System.out.println(\"Connection established!\"); &#125; public void readResponse() throws IOException&#123; String userInput; BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(\"Response from the server:\"); while((userInput = reader.readLine() )!= null )&#123; System.out.println(userInput); &#125; &#125; public void askForTime() throws IOException&#123; BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); writer.write(\"Time?\"); writer.newLine(); writer.flush(); &#125; public static void main(String[] argv)&#123; //create an object for the current class Client ThreadedClient client = new ThreadedClient(\"localhost\",8181); try&#123; //trying to establish a connection to the server client.connect(); //ask the server for time client.askForTime(); //if connection succeed, return the input contents client.readResponse(); &#125;catch(UnknownHostException ukhe)&#123; //if the host not found System.err.println(\"Host unknown! Connection can not be established!\"); &#125;catch(IOException ioe)&#123; //if the server doesn't work System.err.println(\"Connection can not be established! The server may not be on! Check the error message! \"+ioe.getMessage()); &#125; &#125; &#125; Server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package exercise01; import java.io.*; import java.net.*; import java.util.Date; public class ThreadedServer &#123; private ServerSocket serverSocket; private int port; public ThreadedServer(int port)&#123; this.port = port; &#125; //get the thread started public void start() throws IOException&#123; System.out.println(\"Starting the server at the port: \"+ port); serverSocket = new ServerSocket(port); //instantial an object client Socket client = null; //set the condition to be true for endless loops while(true)&#123; System.out.println(\"Waiting for clients...\"); client = serverSocket.accept(); System.out.println(\"The following client has connected: \" + client.getInetAddress().getCanonicalHostName()); //A client has connected to the server Thread thread = new Thread(new SocketClientHandler(client)); thread.start(); &#125; &#125; /** * instantial an object of class ThreadedServer and start the server * * @param argv */ public static void main(String[] argv)&#123; //set the default port number int port = 8181; try&#123; //initializing the socket server ThreadedServer threadedServer = new ThreadedServer(port); threadedServer.start(); &#125;catch(IOException ioe)&#123; ioe.printStackTrace(); &#125; &#125; &#125; class SocketClientHandler implements Runnable&#123; private Socket client; public SocketClientHandler(Socket client)&#123; this.client = client; &#125; /** * get the thread started by the run method */ @Override public void run() &#123; try&#123; System.out.println(\"Thread started with name: \" + Thread.currentThread().getName()); readResponse(); &#125;catch(IOException ioe)&#123; ioe.printStackTrace(); &#125;catch(InterruptedException ie)&#123; ie.printStackTrace(); &#125; &#125; /** * read the response from the server * @throws IOException * @throws InterruptedException */ private void readResponse() throws IOException, InterruptedException &#123; String userInput; BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream())); while(( userInput = reader.readLine())!= null)&#123; if(userInput.equals(\"Time?\"))&#123; System.out.println(\"Request to send time! Sending time current.\"); sendTime(); break; &#125; &#125; &#125; /** * send the current time to the server * @throws IOException * @throws InterruptedException */ private void sendTime() throws IOException, InterruptedException &#123; BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(client.getOutputStream())); writer.write(new Date().toString()); writer.flush(); writer.close(); &#125; &#125;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qinjiangbo.com/tags/Java/"},{"name":"网络编程","slug":"网络编程","permalink":"http://qinjiangbo.com/tags/网络编程/"}]},{"title":"Java网络编程之单线程Client-Server","slug":"java-net-single-thread-server","date":"2016-05-12T14:54:05.000Z","updated":"2016-10-19T15:50:56.000Z","comments":true,"path":"java-net-single-thread-server.html","link":"","permalink":"http://qinjiangbo.com/java-net-single-thread-server.html","excerpt":"","text":"Java网络编程知识整理如下思维导图: 单线程的C/S架构实现如下： Client: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package exercise01; import java.io.*; import java.net.*; public class Client &#123; private String hostname; private int port; Socket socket = null; public Client(String hostname, int port)&#123; //constructor of the Client class this.hostname = hostname; this.port = port; &#125; public void connect() throws UnknownHostException, IOException&#123; System.out.println(\"Attempting connect to \"+ hostname +\":\"+port); socket = new Socket(hostname,port); System.out.println(\"Connection established!\"); &#125; public void readResponse() throws IOException&#123; String userInput; BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(\"Response from the server:\"); while((userInput = reader.readLine() )!= null )&#123; System.out.println(userInput); &#125; &#125; public static void main(String[] argv)&#123; //create an object for the current class Client Client client = new Client(\"localhost\",8181); try&#123; //trying to establish a connection to the server client.connect(); //if connection succeed, return the input contents client.readResponse(); &#125;catch(UnknownHostException ukhe)&#123; //if the host not found System.err.println(\"Host unknown! Connection can not be established!\"); &#125;catch(IOException ioe)&#123; //if the server doesn't work System.err.println(\"Connection can not be established! The server may not be on! Check the error message! \"+ioe.getMessage()); &#125; &#125; &#125; Server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package exercise01; import java.net.*; import java.io.*; public class Server &#123; private ServerSocket serverSocket; private int port; public Server(int port)&#123; this.port = port; &#125; public void startServer() throws IOException&#123; System.out.println(\"Starting the socket server at the port: \" + port); serverSocket = new ServerSocket(port); //Listen the clients. Block until one connects System.out.println(\"Waiting for clients...\"); Socket client = serverSocket.accept(); //A client has connected and send the welcome message sendMessage(client); &#125; //send the display message private void sendMessage(Socket client) throws IOException &#123; BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(client.getOutputStream())); writer.write(\"Hello. You are connected to a Simple Socket Server.\"); writer.flush(); writer.close(); &#125; /** * Create a server object and start the server * * @param argv */ public static void main(String[] argv)&#123; int port = 8181; //start the server try&#123; Server server = new Server(port); server.startServer(); &#125;catch(IOException ioe)&#123; ioe.printStackTrace(); &#125; &#125; &#125;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://qinjiangbo.com/tags/Java/"},{"name":"网络编程","slug":"网络编程","permalink":"http://qinjiangbo.com/tags/网络编程/"}]},{"title":"Sublime Text 3比较好用的插件记录","slug":"useful-plugins-of-sublime-text3","date":"2016-05-06T16:09:52.000Z","updated":"2016-10-19T15:50:10.000Z","comments":true,"path":"useful-plugins-of-sublime-text3.html","link":"","permalink":"http://qinjiangbo.com/useful-plugins-of-sublime-text3.html","excerpt":"","text":"最近在忙前端的事情，用的是sublime text 3.0版本，为了提高工作的效率，使用了一些比较实用的插件，这些插件都是在sublime的插件列表里面可以找得到的，都是很不错的插件，推荐大家将这些全部安装，具体效果是什么样的，估计从名字可以看出一部分，然后可以向大家保证的是这些插件基本上能解决我们使用sublime敲代码时候的一些困扰。 如何安装插件详见：https://packagecontrol.io/installation (1)ColorPicker (2)BracketHilighter (3)Emmet (4)DocBlockr (5)CSS3 (6)AndyPHP (7)ConvertToUTF8 (8)jQuery (9)JsFormat (10)SublimeCodeIntel (11)CSSFormat 具体每一个是啥作用可以参考这篇博客！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"}],"tags":[{"name":"Sublime Text","slug":"Sublime-Text","permalink":"http://qinjiangbo.com/tags/Sublime-Text/"},{"name":"插件","slug":"插件","permalink":"http://qinjiangbo.com/tags/插件/"}]},{"title":"中文和Unicode互相转化","slug":"mutual-tranformations-between-chinese-and-unicode","date":"2016-05-06T15:42:59.000Z","updated":"2016-10-19T15:50:19.000Z","comments":true,"path":"mutual-tranformations-between-chinese-and-unicode.html","link":"","permalink":"http://qinjiangbo.com/mutual-tranformations-between-chinese-and-unicode.html","excerpt":"","text":"Unicode转中文 123String unicode = \"\\u6211\\u7231\\u7956\\u56fd\";String result = new String(unicode.getBytes(\"UTF-8\"), \"UTF-8\");System.out.println(result); 结果：我爱祖国 中文转Unicode 1234567String chinese = \"我爱祖国\";StringBuffer unicode = new StringBuffer();for (int i = 0; i &lt; chinese.length(); i++) &#123; Character character = chinese.charAt(i); unicode.append(\"\\\\u\" + Integer.toHexString(character));&#125;System.out.println(unicode.toString()); 结果：\\u6211\\u7231\\u7956\\u56fd","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Unicode","slug":"Unicode","permalink":"http://qinjiangbo.com/tags/Unicode/"},{"name":"中文","slug":"中文","permalink":"http://qinjiangbo.com/tags/中文/"}]},{"title":"各种实用的WebService","slug":"useful-web-services","date":"2016-04-26T15:52:38.000Z","updated":"2016-10-19T15:50:44.000Z","comments":true,"path":"useful-web-services.html","link":"","permalink":"http://qinjiangbo.com/useful-web-services.html","excerpt":"","text":"天气预报Web服务，数据来源于中国气象局123&lt;a href=\"http://www.webxml.com.cn/WebServices/WeatherWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/WeatherWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/WeatherWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; IP地址来源搜索 WEB 服务（是目前最完整的IP地址数据）123&lt;a href=\"http://www.webxml.com.cn/WebServices/IpAddressSearchWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/IpAddressSearchWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/IpAddressSearchWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 随机英文、数字和中文简体字 WEB 服务123&lt;a href=\"http://www.webxml.com.cn/WebServices/RandomFontsWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/RandomFontsWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/RandomFontsWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 中国邮政编码 &lt;-&gt; 地址信息双向查询/搜索 WEB 服务123&lt;a href=\"http://www.webxml.com.cn/WebServices/ChinaZipSearchWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ChinaZipSearchWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ChinaZipSearchWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 验证码图片 WEB 服务 支持中文、字母、数字 图像和多媒体123&lt;a href=\"http://www.webxml.com.cn/WebServices/ValidateCodeWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ValidateCodeWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ValidateCodeWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; Email 电子邮件地址验证 WEB 服务123&lt;a href=\"http://www.webxml.com.cn/WebServices/ValidateEmailWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ValidateEmailWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ValidateEmailWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 中文简体字&lt;-&gt;繁体字转换 WEB 服务123&lt;a href=\"http://www.webxml.com.cn/WebServices/TraditionalSimplifiedWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/TraditionalSimplifiedWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/TraditionalSimplifiedWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 中文 &lt;-&gt; 英文双向翻译 WEB 服务123&lt;a href=\"http://www.webxml.com.cn/WebServices/TranslatorWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/TranslatorWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/TranslatorWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 火车时刻表 WEB 服务 （第六次提速最新列车时刻表）123&lt;a href=\"http://www.webxml.com.cn/WebServices/TrainTimeWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/TrainTimeWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/TrainTimeWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 中国股票行情数据 WEB 服务（支持深圳和上海股市的基金、债券和股票）123&lt;a href=\"http://www.webxml.com.cn/WebServices/ChinaStockWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ChinaStockWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ChinaStockWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 即时外汇汇率数据 WEB 服务123&lt;a href=\"http://www.webxml.com.cn/WebServices/ExchangeRateWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ExchangeRateWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ExchangeRateWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 腾讯QQ在线状态 WEB 服务123&lt;a href=\"http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/webservices/qqOnlineWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 中国电视节目预告（电视节目表） WEB 服务123&lt;a href=\"http://www.webxml.com.cn/webservices/ChinaTVprogramWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/webservices/ChinaTVprogramWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/webservices/ChinaTVprogramWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 外汇-人民币即时报价 WEB 服务123&lt;a href=\"http://www.webxml.com.cn/WebServices/ForexRmbRateWebService.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ForexRmbRateWebService.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ForexRmbRateWebService.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 中国股票行情分时走势预览缩略图 WEB 服务123&lt;a href=\"http://www.webxml.com.cn/webservices/ChinaStockSmallImageWS.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/webservices/ChinaStockSmallImageWS.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/webservices/ChinaStockSmallImageWS.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 国内飞机航班时刻表 WEB 服务123&lt;a href=\"http://www.webxml.com.cn/webservices/DomesticAirline.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/webservices/DomesticAirline.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/webservices/DomesticAirline.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 中国开放式基金数据 WEB 服务123&lt;a href=\"http://www.webxml.com.cn/WebServices/ChinaOpenFundWS.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ChinaOpenFundWS.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/ChinaOpenFundWS.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt; 股票行情数据 WEB 服务（支持香港、深圳、上海基金、债券和股票；支持多股票同时查询）123&lt;a href=\"http://www.webxml.com.cn/WebServices/StockInfoWS.asmx\" target=\"_blank\"&gt;Endpoint&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/StockInfoWS.asmx?disco\" target=\"_blank\"&gt;Disco&lt;/a&gt; &lt;a href=\"http://www.webxml.com.cn/WebServices/StockInfoWS.asmx?wsdl\" target=\"_blank\"&gt;WSDL&lt;/a&gt;","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"}],"tags":[{"name":"Web Service","slug":"Web-Service","permalink":"http://qinjiangbo.com/tags/Web-Service/"}]},{"title":"Jdom解析XML","slug":"parsing-xml-with-jdom","date":"2016-04-17T14:29:42.000Z","updated":"2016-10-19T15:53:45.000Z","comments":true,"path":"parsing-xml-with-jdom.html","link":"","permalink":"http://qinjiangbo.com/parsing-xml-with-jdom.html","excerpt":"","text":"XML是一种广为使用的可扩展标记语言，java中解析xml的方式有很多，最常用的像jdom、dom4j、sax等等。前两天刚好有个程序需要解析xml，就学了下jdom，写了个小例子，这里做个学习笔记。 要使用jdom解析xml文件，需要下载jdom的包，我使用的是jdom-1.1。解压之后，将lib文件夹下的.jar文件以及build文件夹下的jdom.jar拷贝到工程文件夹下，然后就可以使用jdom操作xml文件了。 一、读取xml文件假设有这样一个xml文件： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;sys-config&gt; &lt;jdbc-info&gt; &lt;driver-class-name&gt;oracle.jdbc.driver.OracleDriver&lt;/driver-class-name&gt; &lt;url&gt;jdbc:oracle:thin:@localhost:1521:database&lt;/url&gt; &lt;user-name&gt;why&lt;/user-name&gt; &lt;password&gt;why&lt;/password&gt; &lt;/jdbc-info&gt; &lt;provinces-info&gt; &lt;province id=\"hlj\" name=\"黑龙江\"&gt; &lt;city id=\"harb\"&gt;哈尔滨&lt;/city&gt; &lt;city id=\"nj\"&gt;嫩江&lt;/city&gt; &lt;/province&gt; &lt;province id=\"jl\" name=\"吉林\"&gt;&lt;/province&gt; &lt;/provinces-info&gt; &lt;/sys-config&gt; 首先，用 org.jdom.input.SAXBuilder 这个类取得要操作的xml文件，会返回一个 org.jdom.Document 对象，这里需要做一下异常处理。然后，取得这个xml文件的根节点，org.jdom.Element 代表xml文件中的一个节点，取得跟节点后，便可以读取xml文件中的信息。利用 org.jdom.xpath.XPath 可以取得xml中的任意制定的节点中的信息。 例如，要取得上面文件中的 下的 中的内容，先取得这个节点Element driverClassNameElement = (Element)XPath.selectSingleNode(rootEle, “//sys-config/jdbc-info/driver-class-name”)，注意，根节点前要使用两个 “/“ ，然后，用 driverClassNameElement.getText() 便可以取得这个节点下的信息。 如果一个节点下有多个名称相同的子节点，可以用XPath.selectNodes()方法取得多个子节点的List，遍历这个List就可以操作各个子节点的内容了。 下面是我写的读取上面xml文件的例子，比起文字描述更直观一些吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.why.jdom; import java.io.IOException; import java.util.Iterator; import java.util.List; import org.jdom.input.SAXBuilder; import org.jdom.xpath.XPath; import org.jdom.Document; import org.jdom.Element; import org.jdom.JDOMException; public class ReadXML &#123; /** * @param args */ public static void main(String[] args) &#123; SAXBuilder sax = new SAXBuilder(); try &#123; Document doc = sax.build(\"src/config.xml\"); Element rootEle = doc.getRootElement(); Element driverClassNameElement = (Element)XPath.selectSingleNode(rootEle, \"//sys-config/jdbc-info/driver-class-name\"); String driverClassName = driverClassNameElement.getText(); System.out.println(\"driverClassName = \" + driverClassName); List provinceList = XPath.selectNodes(rootEle, \"//sys-config/provinces-info/province\"); for(Iterator it = provinceList.iterator();it.hasNext();)&#123; Element provinceEle = (Element)it.next(); String proId = provinceEle.getAttributeValue(\"id\"); String proName = provinceEle.getAttributeValue(\"name\"); System.out.println(\"provinceId = \" + proId + \" provinceName = \" + proName); List cityEleList = (List)provinceEle.getChildren(\"city\"); for(Iterator cityIt = cityEleList.iterator();cityIt.hasNext();)&#123; Element cityEle = (Element)cityIt.next(); String cityId = cityEle.getAttributeValue(\"id\"); String cityName = cityEle.getText(); System.out.println(\" cityId = \" + cityId + \" cityName = \" + cityName); &#125; &#125; &#125; catch (JDOMException e) &#123; // TODO 自动生成 catch 块 e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO 自动生成 catch 块 e.printStackTrace(); &#125; &#125; &#125; 二、写xml文件 写xml文件与读取xml文件的操作类似，利用 org.jdom.output.XMLOutputter 就可以将处理好的xml输出到文件了。可以设置文件的编码方式，不过一般使用UTF-8就可以了。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 package com.why.jdom; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import org.jdom.Document; import org.jdom.Element; import org.jdom.output.XMLOutputter; public class WriteXML &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO 自动生成方法存根 Element rootEle = new Element(\"sys-config\"); Element provincesEle = new Element(\"provinces-info\"); Element provinceEle = new Element(\"province\"); provinceEle.setAttribute(\"id\",\"hlj\"); provinceEle.setAttribute(\"name\",\"黑龙江省\"); Element cityEle1 = new Element(\"city\"); cityEle1.setAttribute(\"id\",\"harb\"); cityEle1.addContent(\"哈尔滨\"); Element cityEle2 = new Element(\"city\"); cityEle2.setAttribute(\"id\",\"nj\"); cityEle2.addContent(\"嫩江\"); provinceEle.addContent(cityEle1); provinceEle.addContent(cityEle2); provincesEle.addContent(provinceEle); rootEle.addContent(provincesEle); Document doc = new Document(rootEle); XMLOutputter out = new XMLOutputter(); // out.setFormat(Format.getCompactFormat().setEncoding(\"GBK\"));//设置文件编码，默认为UTF-8 String xmlStr = out.outputString(doc); System.out.println(xmlStr); try &#123; out.output(doc, new FileOutputStream(\"c:/test.xml\")); &#125; catch (FileNotFoundException e) &#123; // TODO 自动生成 catch 块 e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO 自动生成 catch 块 e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"Jdom","slug":"Jdom","permalink":"http://qinjiangbo.com/tags/Jdom/"},{"name":"XML","slug":"XML","permalink":"http://qinjiangbo.com/tags/XML/"}]},{"title":"HashMap vs. TreeMap vs. HashTable vs. LinkedHashMap","slug":"hash-map-vs-tree-map-vs-hash-table-vs-linked-hash-map","date":"2016-04-13T13:52:47.000Z","updated":"2016-10-19T15:54:31.000Z","comments":true,"path":"hash-map-vs-tree-map-vs-hash-table-vs-linked-hash-map.html","link":"","permalink":"http://qinjiangbo.com/hash-map-vs-tree-map-vs-hash-table-vs-linked-hash-map.html","excerpt":"","text":"Map is one of the most important data structures in Java. In this post, I will illustrate how to use different types of maps, such as HashMap, TreeMap, HashTable and LinkedHashMap. 1. Map Overview There are 4 commonly used implementations of Map in Java SE - HashMap, TreeMap, Hashtable and LinkedHashMap. If we use only one sentence to describe each implementation, it would be the following: HashMap is implemented as a hash table, and there is no ordering on keys or values. TreeMap is implemented based on red-black tree structure, and it is ordered by the key. LinkedHashMap preserves the insertion order Hashtable is synchronized, in contrast to HashMap. It has an overhead for synchronization. This is the reason that HashMap should be used if the program is thread-safe. 2. HashMapIf the key of a HashMap is a self-defined object, then the equals() and hashCode() contract need to be followed. 123456789101112131415161718192021222324252627282930313233class Dog &#123; String color; Dog(String c) &#123; color = c; &#125; public String toString()&#123; return color + \" dog\"; &#125;&#125;public class TestHashMap &#123; public static void main(String[] args) &#123; HashMap&lt;Dog, Integer&gt; hashMap = new HashMap&lt;Dog, Integer&gt;(); Dog d1 = new Dog(\"red\"); Dog d2 = new Dog(\"black\"); Dog d3 = new Dog(\"white\"); Dog d4 = new Dog(\"white\"); hashMap.put(d1, 10); hashMap.put(d2, 15); hashMap.put(d3, 5); hashMap.put(d4, 20); //print size System.out.println(hashMap.size()); //loop HashMap for (Entry&lt;Dog, Integer&gt; entry : hashMap.entrySet()) &#123; System.out.println(entry.getKey().toString() + \" - \" + entry.getValue()); &#125; &#125;&#125; Output: 123454 white dog - 5 black dog - 15 red dog - 10 white dog - 20 Note here, we add “white dogs” twice by mistake, but the HashMap accepts it. This does not make sense, because now we are confused with how many white dogs are really there. The Dog class should be defined as follows: 12345678910111213141516171819class Dog &#123; String color; Dog(String c) &#123; color = c; &#125; public boolean equals(Object o) &#123; return ((Dog) o).color.equals(this.color); &#125; public int hashCode() &#123; return color.length(); &#125; public String toString()&#123; return color + \" dog\"; &#125;&#125; Now the output is: 12343red dog - 10white dog - 20black dog - 15 The reason is that HashMap doesn’t allow two identical elements. By default, the hashCode() and equals() methods implemented in the Object class are used. The default hashCode() method gives distinct integers for distinct objects, and the equals() method only returns true when two references refer to the same object. Check out the hashCode() and equals() contract if this is not obvious to you. Check out the most frequently used methods for HashMap, such as iteration, print, etc. 3. TreeMapA TreeMap is sorted by keys. Let’s first take a look at the following example to understand the “sorted by keys” idea. 123456789101112131415161718192021222324252627282930313233343536class Dog &#123; String color; Dog(String c) &#123; color = c; &#125; public boolean equals(Object o) &#123; return ((Dog) o).color.equals(this.color); &#125; public int hashCode() &#123; return color.length(); &#125; public String toString()&#123; return color + \" dog\"; &#125;&#125;public class TestTreeMap &#123; public static void main(String[] args) &#123; Dog d1 = new Dog(\"red\"); Dog d2 = new Dog(\"black\"); Dog d3 = new Dog(\"white\"); Dog d4 = new Dog(\"white\"); TreeMap&lt;Dog, Integer&gt; treeMap = new TreeMap&lt;Dog, Integer&gt;(); treeMap.put(d1, 10); treeMap.put(d2, 15); treeMap.put(d3, 5); treeMap.put(d4, 20); for (Entry&lt;Dog, Integer&gt; entry : treeMap.entrySet()) &#123; System.out.println(entry.getKey() + \" - \" + entry.getValue()); &#125; &#125;&#125; Output: 123Exception in thread \"main\" java.lang.ClassCastException: collection.Dog cannot be cast to java.lang.Comparable at java.util.TreeMap.put(Unknown Source) at collection.TestHashMap.main(TestHashMap.java:35) Since TreeMaps are sorted by keys, the object for key has to be able to compare with each other, that’s why it has to implement Comparable interface. For example, you use String as key, because String implements Comparable interface. Let’s change the Dog, and make it comparable. 12345678910111213141516171819202122232425262728293031323334353637class Dog implements Comparable&lt;Dog&gt;&#123; String color; int size; Dog(String c, int s) &#123; color = c; size = s; &#125; public String toString()&#123; return color + \" dog\"; &#125; @Override public int compareTo(Dog o) &#123; return o.size - this.size; &#125;&#125;public class TestTreeMap &#123; public static void main(String[] args) &#123; Dog d1 = new Dog(\"red\", 30); Dog d2 = new Dog(\"black\", 20); Dog d3 = new Dog(\"white\", 10); Dog d4 = new Dog(\"white\", 10); TreeMap&lt;Dog, Integer&gt; treeMap = new TreeMap&lt;Dog, Integer&gt;(); treeMap.put(d1, 10); treeMap.put(d2, 15); treeMap.put(d3, 5); treeMap.put(d4, 20); for (Entry&lt;Dog, Integer&gt; entry : treeMap.entrySet()) &#123; System.out.println(entry.getKey() + \" - \" + entry.getValue()); &#125; &#125;&#125; Output: 123red dog - 10black dog - 15white dog - 20 It is sorted by key, i.e., dog size in this case. If “Dog d4 = new Dog(“white”, 10);” is replaced with “Dog d4 = new Dog(“white”, 40);”, the output would be: 1234white dog - 40red dog - 10black dog - 15white dog - 5 The reason is that TreeMap now uses compareTo() method to compare keys. Different sizes make different dogs! 4. HashtableFrom Java Doc: The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls. 5. LinkedHashMapLinkedHashMap is a subclass of HashMap. That means it inherits the features of HashMap. In addition, the linked list preserves the insertion-order. Let’s replace the HashMap with LinkedHashMap using the same code used for HashMap. 123456789101112131415161718192021222324252627282930313233343536373839class Dog &#123; String color; Dog(String c) &#123; color = c; &#125; public boolean equals(Object o) &#123; return ((Dog) o).color.equals(this.color); &#125; public int hashCode() &#123; return color.length(); &#125; public String toString()&#123; return color + \" dog\"; &#125;&#125;public class TestHashMap &#123; public static void main(String[] args) &#123; Dog d1 = new Dog(\"red\"); Dog d2 = new Dog(\"black\"); Dog d3 = new Dog(\"white\"); Dog d4 = new Dog(\"white\"); LinkedHashMap&lt;Dog, Integer&gt; linkedHashMap = new LinkedHashMap&lt;Dog, Integer&gt;(); linkedHashMap.put(d1, 10); linkedHashMap.put(d2, 15); linkedHashMap.put(d3, 5); linkedHashMap.put(d4, 20); for (Entry&lt;Dog, Integer&gt; entry : linkedHashMap.entrySet()) &#123; System.out.println(entry.getKey() + \" - \" + entry.getValue()); &#125; &#125;&#125; Output is: 123red dog - 10black dog - 15white dog - 20 The difference is that if we use HashMap the output could be the following - the insertion order is not preserved. 123red dog - 10white dog - 20black dog - 15","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://qinjiangbo.com/tags/JDK8/"},{"name":"map","slug":"map","permalink":"http://qinjiangbo.com/tags/map/"}]},{"title":"static静态代码块，静态变量等加载顺序研究","slug":"static-block-load-ordering","date":"2016-04-12T13:43:13.000Z","updated":"2016-10-19T15:54:23.000Z","comments":true,"path":"static-block-load-ordering.html","link":"","permalink":"http://qinjiangbo.com/static-block-load-ordering.html","excerpt":"","text":"一直很纠结static代码块和static静态变量的加载顺序，网上的教程良莠不齐，决定自己亲自试一下，毕竟实践才是检验真理的唯一标准，实践过才有发言权！好啦，先看代码： 父类代码: 123456789101112131415161718192021222324252627282930313233343536public class StaticBlock &#123; &#123; System.out.println(\"Just one parent normal line!\"); &#125; private final static int e = 8; &#123; System.out.println(\"I am final static field e!\"); &#125; private static int d = 7; &#123; System.out.println(\"I am static field d!\"); &#125; static &#123; System.out.println(\"I am static block!\"); &#125; private static int a = 7; &#123; System.out.println(\"I am static field a!\"); &#125; private final static int b = 8; &#123; System.out.println(\"I am final static field b!\"); &#125; public StaticBlock()&#123; System.out.println(\"I am constructor!\"); &#125; public int c = 9;&#125; 子类代码: 1234567891011121314151617181920212223242526272829303132333435public class SubStaticBlock extends StaticBlock &#123; &#123; System.out.println(\"Just one sub normal line!\"); &#125; private final static int e = 8; &#123; System.out.println(\"I am sub final static field e!\"); &#125; private static int d = 7; &#123; System.out.println(\"I am sub static field d!\"); &#125; static &#123; System.out.println(\"I am sub static block!\"); &#125; private static int a = 7; &#123; System.out.println(\"I am sub static field a!\"); &#125; private final static int b = 8; &#123; System.out.println(\"I am sub final static field b!\"); &#125; public SubStaticBlock()&#123; System.out.println(\"I am sub constructor!\"); &#125; public int c = 9;&#125; 子类与父类在打印语句里面最大的区别就是多了一个sub对吧。 好，我们先单纯地看一下父类的代码执行情况： 12345678I am static block!Just one parent normal line!I am final static field e!I am static field d!I am static field a!I am final static field b!I am constructor!c is 9 优先加载的是static代码块，其次是写在最前面的普通代码块，然后才是第二的final static 静态变量e，接着就是static变量d和a，然后又是final static变量b，最后是constructor对吧，就是这个顺序的。 那么子类加载的情况如何呢？ 123456789101112131415I am static block!I am sub static block!Just one parent normal line!I am final static field e!I am static field d!I am static field a!I am final static field b!I am constructor!Just one sub normal line!I am sub final static field e!I am sub static field d!I am sub static field a!I am sub final static field b!I am sub constructor!c is 9 可以看到，static代码在子类和父类都优先执行了，其次是父类的代码按照顺序先执行，再次是子类的代码按照顺序执行。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://qinjiangbo.com/tags/JDK8/"},{"name":"static","slug":"static","permalink":"http://qinjiangbo.com/tags/static/"},{"name":"加载顺序","slug":"加载顺序","permalink":"http://qinjiangbo.com/tags/加载顺序/"}]},{"title":"Ubuntu开发笔记","slug":"notes-of-development-on-ubuntu","date":"2016-04-11T15:07:11.000Z","updated":"2016-10-19T15:53:55.000Z","comments":true,"path":"notes-of-development-on-ubuntu.html","link":"","permalink":"http://qinjiangbo.com/notes-of-development-on-ubuntu.html","excerpt":"","text":"安装JDK解压文件，文件夹为jdk 1.8.0_20，并且sudo gedit /etc/environment 在后面加入以下几行： 123PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/lib/jdk1.7.0/bin\" CLASSPATH=.:/usr/local/lib/jdk1.7.0/lib JAVA_HOME=/usr/local/lib/jdk1.7.0 安装mysql命令sudo apt-get install mysql-server 安装图形化界面sudo apt-get install mysql-admin 启动服务sudo service mysql start 关闭服务sudo service mysql stop 安装mysql workbench(先进入包所在目录) sudo dpkg -i ./mysql-workbench-community-6.1.7-1ubu1404-amd64.deb sql 接下来会报一系列依赖错误，一个一个去安装缺省的包sudo apt-get install [package_name] 安装Tomcat只需要在环境变量里面增加tomcat的bin路径 123PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/richard/jdk1.8.0_20/bin:/home/richard/apache-tomcat-8.0.12/bin\"CLASSPATH=\"/home/richard/jdk1.8.0_20/lib\"JAVA_HOME=\"/home/richard/jdk1.8.0_20\" 注意，后面如果报错，就在catalin.sh文件第一行加上JAVA_HOME=”/home/richard/jdk1.8.0_20” 安装PHPphp的安装要注意: sudo gedit /etc/apache2/sites-enabled/000-default.conf 修改DocumentRoot为/var/www/（删掉默认的/html/） apache2配置的时候要注意以后服务器名会变，所以加上 12# Server NameServerName 127.0.0.1 apache2默认路径更改cd /etc/apache2/sites-enabled/sudo gedit 000-default.conf修改一下DocumentRoot即可 12345678# DocumentRoot /var/www/DocumentRoot /home/richard/workspace/&lt;Directory /home/richard/workspace/&gt; Options Indexes FollowSymLinks Multiviews AllowOverride all Order allow,deny Allow from all&lt;/Directory&gt; 注意！！！需要修改workspace目录的读写权限 sudo chmod 777 -R /home/richard/workspacephp5安装以后会改变默认权限cd /etc/apache2/sudo gedit apache2.conf修改以下内容 12345&lt;Directory /&gt;Options FollowSymLinksAllowOverride NoneRequire all granted&lt;!-- 这个默认是deny,会造成403,permission denied --&gt;&lt;/Directory&gt; Apache2服务器重启sudo /etc/init.d/apache2 restart 管理工具phpmyadmin404解决方法Include /etc/phpmyadmin/apache.conf(目录同上述的文件目录一样) tomcat设置开机启动cd /etcsudo gedit rc.local 添加startup.sh的路径即可cd /home/richard/apache-tomcat-8.0.12/bin &amp;&amp; ./startup.sh 配置JAVA环境sudo gvim /etc/environment 打开环境配置文件。对了，这一步各们不一定要用 gvim 去打开，因为你不一定装了gvim，用 gedit, vi 等打开也一样。不熟悉 vim 的请使用 gedit打开后可以看到: PATH=”/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games” 一行文字，你们的可能跟我的有些出入。将其修改为： 123PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/lib/jdk1.7.0/bin\" CLASSPATH=.:/usr/local/lib/jdk1.7.0/lib JAVA_HOME=/usr/local/lib/jdk1.7.0 其中的jvm/jdk1.7.0等请跟据自己下载的安装包和安装目录对号修改。然后重新加载.bashrc source ~/.bashrc 5、到这里后运行 javac, java, 等命令还是不能用，和 windows 安装配置后就可以用不一样。接下来再执行下面命令： 1234sudo update-alternatives --install /usr/bin/java java /home/richard/Softwares/jdk1.8.0_25/bin/java 300 sudo update-alternatives --install /usr/bin/javac javac /home/richard/Softwares/jdk1.8.0_25/bin/javac 300 sudo update-alternatives --install /usr/bin/javap javap /home/richard/Softwares/jdk1.8.0_25/bin/javap 300 sudo update-alternatives --install /usr/bin/javadoc javadoc /home/richard/Softwares/jdk1.8.0_25/bin/javadoc 300 6,sudo gedit /etc/profile 123export JAVA_HOME=/home/richard/Softwares/jdk1.8.0_25export PATH=PATH:JAVA_HOME/bin:JAVA_HOME/jre/binexport CLASSPATH=.:JAVA_HOME/lib/dt.jar: JAVA_HOME/lib/tools.jar LAMP+phpmyadmin安装教程一.安装1.安装LAMP在新立得软件包管理器中选择 编辑－－使用任务分组标记软件包 在打开的窗口中 勾选 LAMP SERVER 然后确定。 在主窗口中 点击绿色的对号 应用 按钮 好了 。接下来就是等待…等待新立得 自动下载安装完。 中间会有一次提示输入mysql的root用户的密码 您还可以在终端模式下，通过命令行安装：sudo apt-get install apache2 libapache2-mod-php5 php5 php5-gd mysql-server php5-mysql phpmyadmin 2.安装phpmyadmin终端中运行命令sudo apt-get install phpmyadmin 二.配置1&gt; apache 的配置文件路径 /etc/apache2/apache2.conf2&gt; php.ini 路径 /etc/php5/apache2/php5.ini3&gt; mysql配置文件 路径 /etc/mysql/my.cnf4&gt; phpmyadmin配置文件路径 /etc/phpmyadmin/apache.conf5&gt; 网站根目录 /var/www 1. 配置apache终端中 使用命令sudo gedit /etc/apache2/apache2.conf在配置文件最后面加入下面几行：添加文件类型支持AddType application/x-httpd-php .php .htm .html默认字符集 根据自己需要AddDefaultCharset UTF-8服务器地址ServerName 127.0.0.1添加首页文件 三个的顺序可以换 前面的访问优先 （当然你也可以加别的 比如default.php）DirectoryIndex index.htm index.html index.php 2.配置PHP5这个没什么好说的 根据个人自己需要下面是默认时区;default.timezone=去掉前面的分号 后面加个PRC 。表示中华人民共和国（就是GMT＋8时区）default.timezone= PRC 3.配置mysqlsudo gedit /etc/mysql/my.cnf这里有一个地方要注意 因为默认是只允许本地访问数据库的 如果你有需要 可以打开。 bind-address 127.0.0.1这一句是限制只能本地访问mysql的。如果有需要其他机器访问 把这句话用#注释掉 # bind-address 127.0.0.1 4.配置phpmyadminphpmyadmin 默认并不是安装在 /var/www下面的而是在 /usr/share/phpmyadmin 你可以把phpmyadmin复制过去 或者 网上有人说你可以创建一个链接 然后把链接复制过去（没有试过） 然后 终端中运行命令 sudo gedit /etc/phpmyadmin/apache.conf 然后把下面两句的路径 改为/var/www/phpmyadmin Alias /phpmyadmin /usr/share/phpmyadmin 改为： Alias /phpmyadmin /var/www/phpmyadmin 符：常用命令 重启apachesudo /etc/init.d/apache2 restart 重启mysqlsudo /etc/init.d/mysql restart至此 LAMP环境配置成功,试一下 echo phpinfo(); 吧！ LAMP并没有那么神秘！除去下载的时间，整个配置过程决不会花费您五分钟。 GD库的安装 sudo apt-get install php5-gd 记得装完重启apache sudo /etc/init.d/apache2 restart 启用 mod_rewrite 模块 sudo a2enmod rewrite Sublime text 2 安装ubuntu 12.04 sublime text 2 破解 将sublime_text文件复制一份并重命名为sublime_text.bak做一个备份 用sublime text 2打开sublime_text.bak文件，搜索 3342 并替换为 3242(所有都替换)， 然后保存 关闭 sublime text 2应用程序， 并删除 sublime_text 文件, 把备份文件sublime_text.bak修改为 sublime_text.bak 输入序列号 打开sublime_text，点击help-&gt;enter lisence key，在弹出对话框粘帖以下内容：（从——BEGIN到LICENSE——） 12345678910111213—–BEGIN LICENSE—–USAUnlimited User LicenseEA7E-1640763D05839CA08BDA7B0103B5BABF0150195EE53CC33B569858AFD553F080A9BC1F678C88A1342AC92CA596FE775E70145A0EE55DC2F8DE3C4ED6B5B02FD4DB3C493FCE3EE61FC0588CDAFAAD731BB47FFD047777D02A5BE92202B3D3EB59A696A69DFEF6687D16FCD4443556912A1F6282DA125263C5BC270CEE7664B5D0CEB9—–END LICENSE—– Ubuntu Nginx 安装及其配置Nginx安装3.1 安装Nginx 在线安装 sudo apt-get install nginx Nginx的版本是1.2.1 ubuntu安装Nginx之后的文件结构大致为： 所有的配置文件都在/etc/nginx下，并且每个虚拟主机已经安排在了/etc/nginx/sites-available下 启动程序文件在/usr/sbin/nginx 日志放在了/var/log/nginx中，分别是access.log和error.log 并已经在/etc/init.d/下创建了启动脚本nginx 默认的虚拟主机的目录设置在了/usr/share/nginx/www 源代码安装 下载地址：http://nginx.org/download/ 我这里下载的是 nginx-1.3.9.tar.gz，安装过程很简单，如下： 123./configuremakemake install 安装成功之后，nginx放置在/usr/local/nginx目录下，主要的配置文件为conf目录下的nginx.conf， nginx的启动文件在sbin目录下的nginx文件。 3.2 启动Nginx 在线安装的启动过程sudo /etc/init.d/nginx start 源代码安装的启动过程 12cd /usr/local/nginxsbin/nginx 然后就可以访问了，http://localhost/ ， 一切正常！如果不能访问，先不要继续，看看是什么原因，解决之后再继续。 如果你的机器同时安装了Apache，那上面的访问方式就不能使用了，而且nginx都可能启动不了，这是因为它们都是用了80这个端口。我们这里将nginx的端口修改为8080，这里主要修改nginx的配置文件nginx.conf，将一下这一行 listen 80; 修改为 listen 8080; 然后就可以访问了，http://localhost:8080/ 。 3.3 安装PHP和MySQLsudo apt-get install php5-cli php5-cgi mysql-server php5-mysql 3.4 测试Nginx对PHP的支持(1). 重新启动nginx: /etc/init.d/nginx restart (2). 启动FastCGI: 12spawn-fcgi -a 127.0.0.1 -p 9000 -C 10 -u www-data -f /usr/bin/php-cgispawn-fcgi启动出现错误时，查看php-cgi是否安装，如果么有的话，安装php5-cgi。 sudo apt-get install php5-cgi (3). 测试 打开http://localhost/phpinfo.php (4). Nginx配置 Nginx的配置文件是/etc/nginx/nginx.conf，其中设置了一些必要的参数，我们发现其中这样的语句： include /etc/nginx/sites-enabled/* 可以看出/etc/nginx/sites-enabled/default文件也是一个核心的配置文件，其中包含了主要的配置信息， 如服务器跟目录、服务器名称、location信息和server信息。 对于源代码安装的nginx，配置文件为/usr/local/nginx/conf/nginx.conf。 下面主要说明location的匹配规则： = 前缀的指令严格匹配这个查询。如果找到，停止搜索。 剩下的常规字符串，最长的匹配优先使用。如果这个匹配使用 ^~ 前缀，搜索停止。 正则表达式，按配置文件里的顺序，第一个匹配的被使用。 如果第三步产生匹配，则使用这个结果。否则使用第二步的匹配结果。 在location中可以使用常规字符串和正则表达式。 如果使用正则表达式，你必须使用以下规则： （1）~* 前缀选择不区分大小写的匹配 （2）~ 选择区分大小写的匹配 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546location = / &#123; \\# 只匹配 / 查询。 [ configuration A ]&#125;location / &#123; \\# 匹配任何查询，因为所有请求都以 / 开头。 \\# 但是正则表达式规则和长的块规则将被优先和查询匹配。 [ configuration B ]&#125; location ^~ /images/ &#123; \\# 匹配任何以 /images/ 开头的任何查询并且停止搜索。\\# 任何正则表达式将不会被测试。 [ configuration C ] &#125; location ~* \\.(gif|jpg|jpeg) &#123;\\# 匹配任何以 gif、jpg 或 jpeg 结尾的请求。\\# 然而所有 /images/ 目录的请求将使用 Configuration C。 [ configuration D ] &#125; 这里你还要对正则表达式有一定的了解！！！ PDO常用方法及其应用 PDO::query() 主要是用于有记录结果返回的操作，特别是SELECT操作 PDO::exec() 主要是针对没有结果集合返回的操作，如INSERT、UPDATE等操作 PDO::lastInsertId() 返回上次插入操作，主键列类型是自增的最后的自增ID PDOStatement::fetch() 是用来获取一条记录 PDOStatement::fetchAll() 是获取所有记录集到一个中","categories":[{"name":"架构师","slug":"架构师","permalink":"http://qinjiangbo.com/categories/架构师/"},{"name":"Linux","slug":"架构师/Linux","permalink":"http://qinjiangbo.com/categories/架构师/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://qinjiangbo.com/tags/Linux/"},{"name":"开发经验","slug":"开发经验","permalink":"http://qinjiangbo.com/tags/开发经验/"}]},{"title":"关于List-contains方法的一些思考","slug":"thought-about-list-contains-method","date":"2016-04-09T13:34:14.000Z","updated":"2016-10-19T15:54:16.000Z","comments":true,"path":"thought-about-list-contains-method.html","link":"","permalink":"http://qinjiangbo.com/thought-about-list-contains-method.html","excerpt":"","text":"实现了一个单链表，尤其是写contains方法的时候陷入了一个瓶颈，该方法对于String， Integer， Float， Double等等数据类型有效，对于对象却无效，我在想是我的实现的代码有问题吗？ 代码如下： 12345678910111213141516171819202122232425262728293031323334/** * 判断某个元素是否在链表中 * @param element * @return 若在即为true，不在即为false */public boolean contains(E element) &#123; return (getIndexOf(element) != -1);&#125;/** * 获取某个元素的索引, 参考双向链接表的实现 * @param element * @return */public int getIndexOf(E element) &#123; int index = 0; if (element == null) &#123; for (Node&lt;E&gt; node = first; node != null; node = node.next) &#123; if (node.element == null) &#123; return index; &#125; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; node = first; node != null; node = node.next) &#123; if (node.element.equals(element)) &#123; return index; &#125; index++; &#125; &#125; return -1;&#125; 发现这里面是没有问题的，我采用的是类似与LinkedList的实现方式，然后再来测试对象的，发现持续报错！于是我又继续测试Java自带的一些List的实现类，试了两个，ArrayList和LinkedList，然后结果就是contains一直显示false！！！ 查看了equals最初的源码，也就是所有类的祖先Object类，发现了这个： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 原来String以及其它几个基本类型都自己实现了equals方法，于是我就想，User类和String都是属于类，他们的实例不是基本类型，所以他们必须得自己单独实现自己的equals方法。然后下面就是User类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class User&#123; private int age; private String name; private String gender; public User(int age, String name, String gender) &#123; this.age = age; this.name = name; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"age=\" + age + \", name='\" + name + '\\'' + \", gender='\" + gender + '\\'' + '&#125;'; &#125; /** * 重写 equals方法 * @param object * @return */ @Override public boolean equals(Object object) &#123; if (object instanceof User) &#123; User otherUser = (User) object; if (this.age == otherUser.getAge() &amp;&amp; this.gender.equals(otherUser.getGender()) &amp;&amp; this.name.equals(otherUser.getName())) &#123; return true; &#125; &#125; return false; &#125;&#125; 从最后这个代码可以看出，我们是重载了equals方法，注意重载的时候参数类型一定要相同，否则绝对报错！如果类型以及个数不一样，那就是重写了。这点得非常小心！然后再测试，一切OK！","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://qinjiangbo.com/tags/JDK8/"},{"name":"List","slug":"List","permalink":"http://qinjiangbo.com/tags/List/"},{"name":"contains方法","slug":"contains方法","permalink":"http://qinjiangbo.com/tags/contains方法/"}]},{"title":"Java泛型中E、T、K、V等的含义","slug":"meanings-of-keywords-in-generic","date":"2016-04-08T13:28:09.000Z","updated":"2016-10-19T15:54:06.000Z","comments":true,"path":"meanings-of-keywords-in-generic.html","link":"","permalink":"http://qinjiangbo.com/meanings-of-keywords-in-generic.html","excerpt":"","text":"Java泛型中的标记符含义： E - Element (在集合中使用，因为集合中存放的是元素) T - Type（Java 类） K - Key（键） V - Value（值） N - Number（数值类型） ? - 表示不确定的java类型 S、U、V - 2nd、3rd、4th types Object跟这些标记符代表的java类型有啥区别呢？ Object是所有类的根类，任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。","categories":[{"name":"开发技术","slug":"开发技术","permalink":"http://qinjiangbo.com/categories/开发技术/"},{"name":"Java","slug":"开发技术/Java","permalink":"http://qinjiangbo.com/categories/开发技术/Java/"}],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://qinjiangbo.com/tags/JDK8/"}]}]}